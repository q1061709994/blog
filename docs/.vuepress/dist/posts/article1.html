<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.49" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://github.com/q1061709994/blog/blog/posts/article1.html"><meta property="og:site_name" content="Huan"><meta property="og:title" content="刷题笔记"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-30T02:56:49.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="huan"><meta property="article:tag" content="数据结构与算法"><meta property="article:published_time" content="2022-01-02T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-30T02:56:49.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="icon" type="image/x-icon" href="/blog/favicon.ico"><title>刷题笔记 | Huan</title><meta name="description" content="a blog project">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.4f94a94d.css">
    <link rel="modulepreload" href="/blog/assets/app.c628af9c.js"><link rel="modulepreload" href="/blog/assets/article1.html.9c16dfa3.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/blog/assets/article1.html.7e531b1e.js"><link rel="prefetch" href="/blog/assets/index.html.f19f41a4.js"><link rel="prefetch" href="/blog/assets/slide.html.3aaec561.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.c0666770.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.b17ce4bc.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.a21f6e7c.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.addf404c.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.87bc2c3e.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.cb546c6e.js"><link rel="prefetch" href="/blog/assets/index.html.d8bb1f63.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.060544bf.js"><link rel="prefetch" href="/blog/assets/article10.html.c5b90527.js"><link rel="prefetch" href="/blog/assets/article11.html.2f80a0ac.js"><link rel="prefetch" href="/blog/assets/article12.html.d1755287.js"><link rel="prefetch" href="/blog/assets/article2.html.c9a4b6fa.js"><link rel="prefetch" href="/blog/assets/article3.html.c3b12665.js"><link rel="prefetch" href="/blog/assets/article9.html.5972bafc.js"><link rel="prefetch" href="/blog/assets/index.html.bb24b589.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.50e04080.js"><link rel="prefetch" href="/blog/assets/Database.html.647c9082.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.4d478bbb.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.81b6ad1c.js"><link rel="prefetch" href="/blog/assets/disable.html.8423cfb1.js"><link rel="prefetch" href="/blog/assets/encrypt.html.b4588a12.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.a8e96087.js"><link rel="prefetch" href="/blog/assets/markdown.html.e5e200b9.js"><link rel="prefetch" href="/blog/assets/network.html.83ef10c0.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.aef72a2b.js"><link rel="prefetch" href="/blog/assets/page.html.5e8e43ec.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.e04386e3.js"><link rel="prefetch" href="/blog/assets/index.html.c72101b9.js"><link rel="prefetch" href="/blog/assets/article3.html.94707ec0.js"><link rel="prefetch" href="/blog/assets/article4.html.566c6880.js"><link rel="prefetch" href="/blog/assets/article5.html.baf3eb3b.js"><link rel="prefetch" href="/blog/assets/article6.html.ef17c94c.js"><link rel="prefetch" href="/blog/assets/article7.html.bdc9e74f.js"><link rel="prefetch" href="/blog/assets/article8.html.1179c480.js"><link rel="prefetch" href="/blog/assets/716-717.html.a5ca6819.js"><link rel="prefetch" href="/blog/assets/718-719.html.2b6b0c35.js"><link rel="prefetch" href="/blog/assets/720-721.html.37e47418.js"><link rel="prefetch" href="/blog/assets/722-723.html.04256455.js"><link rel="prefetch" href="/blog/assets/724-725.html.876c3e1f.js"><link rel="prefetch" href="/blog/assets/726-727.html.a2197340.js"><link rel="prefetch" href="/blog/assets/728-729.html.6bd1bdba.js"><link rel="prefetch" href="/blog/assets/730-731.html.5480bde6.js"><link rel="prefetch" href="/blog/assets/801-805.html.167ba2bc.js"><link rel="prefetch" href="/blog/assets/806-809.html.598ab85e.js"><link rel="prefetch" href="/blog/assets/810-811.html.7dfd03bb.js"><link rel="prefetch" href="/blog/assets/812-813.html.83728dbf.js"><link rel="prefetch" href="/blog/assets/815-816.html.4624d874.js"><link rel="prefetch" href="/blog/assets/404.html.598608ea.js"><link rel="prefetch" href="/blog/assets/index.html.f9873869.js"><link rel="prefetch" href="/blog/assets/index.html.29e7af3b.js"><link rel="prefetch" href="/blog/assets/index.html.c16d2cab.js"><link rel="prefetch" href="/blog/assets/index.html.4002ce24.js"><link rel="prefetch" href="/blog/assets/index.html.56b7de82.js"><link rel="prefetch" href="/blog/assets/index.html.3d141104.js"><link rel="prefetch" href="/blog/assets/index.html.78fbd65d.js"><link rel="prefetch" href="/blog/assets/index.html.48c256bb.js"><link rel="prefetch" href="/blog/assets/index.html.f2e19447.js"><link rel="prefetch" href="/blog/assets/index.html.70e02a00.js"><link rel="prefetch" href="/blog/assets/index.html.3fd218c9.js"><link rel="prefetch" href="/blog/assets/index.html.beb1e369.js"><link rel="prefetch" href="/blog/assets/index.html.97e1466d.js"><link rel="prefetch" href="/blog/assets/index.html.669e7212.js"><link rel="prefetch" href="/blog/assets/index.html.5813e0a0.js"><link rel="prefetch" href="/blog/assets/index.html.ab2fc4e7.js"><link rel="prefetch" href="/blog/assets/index.html.19513c78.js"><link rel="prefetch" href="/blog/assets/index.html.3a68a554.js"><link rel="prefetch" href="/blog/assets/index.html.c2eda9f4.js"><link rel="prefetch" href="/blog/assets/index.html.7f7f1beb.js"><link rel="prefetch" href="/blog/assets/index.html.98e0c7fb.js"><link rel="prefetch" href="/blog/assets/index.html.16bcb0f4.js"><link rel="prefetch" href="/blog/assets/index.html.a1444922.js"><link rel="prefetch" href="/blog/assets/index.html.487a5bce.js"><link rel="prefetch" href="/blog/assets/index.html.229c50fb.js"><link rel="prefetch" href="/blog/assets/slide.html.a03c9ea7.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.aebf1207.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.978fffeb.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.ce46bd0a.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.2d391c36.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.57b3a0a2.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.31f4e2a8.js"><link rel="prefetch" href="/blog/assets/index.html.0058d24e.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.a428b839.js"><link rel="prefetch" href="/blog/assets/article10.html.1b250c1b.js"><link rel="prefetch" href="/blog/assets/article11.html.ce1c65ec.js"><link rel="prefetch" href="/blog/assets/article12.html.7cf4c57d.js"><link rel="prefetch" href="/blog/assets/article2.html.7eb2757c.js"><link rel="prefetch" href="/blog/assets/article3.html.44f83ca8.js"><link rel="prefetch" href="/blog/assets/article9.html.dc2dff96.js"><link rel="prefetch" href="/blog/assets/index.html.0908d3c0.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.76b7f62f.js"><link rel="prefetch" href="/blog/assets/Database.html.87ef128c.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.c41e987a.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.6cf4966f.js"><link rel="prefetch" href="/blog/assets/disable.html.a60a654c.js"><link rel="prefetch" href="/blog/assets/encrypt.html.88459654.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.eb8df484.js"><link rel="prefetch" href="/blog/assets/markdown.html.bc150ae3.js"><link rel="prefetch" href="/blog/assets/network.html.8bd75bde.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.3333fe3b.js"><link rel="prefetch" href="/blog/assets/page.html.94401bc1.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.954c2479.js"><link rel="prefetch" href="/blog/assets/index.html.294a8b34.js"><link rel="prefetch" href="/blog/assets/article3.html.b4fea1b8.js"><link rel="prefetch" href="/blog/assets/article4.html.09cea009.js"><link rel="prefetch" href="/blog/assets/article5.html.8f760304.js"><link rel="prefetch" href="/blog/assets/article6.html.b9b6b9f2.js"><link rel="prefetch" href="/blog/assets/article7.html.2f04adbf.js"><link rel="prefetch" href="/blog/assets/article8.html.f58df5b8.js"><link rel="prefetch" href="/blog/assets/716-717.html.9dc458d0.js"><link rel="prefetch" href="/blog/assets/718-719.html.685d4858.js"><link rel="prefetch" href="/blog/assets/720-721.html.3f5dad59.js"><link rel="prefetch" href="/blog/assets/722-723.html.b175bf50.js"><link rel="prefetch" href="/blog/assets/724-725.html.f33e6dea.js"><link rel="prefetch" href="/blog/assets/726-727.html.4685a289.js"><link rel="prefetch" href="/blog/assets/728-729.html.1466f979.js"><link rel="prefetch" href="/blog/assets/730-731.html.2d9e0697.js"><link rel="prefetch" href="/blog/assets/801-805.html.35c4c451.js"><link rel="prefetch" href="/blog/assets/806-809.html.c9efad55.js"><link rel="prefetch" href="/blog/assets/810-811.html.efff9f79.js"><link rel="prefetch" href="/blog/assets/812-813.html.55dcfcfb.js"><link rel="prefetch" href="/blog/assets/815-816.html.4211f4ec.js"><link rel="prefetch" href="/blog/assets/404.html.7dc7d5d9.js"><link rel="prefetch" href="/blog/assets/index.html.31008c7e.js"><link rel="prefetch" href="/blog/assets/index.html.11b8f0ee.js"><link rel="prefetch" href="/blog/assets/index.html.842c4e75.js"><link rel="prefetch" href="/blog/assets/index.html.8bf684d2.js"><link rel="prefetch" href="/blog/assets/index.html.e6a9a492.js"><link rel="prefetch" href="/blog/assets/index.html.829ccfc4.js"><link rel="prefetch" href="/blog/assets/index.html.f90e11ab.js"><link rel="prefetch" href="/blog/assets/index.html.6410c090.js"><link rel="prefetch" href="/blog/assets/index.html.f26b28fe.js"><link rel="prefetch" href="/blog/assets/index.html.de7fb811.js"><link rel="prefetch" href="/blog/assets/index.html.17c49be7.js"><link rel="prefetch" href="/blog/assets/index.html.7f6821a5.js"><link rel="prefetch" href="/blog/assets/index.html.1e4b1b7b.js"><link rel="prefetch" href="/blog/assets/index.html.7ca14074.js"><link rel="prefetch" href="/blog/assets/index.html.d0f574db.js"><link rel="prefetch" href="/blog/assets/index.html.ceb720f7.js"><link rel="prefetch" href="/blog/assets/index.html.af575ecc.js"><link rel="prefetch" href="/blog/assets/index.html.8fa72650.js"><link rel="prefetch" href="/blog/assets/index.html.c549acf2.js"><link rel="prefetch" href="/blog/assets/index.html.c96fb014.js"><link rel="prefetch" href="/blog/assets/index.html.3df16dd9.js"><link rel="prefetch" href="/blog/assets/index.html.769c69bf.js"><link rel="prefetch" href="/blog/assets/index.html.2ed929e0.js"><link rel="prefetch" href="/blog/assets/index.html.faabca17.js"><link rel="prefetch" href="/blog/assets/404.10cc9a97.js"><link rel="prefetch" href="/blog/assets/Layout.76da7024.js"><link rel="prefetch" href="/blog/assets/Slide.db40c871.js"><link rel="prefetch" href="/blog/assets/Blog.2808f186.js"><link rel="prefetch" href="/blog/assets/auto.esm.2565cd3a.js"><link rel="prefetch" href="/blog/assets/index.d8a59108.js"><link rel="prefetch" href="/blog/assets/index.1842ee54.js"><link rel="prefetch" href="/blog/assets/mermaid.esm.min.ee1e0284.js"><link rel="prefetch" href="/blog/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/blog/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/blog/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/blog/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/blog/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/blog/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/blog/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/blog/assets/photoswipe.esm.218074cd.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/blog/" class="brand"><img class="logo" src="/blog/logo.svg" alt="Huan"><!----><span class="site-name hide-in-pad">Huan</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/blog/guide/" class="nav-link" aria-label="基础"><span class="icon iconfont icon-creative"></span>基础<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/posts/" class="nav-link active" aria-label="算法"><span class="icon iconfont icon-edit"></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/tem" class="nav-link" aria-label="关于作者"><span class="icon iconfont icon-note"></span>关于作者<!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://github.com/q1061709994/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a aria-current="page" href="/blog/posts/article1.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="刷题笔记"><span class="icon iconfont icon-article"></span>刷题笔记<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#链表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="链表"><!---->链表<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#单调栈" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="单调栈"><!---->单调栈<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#单调队列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="单调队列"><!---->单调队列<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#二分查找" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="二分查找"><!---->二分查找<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#前缀和" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="前缀和"><!---->前缀和<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#trie字典树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Trie字典树"><!---->Trie字典树<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#哈希" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="哈希"><!---->哈希<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#原地哈希" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="原地哈希"><!---->原地哈希<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#模拟" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="模拟"><!---->模拟<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#数论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="数论"><!---->数论<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#滑动窗口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="滑动窗口"><!---->滑动窗口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#双指针" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="双指针"><!---->双指针<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#图论" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="图论"><!---->图论<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#dp" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="DP"><!---->DP<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#bfs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="BFS"><!---->BFS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#dfs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="DFS"><!---->DFS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#并查集" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="并查集"><!---->并查集<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#拓扑排序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="拓扑排序"><!---->拓扑排序<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#贪心" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="贪心"><!---->贪心<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#位运算" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="位运算"><!---->位运算<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article1.html#每日一题系列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="每日一题系列"><!---->每日一题系列<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/blog/posts/article2.html" class="nav-link sidebar-link sidebar-page" aria-label="周赛总结"><span class="icon iconfont icon-article"></span>周赛总结<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/blog/posts/article3.html" class="nav-link sidebar-link sidebar-page" aria-label="算法模板"><span class="icon iconfont icon-article"></span>算法模板<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">暑期集训</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">文章</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-article"></span>刷题笔记</h1><div class="page-info"><span class="author-info" aria-label="作者" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="author-item">huan</span></span><span property="author" content="huan"></span></span><!----><span class="date-info" aria-label="写作日期" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年1月2日</span><meta property="datePublished" content="2022-01-02T00:00:00.000Z"></span><span class="category-info" aria-label="分类" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">算法笔记</li><meta property="articleSection" content="算法笔记"></ul></span><span aria-label="标签" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">数据结构与算法</li></ul><meta property="keywords" content="数据结构与算法"></span><span class="words-info" aria-label="字数" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 41824 字</span><meta property="wordCount" content="41824"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#链表" class="router-link-active router-link-exact-active toc-link level2">链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#单调栈" class="router-link-active router-link-exact-active toc-link level2">单调栈</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#单调队列" class="router-link-active router-link-exact-active toc-link level2">单调队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#二分查找" class="router-link-active router-link-exact-active toc-link level2">二分查找</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#前缀和" class="router-link-active router-link-exact-active toc-link level2">前缀和</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#trie字典树" class="router-link-active router-link-exact-active toc-link level2">Trie字典树</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#哈希" class="router-link-active router-link-exact-active toc-link level2">哈希</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#原地哈希" class="router-link-active router-link-exact-active toc-link level2">原地哈希</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#模拟" class="router-link-active router-link-exact-active toc-link level2">模拟</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#数论" class="router-link-active router-link-exact-active toc-link level2">数论</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#滑动窗口" class="router-link-active router-link-exact-active toc-link level2">滑动窗口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#双指针" class="router-link-active router-link-exact-active toc-link level2">双指针</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#图论" class="router-link-active router-link-exact-active toc-link level2">图论</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#dp" class="router-link-active router-link-exact-active toc-link level2">DP</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#bfs" class="router-link-active router-link-exact-active toc-link level2">BFS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#dfs" class="router-link-active router-link-exact-active toc-link level2">DFS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#并查集" class="router-link-active router-link-exact-active toc-link level2">并查集</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#拓扑排序" class="router-link-active router-link-exact-active toc-link level2">拓扑排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#贪心" class="router-link-active router-link-exact-active toc-link level2">贪心</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#位运算" class="router-link-active router-link-exact-active toc-link level2">位运算</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article1.html#每日一题系列" class="router-link-active router-link-exact-active toc-link level2">每日一题系列</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="链表" tabindex="-1"><a class="header-anchor" href="#链表" aria-hidden="true">#</a> 链表</h2><h4 id="剑指-offer-22-链表中倒数第k个节点" tabindex="-1"><a class="header-anchor" href="#剑指-offer-22-链表中倒数第k个节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 22. 链表中倒数第k个节点 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="剑指-offer-ii-024-反转链表" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-024-反转链表" aria-hidden="true">#</a> <strong><a href="https://leetcode-cn.com/problems/UHnkqh/" target="_blank" rel="noopener noreferrer">剑指 Offer II 024. 反转链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong></h4><h4 id="_1290-二进制链表转整数" tabindex="-1"><a class="header-anchor" href="#_1290-二进制链表转整数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener noreferrer">1290. 二进制链表转整数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1669-合并两个链表" tabindex="-1"><a class="header-anchor" href="#_1669-合并两个链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/merge-in-between-linked-lists/" target="_blank" rel="noopener noreferrer">1669. 合并两个链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_83-删除排序链表中的重复元素" tabindex="-1"><a class="header-anchor" href="#_83-删除排序链表中的重复元素" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener noreferrer">83. 删除排序链表中的重复元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>建立一个新链表，相同的数字只取第一个不一样的</p><h4 id="_24-两两交换链表中的节点" tabindex="-1"><a class="header-anchor" href="#_24-两两交换链表中的节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener noreferrer">24. 两两交换链表中的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>虚拟头节点+暴力</p><h4 id="剑指-offer-ii-023-两个链表的第一个重合节点" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-023-两个链表的第一个重合节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/3u1WK4/" target="_blank" rel="noopener noreferrer">剑指 Offer II 023. 两个链表的第一个重合节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>遍历完一个链表后遍历另一个链表a + c + b等于b + c + a</p><h4 id="_876-链表的中间结点" tabindex="-1"><a class="header-anchor" href="#_876-链表的中间结点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener noreferrer">876. 链表的中间结点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针或者遍历两次</p><h4 id="_1721-交换链表中的节点" tabindex="-1"><a class="header-anchor" href="#_1721-交换链表中的节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/" target="_blank" rel="noopener noreferrer">1721. 交换链表中的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针</p><h4 id="剑指-offer-ii-027-回文链表" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-027-回文链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/aMhZSa/" target="_blank" rel="noopener noreferrer">剑指 Offer II 027. 回文链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>数组+双指针</p><h4 id="面试题-02-04-分割链表" tabindex="-1"><a class="header-anchor" href="#面试题-02-04-分割链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/partition-list-lcci/" target="_blank" rel="noopener noreferrer">面试题 02.04. 分割链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针</p><h4 id="_2-两数相加" tabindex="-1"><a class="header-anchor" href="#_2-两数相加" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener noreferrer">2. 两数相加<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_19-删除链表的倒数第-n-个结点" tabindex="-1"><a class="header-anchor" href="#_19-删除链表的倒数第-n-个结点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener noreferrer">19. 删除链表的倒数第 N 个结点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针+虚拟头节点(当需要特判)</p><h4 id="_445-两数相加-ii" tabindex="-1"><a class="header-anchor" href="#_445-两数相加-ii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener noreferrer">445. 两数相加 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>反转后相加</p><h4 id="_237-删除链表中的节点" tabindex="-1"><a class="header-anchor" href="#_237-删除链表中的节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener noreferrer">237. 删除链表中的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_141-环形链表" tabindex="-1"><a class="header-anchor" href="#_141-环形链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener noreferrer">141. 环形链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>快慢指针</p><h4 id="_142-环形链表-ii" tabindex="-1"><a class="header-anchor" href="#_142-环形链表-ii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener noreferrer">142. 环形链表 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>快慢指针</p><h4 id="_82-删除排序链表中的重复元素-ii" tabindex="-1"><a class="header-anchor" href="#_82-删除排序链表中的重复元素-ii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener noreferrer">82. 删除排序链表中的重复元素 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针</p><h4 id="_203-移除链表元素" tabindex="-1"><a class="header-anchor" href="#_203-移除链表元素" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener noreferrer">203. 移除链表元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_234-回文链表" tabindex="-1"><a class="header-anchor" href="#_234-回文链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener noreferrer">234. 回文链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_143-重排链表" tabindex="-1"><a class="header-anchor" href="#_143-重排链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener noreferrer">143. 重排链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>双指针+寻找中点+链表逆序+链表合并</p><h4 id="_817-链表组件" tabindex="-1"><a class="header-anchor" href="#_817-链表组件" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/linked-list-components/" target="_blank" rel="noopener noreferrer">817. 链表组件<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_328-奇偶链表" tabindex="-1"><a class="header-anchor" href="#_328-奇偶链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener noreferrer">328. 奇偶链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="面试题-02-01-移除重复节点" tabindex="-1"><a class="header-anchor" href="#面试题-02-01-移除重复节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank" rel="noopener noreferrer">面试题 02.01. 移除重复节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_86-分隔链表" tabindex="-1"><a class="header-anchor" href="#_86-分隔链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener noreferrer">86. 分隔链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>相对顺序不能发生变化</p><h4 id="_23-合并k个升序链表" tabindex="-1"><a class="header-anchor" href="#_23-合并k个升序链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener noreferrer">23. 合并K个升序链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.val - o2.val);
        for (ListNode list : lists) {
            if (list == null) continue;
            pq.add(list);
        }
        while (!pq.isEmpty()) {
            ListNode node = pq.poll();
            cur = cur.next = node;
            if (node.next != null) pq.add(node.next);
        }
        return dummy.next;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-ii-029-排序的循环链表" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-029-排序的循环链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/4ueAj6/" target="_blank" rel="noopener noreferrer">剑指 Offer II 029. 排序的循环链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public Node insert(Node head, int insertVal) {
        Node node = new Node(insertVal);
        if (head == null) {
            node.next = node;
            return node;
        }
        Node p = head, q = head.next;
        while (q != head) {
            if (p.val &lt;= node.val &amp;&amp; node.val &lt;= q.val) break;
            if (p.val &gt; q.val) {
                if (p.val &lt; node.val || q.val &gt; node.val) {
                    break;
                }
            }
            p = p.next;
            q = q.next;
        }
        p.next = node;
        node.next = q;
        return head;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_61-旋转链表" tabindex="-1"><a class="header-anchor" href="#_61-旋转链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/rotate-list/" target="_blank" rel="noopener noreferrer">61. 旋转链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (head == null) return null;
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        int num = 0;
        while (a.next != null) {
            num ++ ;
            a = a.next;
        }
        k %= num;
        ListNode b = dummy;
        for (int i = 0; i &lt; num - k; i ++ ) b = b.next;
        a.next = dummy.next;
        dummy.next = b.next;
        b.next = null;
        return dummy.next;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_25-k-个一组翻转链表" tabindex="-1"><a class="header-anchor" href="#_25-k-个一组翻转链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener noreferrer">25. K 个一组翻转链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head; 
        for (ListNode p = dummy;; ) {
            ListNode q = p;
            // 对于链表中的每一个点, 先遍历其后的k个点, 如果遍历完为空, 说明不够k个点
            for (int i = 0; i &lt; k &amp;&amp; q != null; i ++ ) q = q.next;
            if (q == null) break;
            //System.out.println(q.val);
            ListNode a = p.next, b = a.next;
            //开始翻转对k个节点进行内部翻转, 需要翻转k-1次
            for (int i = 0; i &lt; k - 1; i ++ ) {
                ListNode c = b.next;
                b.next = a;
                a = b;
                b = c;
            }
            ListNode c = p.next;
            p.next = a;
            c.next = b;
            // 更新链表到下一个节点
            p = c;
        }
        return dummy.next;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_725-分隔链表" tabindex="-1"><a class="header-anchor" href="#_725-分隔链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/split-linked-list-in-parts/" target="_blank" rel="noopener noreferrer">725. 分隔链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        ListNode[] res = new ListNode[k];
        ListNode cur = head;
        int n = 0;
        while (cur != null) {
            n ++ ;
            cur = cur.next;
        }
        int a = n / k, b = n % k;
        ListNode p = head, pre = null;
        for (int i = 0; i &lt; k; i ++ ) {
            res[i] = p;
            int t = a + (b -- &gt; 0 ? 1 : 0);
            for (int j = 0; j &lt; t; j ++ ) {
                pre = p;
                p = p.next;
            }
            if (pre != null) pre.next = null;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_138-复制带随机指针的链表" tabindex="-1"><a class="header-anchor" href="#_138-复制带随机指针的链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener noreferrer">138. 复制带随机指针的链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：使用哈希进行快速拷贝</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return null;
        Node cur = head;
        Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;();
        //存放旧节点对应的新节点
        while (cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        //再次遍历老链表，进行新链表的连接
        while (cur != null) {
            Node next = cur.next;
            Node random = cur.random;
            map.get(cur).next = map.get(next);
            map.get(cur).random = map.get(random);
            cur = cur.next;
        }
        return map.get(head);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2：不使用额外空间</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) return head;
        Node cur = head;
		//复制节点进行连接 1-&gt;2  ==  1-&gt;1`-&gt;2-&gt;2`
        while (cur != null) {
            Node next = cur.next;
            cur.next = new Node(cur.val);
            cur = cur.next.next = next;
        }
        //连接random
        cur = head;
        while (cur != null) {
            if (cur.random != null) cur.next.random = cur.random.next;
            else cur.next.random = null;
            cur = cur.next.next;
        }
        //分离新链表
        //需要将原链表恢复
        Node res = head.next;
        cur = head;
        while (cur.next != null) {
            Node temp = cur.next;
            cur.next = cur.next.next;
            cur = temp;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_147-对链表进行插入排序" tabindex="-1"><a class="header-anchor" href="#_147-对链表进行插入排序" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/insertion-sort-list/" target="_blank" rel="noopener noreferrer">147. 对链表进行插入排序<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(-1);
        for (var p = head; p != null; ) {
            ListNode cur = dummy, next = p.next;
            while (cur.next != null &amp;&amp; cur.next.val &lt;= p.val) cur = cur.next;
            p.next = cur.next;
            cur.next = p;
            p = next;
        }
        return dummy.next;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="单调栈" tabindex="-1"><a class="header-anchor" href="#单调栈" aria-hidden="true">#</a> 单调栈</h2><p>常见模型：找到每个数左边离他最近比它大/小的数</p><h4 id="_6080-使数组按非递减顺序排列" tabindex="-1"><a class="header-anchor" href="#_6080-使数组按非递减顺序排列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/" target="_blank" rel="noopener noreferrer">6080. 使数组按非递减顺序排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/by-newhar-6k75/
class Solution {
    public int totalSteps(int[] nums) {
    	// 单调栈
        // 1. 每个元素一定时被左侧第一个更大的元素消除的
        // 2. 设 x 消除 y，也就是 [x] .... [y]，那么
        //    中间的 .... 一定先被消除，再 +1 次消除（x 消除 y）
        // 3. 那么，x 被消除所需轮数就是 [....] 中的最大消除轮数 + 1
        int n = nums.length;
        int res = 0;
        int[] f = new int[n];
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i ++ ) {
            int cur = 0;
            while (!s.isEmpty() &amp;&amp; nums[s.peek()] &lt;= nums[i]) {
                cur = Math.max(cur, f[s.peek()]);
                s.pop();
            }
            if (!s.isEmpty()) {
                f[i] = cur + 1;
                res = Math.max(res, f[i]);
            }
            s.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_739-每日温度" tabindex="-1"><a class="header-anchor" href="#_739-每日温度" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener noreferrer">739. 每日温度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] dailyTemperatures(int[] tem) {
        int n = tem.length;
        int[] ans = new int[n];
        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            while (s.size() &gt; 0 &amp;&amp; tem[s.peek()] &lt; tem[i]) {
                ans[s.peek()] = i - s.peek();
                s.pop();
            }
            s.push(i);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_907-子数组的最小值之和" tabindex="-1"><a class="header-anchor" href="#_907-子数组的最小值之和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sum-of-subarray-minimums/" target="_blank" rel="noopener noreferrer">907. 子数组的最小值之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int sumSubarrayMins(int[] arr) {
        int mod = (int)1e9 + 7;
        int n = arr.length;
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        int[] l = new int[n], r = new int[n];
        long ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
			while (!s.isEmpty() &amp;&amp; arr[s.peek()] &gt; arr[i]) s.pop();
            if (s.isEmpty()) l[i] = -1;
            else l[i] = s.peek();
			s.push(i);
		}
        s = new ArrayDeque&lt;&gt;(); 
		for (int i = n - 1; i &gt;= 0; i -- ) {
			while (!s.isEmpty() &amp;&amp; arr[s.peek()] &gt;= arr[i]) s.pop();
            if (s.isEmpty()) r[i] = n;
            else r[i] = s.peek();
			s.push(i);
		}
        for (int i = 0; i &lt; n; i ++ ) {
            ans += (long) (i - l[i]) * (r[i] - i) * arr[i];
            ans %= mod;
        }
        return (int)(ans + mod) % mod;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：单调栈&amp;三次遍历</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def sumSubarrayMins(self, arr: List[int]) -&gt; int:
        n, res, mod = len(arr), 0, 10 ** 9 + 7
        left, s = [-1] * n, deque()
        for i, x in enumerate(arr):
            while s and x &lt; arr[s[-1]]: s.pop()
            if s: left[i] = s[-1]
            s.append(i)
        right, s = [n] * n, deque()
        for i in range(n - 1, -1, -1):
            # 避免因相同数字，重复统计子数组
            while s and arr[i] &lt;= arr[s[-1]]: s.pop()
            if s: right[i] = s[-1]
            s.append(i)
        for i, (x, l, r) in enumerate(zip(arr, left, right)):
            res += x * (i - l) * (r - i)
        return res % mod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：单调栈&amp;两次遍历</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def sumSubarrayMins(self, arr: List[int]) -&gt; int:
        n, res, mod = len(arr), 0, 10 ** 9 + 7
        left, right, s = [-1] * n, [n] * n, deque()
        for i, x in enumerate(arr):
            while s and x &lt;= arr[s[-1]]: 
                right[s.pop()] = i
            if s: left[i] = s[-1]
            s.append(i)
        for i, (x, l, r) in enumerate(zip(arr, left, right)):
            res += x * (i - l) * (r - i)
        return res % mod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：单调栈&amp;一次遍历</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def sumSubarrayMins(self, arr: List[int]) -&gt; int:
    	# 栈顶下面的元素正好也是栈顶的左边界
        arr.append(-1)
        res, mod = 0, 10 ** 9 + 7
        s = [-1]
        for r, x in enumerate(arr):
            while len(s) &gt; 1 and x &lt;= arr[s[-1]]: 
                i = s.pop()
                res += arr[i] * (i - s[-1]) * (r - i)
            s.append(r)
        return res % mod
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-33-二叉搜索树的后序遍历序列" tabindex="-1"><a class="header-anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 33. 二叉搜索树的后序遍历序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean verifyPostorder(int[] pos) {
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        int pre = Integer.MAX_VALUE;
        for (int i = pos.length - 1; i &gt;= 0; i -- ) {
            if (pos[i] &gt; pre) return false;
            //当pos[i]小于栈顶元素时，表示要进入左子树了
            while (!q.isEmpty() &amp;&amp; q.peek() &gt; pos[i]) pre = q.pop();
            q.push(pos[i]);
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_42-接雨水" tabindex="-1"><a class="header-anchor" href="#_42-接雨水" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener noreferrer">42. 接雨水<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法1：单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int trap(int[] h) {
        int ans = 0, n = h.length;
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            while (!q.isEmpty() &amp;&amp; h[q.peek()] &lt; h[i]) {
                int cur = q.pop();
                if (q.isEmpty()) break;
                //考虑每个位置左边和右边 第一个 比自身高的矩形条，以及三个矩形条构成的 U 型，相当于对水的面积按 行 进行拆解。
                //h[q.peek()]为左边第一个比cur高的矩形，h[i]为右边第一个比cur高的矩形
                ans += (i - q.peek() - 1) * (Math.min(h[i], h[q.peek()]) - h[cur]);
            }
            q.push(i);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2：双指针</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int trap(int[] h) {
        int n = h.length;
        int l = 0, r = n - 1, res = 0;
        //记录l, r遍历过的最大值
        int lMax = 0, rMax = 0;
        while (l &lt; r) {
            lMax = Math.max(h[l], lMax);
            rMax = Math.max(h[r], rMax);
            //若lMax较小，则i号柱子的体积由lMax决定，反之
            if (lMax &lt;= rMax) {
                res += lMax - h[l];
                l ++ ;
            } else {
                res += rMax - h[r];
                r -- ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_402-移掉-k-位数字" tabindex="-1"><a class="header-anchor" href="#_402-移掉-k-位数字" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/remove-k-digits/" target="_blank" rel="noopener noreferrer">402. 移掉 K 位数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    //尽可能让最高位小，最高位相同的情况下尽可能让次高位小
    public String removeKdigits(String num, int k) {
        StringBuilder res = new StringBuilder();
        for (char c : num.toCharArray()) {
            while (k &gt; 0 &amp;&amp; res.length() &gt; 0 &amp;&amp; res.charAt(res.length() - 1) &gt; c) {
                k -- ;
                res.delete(res.length() - 1, res.length());
            }
            res.append(c);
        }
        while (k -- &gt; 0) res.delete(res.length() - 1, res.length());
        k = 0;
        //删除前导0
        while (k &lt; res.length() &amp;&amp; res.charAt(k) == &#39;0&#39;) k ++ ;
        return k == res.length() ? &quot;0&quot; : res.substring(k, res.length());
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_84-柱状图中最大的矩形" tabindex="-1"><a class="header-anchor" href="#_84-柱状图中最大的矩形" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener noreferrer">84. 柱状图中最大的矩形<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法1：枚举左右边界</strong></p><p>O（N * N）超时</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int res = 0;
        for (int l = 0; l &lt; n; l ++ ) {
            int h = 100010;
            for (int r = l; r &lt; n; r ++ ) {
                h = Math.min(h, heights[r]);
                res = Math.max(res, h * (r - l + 1));
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2：枚举高度</strong></p><p>O（N * N）超时</p><p><strong>解法3：单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    //找到每个柱形条左边和右边最近的比自己低的矩形条，然后用宽度乘上当前柱形条的高度
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int res = 0;
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            while (!s.isEmpty() &amp;&amp; heights[s.peek()] &gt; heights[i]) {
            	//矩形的高度为h[cur], 宽度由cur两边最近的比h[cur]低的决定
                int cur = s.pop();
                if (s.isEmpty()) 
                    res = Math.max(res, heights[cur] * i);
                else
                    res = Math.max(res, heights[cur] * (i - s.peek() - 1));
            }
            s.push(i);
        }
        //处理栈中其他的数据      
        while (!s.isEmpty()) {
            int cur = s.pop();
            if (s.isEmpty()) 
                res = Math.max(res, heights[cur] * n);
            else
                res = Math.max(res, heights[cur] * (n - s.peek() - 1));
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_768-最多能完成排序的块-ii" tabindex="-1"><a class="header-anchor" href="#_768-最多能完成排序的块-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/" target="_blank" rel="noopener noreferrer">768. 最多能完成排序的块 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxChunksToSorted(int[] arr) {
        //维护每一个块的最大值
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; arr.length; i ++ ) {
            if (s.isEmpty() || arr[i] &gt;= arr[s.peek()]) s.push(i);
            else {
                int x = s.pop();
                //当前数融入之前块的过程
                //直到遇到一个块，使得该块的最大值小于或等于这个新添加的数，
                //或者当前数已经融合了所有块
                while (!s.isEmpty() &amp;&amp; arr[s.peek()] &gt; arr[i])
                    s.pop();
                s.push(x);
            }
        }
        return s.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1124-表现良好的最长时间段" tabindex="-1"><a class="header-anchor" href="#_1124-表现良好的最长时间段" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-well-performing-interval/" target="_blank" rel="noopener noreferrer">1124. 表现良好的最长时间段<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：单调栈&amp;前缀和</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestWPI(int[] h) {
        int n = h.length;
        for (int i = 0; i &lt; n; i ++ ) 
            if (h[i] &gt; 8) h[i] = 1;
            else h[i] = -1;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; i ++ ) 
            s[i + 1] = s[i] + h[i];
        int res = 0;
        ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt;= n; i ++ ) 
            if (stack.isEmpty() || s[stack.peek()] &gt; s[i])
                stack.push(i);
        for (int i = n; i &gt;= 0; i -- ) {
            while (!stack.isEmpty() &amp;&amp; s[stack.peek()] &lt; s[i]) {
                res = Math.max(res, i - stack.peek());
                stack.pop();
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_962-最大宽度坡" tabindex="-1"><a class="header-anchor" href="#_962-最大宽度坡" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-width-ramp/" target="_blank" rel="noopener noreferrer">962. 最大宽度坡<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxWidthRamp(int[] nums) {
        int res = 0;
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i ++ ) 
            if (s.isEmpty() || nums[s.peek()] &gt; nums[i])
                s.push(i);
        for (int i = nums.length - 1; i &gt;= 0; i -- ) 
            while (!s.isEmpty() &amp;&amp; nums[s.peek()] &lt;= nums[i])
                res = Math.max(res, i - s.pop());
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_503-下一个更大元素-ii" tabindex="-1"><a class="header-anchor" href="#_503-下一个更大元素-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank" rel="noopener noreferrer">503. 下一个更大元素 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        var res = new int[n];
        var s = new ArrayDeque&lt;Integer&gt;();
        Arrays.fill(res, -1);
        for (int i = 0; i &lt; n * 2; i ++ ) {
            int x = nums[i % n];
            while (!s.isEmpty() &amp;&amp; nums[s.peek()] &lt; x) {
                res[s.peek()] = x;
                s.pop();
            }
            if (i &lt; n) s.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2289-使数组按非递减顺序排列" tabindex="-1"><a class="header-anchor" href="#_2289-使数组按非递减顺序排列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/" target="_blank" rel="noopener noreferrer">2289. 使数组按非递减顺序排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int totalSteps(int[] nums) {
        var res = 0;
        var s = new ArrayDeque&lt;Pair&lt;Integer, Integer&gt;&gt;();
        for (int i = 0; i &lt; nums.length; i ++ ) {
            int cur = 0;
            while (!s.isEmpty() &amp;&amp; nums[s.peek().getKey()] &lt;= nums[i]) 
                cur = Math.max(cur, s.pop().getValue());

            if (!s.isEmpty()) {
                s.push(new Pair&lt;&gt;(i, cur + 1));
                res = Math.max(res, cur + 1);
            }
            else 
                s.push(new Pair&lt;&gt;(i, 0));
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_901-股票价格跨度" tabindex="-1"><a class="header-anchor" href="#_901-股票价格跨度" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/online-stock-span/" target="_blank" rel="noopener noreferrer">901. 股票价格跨度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class StockSpanner {
    ArrayDeque&lt;Pair&lt;Integer, Integer&gt;&gt; stk;
    int cur;
    public StockSpanner() {
        stk = new ArrayDeque&lt;&gt;();
    }
    
    public int next(int price) {
        while (!stk.isEmpty() &amp;&amp; stk.peek().getValue() &lt;= price) stk.pop();
        int pre = stk.isEmpty() ? -1 : stk.peek().getKey();
        var res = cur - pre;
        stk.push(new Pair(cur ++ , price));
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6227-下一个更大元素-iv" tabindex="-1"><a class="header-anchor" href="#_6227-下一个更大元素-iv" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/next-greater-element-iv/" target="_blank" rel="noopener noreferrer">6227. 下一个更大元素 IV<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] secondGreaterElement(int[] nums) {
        var n = nums.length;
        var res = new int[n];
        Arrays.fill(res, -1);
        var s1 = new ArrayDeque&lt;Integer&gt;();
        var s2 = new ArrayDeque&lt;Integer&gt;();
        var tem = new ArrayDeque&lt;Integer&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            while (!s2.isEmpty() &amp;&amp; nums[s2.peek()] &lt; nums[i])
                res[s2.pop()] = nums[i];
            while (!s1.isEmpty() &amp;&amp; nums[s1.peek()] &lt; nums[i]) 
                tem.push(s1.pop());
            while (!tem.isEmpty()) s2.push(tem.pop());
            s1.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：单调栈&amp;堆</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] secondGreaterElement(int[] nums) {
        var n = nums.length;
        var res = new int[n];
        Arrays.fill(res, -1);
        var s1 = new ArrayDeque&lt;Integer&gt;();
        var q = new PriorityQueue&lt;Integer&gt;((a, b) -&gt; nums[a] - nums[b]);
        for (int i = 0; i &lt; n; i ++ ) {
            while (!q.isEmpty() &amp;&amp; nums[q.peek()] &lt; nums[i]) 
                res[q.poll()] = nums[i];  
            while (!s1.isEmpty() &amp;&amp; nums[s1.peek()] &lt; nums[i]) 
                q.add(s1.pop());
            s1.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="单调队列" tabindex="-1"><a class="header-anchor" href="#单调队列" aria-hidden="true">#</a> 单调队列</h2><p>常见模型：找到滑动窗口中离他最近比它大/小的数</p><h4 id="_239-滑动窗口最大值" tabindex="-1"><a class="header-anchor" href="#_239-滑动窗口最大值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">239. 滑动窗口最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        if (nums == null || nums.length &lt; 2) return nums;
        int[] res = new int[nums.length - k + 1];
        int idx = 0;
        for (int i = 0; i &lt; nums.length; i ++ ) {
            if (!q.isEmpty() &amp;&amp; i - k + 1 &gt; q.getFirst()) q.pollFirst();
            while (!q.isEmpty() &amp;&amp; nums[q.getLast()] &lt;= nums[i]) q.pollLast();
            q.add(i);
            if (i &gt;= k - 1) res[idx ++ ] = nums[q.getFirst()];
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_862-和至少为-k-的最短子数组" tabindex="-1"><a class="header-anchor" href="#_862-和至少为-k-的最短子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="noopener noreferrer">862. 和至少为 K 的最短子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int shortestSubarray(int[] nums, int k) {
        int ans = Integer.MAX_VALUE;
        int n = nums.length;
        long[] s = new long[n + 1];
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i];
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt;= n; i ++ ) {
            while (!q.isEmpty() &amp;&amp; s[q.getFirst()] + k &lt;= s[i]) {
                ans = Math.min(ans, i - q.getFirst());
                q.pollFirst();
            }
            //删除大于等于s[i]的数，原因不是最优
            while (!q.isEmpty() &amp;&amp; s[q.getLast()] &gt;= s[i]) {
                q.pollLast();
            }
            q.add(i);
        }
        if (ans == Integer.MAX_VALUE) return -1;
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def shortestSubarray(self, nums: List[int], k: int) -&gt; int:
        n = len(nums)
        s = [0] * (n + 1)
        for i in range(n):
            s[i + 1] = s[i] + nums[i]
        q, res = deque(), inf
        for i in range(n + 1):
            while q and s[q[0]] + k &lt;= s[i]:
                res = min(res, i - q.popleft())
            while q and s[q[-1]] &gt;= s[i]:
                q.pop()
            q.append(i)
        return res if res &lt; inf else -1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1438-绝对差不超过限制的最长连续子数组" tabindex="-1"><a class="header-anchor" href="#_1438-绝对差不超过限制的最长连续子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/" target="_blank" rel="noopener noreferrer">1438. 绝对差不超过限制的最长连续子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestSubarray(int[] nums, int limit) {
        int n = nums.length;
        int ans = 0;
        ArrayDeque&lt;Integer&gt; q1 = new ArrayDeque&lt;&gt;(), q2 = new ArrayDeque&lt;&gt;();
        for (int i = 0, j = 0; i &lt; n; i ++ ) {
            while (!q1.isEmpty() &amp;&amp; nums[q1.getLast()] &gt; nums[i]) q1.pollLast();
            while (!q2.isEmpty() &amp;&amp; nums[q2.getLast()] &lt; nums[i]) q2.pollLast();
            q1.add(i);
            q2.add(i);
            while (!q1.isEmpty() &amp;&amp; !q2.isEmpty() &amp;&amp; nums[q2.getFirst()] - nums[q1.getFirst()] &gt; limit) {
                if (q1.getFirst() == j) q1.pollFirst();
                if (q2.getFirst() == j) q2.pollFirst();
                j ++ ;
            }
            ans = Math.max(ans, i - j + 1);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二分查找" tabindex="-1"><a class="header-anchor" href="#二分查找" aria-hidden="true">#</a> 二分查找</h2><p>10.30</p><h4 id="_704-二分查找" tabindex="-1"><a class="header-anchor" href="#_704-二分查找" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener noreferrer">704. 二分查找<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_34-在排序数组中查找元素的第一个和最后一个位置" tabindex="-1"><a class="header-anchor" href="#_34-在排序数组中查找元素的第一个和最后一个位置" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener noreferrer">34. 在排序数组中查找元素的第一个和最后一个位置<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_35-搜索插入位置" tabindex="-1"><a class="header-anchor" href="#_35-搜索插入位置" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener noreferrer">35. 搜索插入位置<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_162-寻找峰值" tabindex="-1"><a class="header-anchor" href="#_162-寻找峰值" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener noreferrer">162. 寻找峰值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_69-sqrt-x" tabindex="-1"><a class="header-anchor" href="#_69-sqrt-x" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener noreferrer">69. Sqrt(x)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_278-第一个错误的版本" tabindex="-1"><a class="header-anchor" href="#_278-第一个错误的版本" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener noreferrer">278. 第一个错误的版本<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>溢出的两种解决方式1、转long在转回int 方式2、l + (l - r) / 2</p><h4 id="acwing14-不修改数组找出重复的数字" tabindex="-1"><a class="header-anchor" href="#acwing14-不修改数组找出重复的数字" aria-hidden="true">#</a> <a href="https://www.acwing.com/problem/content/description/15/" target="_blank" rel="noopener noreferrer">AcWing14.不修改数组找出重复的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>抽屉原理+分治</p><p>抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果</p><h4 id="_287-寻找重复数" tabindex="-1"><a class="header-anchor" href="#_287-寻找重复数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener noreferrer">287. 寻找重复数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>转换为142题求带环链表的入口</p><h4 id="_74-搜索二维矩阵" tabindex="-1"><a class="header-anchor" href="#_74-搜索二维矩阵" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank" rel="noopener noreferrer">74. 搜索二维矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_240-搜索二维矩阵-ii" tabindex="-1"><a class="header-anchor" href="#_240-搜索二维矩阵-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener noreferrer">240. 搜索二维矩阵 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length, m = matrix[0].length;
        int i = 0, j = m - 1;
        while (i &lt; n &amp;&amp; j &gt;= 0) {
            int t = matrix[i][j];
            if (t == target) return true;
            else if (t &gt; target) j -- ;//如果t &gt; target去掉一列
            else i ++ ;//如果t &lt; target去掉一行
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2271-毯子覆盖的最多白色砖块数" tabindex="-1"><a class="header-anchor" href="#_2271-毯子覆盖的最多白色砖块数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet/" target="_blank" rel="noopener noreferrer">2271. 毯子覆盖的最多白色砖块数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumWhiteTiles(int[][] tiles, int carpetLen) {
        int n = tiles.length;
        Arrays.sort(tiles, (a, b) -&gt; a[0] - b[0]);
        int[] s = new int[n + 1];
        //前缀和
        for (int i = 0; i &lt; n; i ++ ) {
            int len = tiles[i][1] - tiles[i][0] + 1;
            s[i + 1] = s[i] + len;
        }
        
        //枚举每个区间的左边界
        //查找毯子的右边界
        int ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            int tar = tiles[i][0] + carpetLen - 1;
            int pos = find(tiles, i, n - 1, tar);
            int cnt = s[pos] - s[i];
            //区分右边界落在区间内还是区间外
            if (tar &lt;= tiles[pos][1]) {
            	//右边界再区间内的情况
                cnt += tar - tiles[pos][0] + 1;
            } else {
            	//右边界再区间外的情况
                cnt += s[pos + 1] - s[pos];
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
    public int find(int[][] tiles, int l, int r, int tar) {
        while (l &lt;= r) {
            int mid = l + r &gt;&gt; 1;
            if (tar &lt; tiles[mid][0]) r = mid - 1;
            else l = mid + 1;
        }
        return r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_668-乘法表中第k小的数" tabindex="-1"><a class="header-anchor" href="#_668-乘法表中第k小的数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/" target="_blank" rel="noopener noreferrer">668. 乘法表中第k小的数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findKthNumber(int m, int n, int k) {
        int l = 0,r = m * n;
        while(l &lt; r){
            int mid = l + r &gt;&gt; 1;
            if(chk(mid, m, n, k)) r = mid;
            else l = mid + 1;
        }
        return r;
    }
    public boolean chk(int mid, int m, int n, int k) {
        int cnt = 0;
        //统计每行每列小于等于mid的数
        for(int i = 1; i &lt;= m; i++ ) {
            cnt += Math.min(mid / i, n);
        }
        return cnt &gt;= k;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-53-i-在排序数组中查找数字-i" tabindex="-1"><a class="header-anchor" href="#剑指-offer-53-i-在排序数组中查找数字-i" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 53 - I. 在排序数组中查找数字 I<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 0) return 0;
        int l = 0, r = nums.length - 1;
        //二分找出左边界
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        //答案不存在返回0
        if (nums[l] != target) return 0;
        //二分找出右边界
        int i = l, j = nums.length - 1;
        while (i &lt; j) {
            int mid = i + j + 1 &gt;&gt; 1;
            if (nums[mid] &lt;= target) i = mid;
            else j = mid - 1;
        }
        return j - l + 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6096-咒语和药水的成功对数" tabindex="-1"><a class="header-anchor" href="#_6096-咒语和药水的成功对数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/" target="_blank" rel="noopener noreferrer">6096. 咒语和药水的成功对数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] successfulPairs(int[] s, int[] p, long success) {
        Arrays.sort(p);
        int n = s.length, m = p.length;
        int[] ans = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            int t = s[i];
            long k = t * 1l * p[m - 1];
            if (k &lt; success) ans[i] = 0;
            else {
                int l = 0, r = m - 1;
                while (l &lt; r) {
                    int mid = l + r &gt;&gt; 1;
                    long q = t * 1l * p[mid];
                    if (q &gt;= success) r = mid;
                    else l = mid + 1;
                }
                ans[i] = m - l;
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_209-长度最小的子数组" tabindex="-1"><a class="header-anchor" href="#_209-长度最小的子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">209. 长度最小的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; i++ ) s[i + 1] = s[i] + nums[i];
        int ans = Integer.MAX_VALUE;
        //s[j] - s[i] &gt;= target -&gt; s[j] &gt;= s[i] + target
        for (int i = 0; i &lt;= n; i ++ ) {
            int l = i, r = n;
            while (l &lt; r) {
                int mid = l + r &gt;&gt; 1;
                if (s[mid] &gt;= s[i] + target) r = mid;
                else l = mid + 1;
            }
            if (s[l] &gt;= s[i] + target) ans = Math.min(ans, r - i);
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1760-袋子里最少数目的球" tabindex="-1"><a class="header-anchor" href="#_1760-袋子里最少数目的球" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag/" target="_blank" rel="noopener noreferrer">1760. 袋子里最少数目的球<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumSize(int[] nums, int m) {
        int l = 1, r = 0;
        for (int i : nums) r = Math.max(r, i);
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            int t = 0;
            for (int i : nums) {
                t += i / mid;
                if (i % mid == 0) t -- ;
            }
            if (t &lt;= m) r = mid;
            else l = mid + 1;
        }
        return l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_658-找到-k-个最接近的元素" tabindex="-1"><a class="header-anchor" href="#_658-找到-k-个最接近的元素" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-k-closest-elements/" target="_blank" rel="noopener noreferrer">658. 找到 K 个最接近的元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        int l = 0, r = arr.length;
        //二分找到第一个大于等于接近x的数
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (arr[mid] &gt;= x) r = mid;
            else l = mid + 1;
        }
        int pl = l - 1, pr = l;
        //双指针寻找结果
        while (k -- &gt; 0) {
            if (pl == -1) pr ++ ;
            else if (pr == arr.length) pl -- ;
            else {
                if (x - arr[pl] &lt;= arr[pr] - x) pl -- ;
                else pr ++ ;
            }
        } 
        for (int i = pl + 1; i &lt; pr; i ++ ) ans.add(arr[i]);
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1894-找到需要补充粉笔的学生编号" tabindex="-1"><a class="header-anchor" href="#_1894-找到需要补充粉笔的学生编号" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk/" target="_blank" rel="noopener noreferrer">1894. 找到需要补充粉笔的学生编号<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int chalkReplacer(int[] chalk, int k) {
        int n = chalk.length;
        long[] s = new long[n + 1];
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + chalk[i];
        k %= s[n];
        int l = 0, r = n;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (s[mid] &gt; k) r = mid;
            else l = mid + 1;
        }
        return l - 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_719-找出第-k-小的数对距离" tabindex="-1"><a class="header-anchor" href="#_719-找出第-k-小的数对距离" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener noreferrer">719. 找出第 K 小的数对距离<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        int n = nums.length;
        int l = 0, r = nums[n - 1] - nums[0];
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            //给定一个候选值 mid，我们可以通过双指针算法，
            //在线性时间内求出小于等于 mid 的数对有多少个
            int t = 0;
            /*for (int i = 0, j = 0; i &lt; n; i ++ ) {
                while (j &lt; n &amp;&amp; nums[j] - nums[i] &lt;= mid) j ++ ;
                t += j - i;
            }*/
            for (int i = 1, j = 0; i &lt; n; i ++ ) {
                while (j &lt; i &amp;&amp; nums[i] - nums[j] &gt; mid) j ++ ;
                t += i - j;
            }
            if (t &gt;= k) r = mid;
            else l = mid + 1;
        }
        return l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_287-寻找重复数-1" tabindex="-1"><a class="header-anchor" href="#_287-寻找重复数-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-the-duplicate-number/" target="_blank" rel="noopener noreferrer">287. 寻找重复数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        int l = 0, r = nums.length - 1;
        while (l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if (mid &lt; nums[mid]) l = mid;
            else r = mid - 1;
        }
        return l + 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_719-找出第-k-小的数对距离-1" tabindex="-1"><a class="header-anchor" href="#_719-找出第-k-小的数对距离-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/" target="_blank" rel="noopener noreferrer">719. 找出第 K 小的数对距离<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        Arrays.sort(nums);
        int l = 0, r = nums[nums.length - 1] - nums[0];
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            int t = 0;
            for (int i = 1, j = 0; i &lt; nums.length; i ++ ) {
                while (j &lt; i &amp;&amp; nums[i] - nums[j] &gt; mid) j ++ ;
                t += i - j;
            }
            if (t &gt;= k) r = mid;
            else l = mid + 1; 
        }
        return l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1283-使结果不超过阈值的最小除数" tabindex="-1"><a class="header-anchor" href="#_1283-使结果不超过阈值的最小除数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/" target="_blank" rel="noopener noreferrer">1283. 使结果不超过阈值的最小除数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int l = 1, r = 1000000;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            long t = 0;
            for (int i : nums) t += (i + mid - 1) / mid;
            if (t &lt;= threshold) r = mid;
            else l = mid + 1;
        }
        return l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1870-准时到达的列车最小时速" tabindex="-1"><a class="header-anchor" href="#_1870-准时到达的列车最小时速" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/" target="_blank" rel="noopener noreferrer">1870. 准时到达的列车最小时速<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minSpeedOnTime(int[] dist, double h) {
        int n = dist.length;
        int l = 1, r = 10000010;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            double t = 0;
            for (int i = 0; i &lt; n - 1; i ++ ) t += (dist[i] + mid - 1) / mid; 
            t += dist[n - 1] * 1.0 / mid;
            if (t &lt;= h) r = mid;
            else l = mid + 1;
        }
        return l == 10000010 ? -1 : l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1898-可移除字符的最大数目" tabindex="-1"><a class="header-anchor" href="#_1898-可移除字符的最大数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-number-of-removable-characters/" target="_blank" rel="noopener noreferrer">1898. 可移除字符的最大数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumRemovals(String s, String p, int[] removable) {
        int n = removable.length;
        int l = 0, r = n;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (!check(s, p, mid, removable)) r = mid;
            else l = mid + 1;
        }
        return l;
    }
    public boolean check(String s1, String s2, int mid, int[] remove) {
        char[] ss = s1.toCharArray();
        for (int i = 0; i &lt;= mid; i ++ ) ss[remove[i]] = &#39;,&#39;;
        int n = s1.length(), m = s2.length();
        int j = 0;
        for (int i = 0; i &lt; s1.length(); i ++ ) {
            if (j &lt; m) {
                if (ss[i] == s2.charAt(j)) j ++ ;
            }
            else return true;
        }
        if (j == m) return true;
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1482-制作-m-束花所需的最少天数" tabindex="-1"><a class="header-anchor" href="#_1482-制作-m-束花所需的最少天数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets/" target="_blank" rel="noopener noreferrer">1482. 制作 m 束花所需的最少天数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minDays(int[] bloomDay, int m, int k) {
        if (bloomDay.length &lt; m * k) return -1;
        int l = 1, r = 1000000010, n = bloomDay.length;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            int t = 0, count = 0;
            for (int i = 0; i &lt; n; i ++ ) {
                if (bloomDay[i] &lt;= mid) count ++ ;
                else count = 0;
                if (count == k) {
                    count = 0;
                    t ++ ;
                }
            }
            if (t &gt;= m) r = mid;
            else l = mid + 1;
        }
        return l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_275-h-指数-ii" tabindex="-1"><a class="header-anchor" href="#_275-h-指数-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/h-index-ii/" target="_blank" rel="noopener noreferrer">275. H 指数 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int hIndex(int[] ct) {
        int  n = ct.length;
        int l = 0, r = n;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            // 满足右侧的 len - mid篇论文分别被引用了至少 len - mid 次.
            if (n - mid &lt;= ct[mid]) r = mid;
            else l = mid + 1;
        }
        return n - l;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1818-绝对差值和" tabindex="-1"><a class="header-anchor" href="#_1818-绝对差值和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-absolute-sum-difference/" target="_blank" rel="noopener noreferrer">1818. 绝对差值和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        long sum = 0;
        int max = 0, mod = (int)1e9 + 7;
        int[] nums = nums1.clone();
        Arrays.sort(nums);
        for (int i = 0; i &lt; nums.length; i ++ ) {
            int a = nums1[i], b = nums2[i];
            int x = Math.abs(a - b);
            sum += x;
            int l = 0, r = nums1.length - 1;
            while (l &lt; r) {
                int mid = l + r &gt;&gt; 1;
                if (nums[mid] &gt;= b) r = mid;
                else l = mid + 1;
            }
            int t = 0;
            t = Math.abs(nums[l] - b);
            if (l &gt; 0) t = Math.min(t, Math.abs(b - nums[l - 1]));
            max = Math.max(max, Math.abs(x - t));
        }
        return (int) ((sum - max) % mod);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_540-有序数组中的单一元素" tabindex="-1"><a class="header-anchor" href="#_540-有序数组中的单一元素" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener noreferrer">540. 有序数组中的单一元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0, r = (nums.length - 1) / 2;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            //两两分组后找第一组两个不同的，左边那个数就是要找的
            if (nums[mid * 2] != nums[mid * 2 + 1]) r = mid;
            else l = mid + 1;
        }
        return nums[l * 2];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1712-将数组分成三个子数组的方案数" tabindex="-1"><a class="header-anchor" href="#_1712-将数组分成三个子数组的方案数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ways-to-split-array-into-three-subarrays/" target="_blank" rel="noopener noreferrer">1712. 将数组分成三个子数组的方案数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int waysToSplit(int[] nums) {
        int n = nums.length, mod = (int) 1e9 + 7;
        long[] s = new long[n + 1];
        long ans = 0;
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i];
        //枚举mid的左边界
        for (int i = 0; i &lt; n; i ++ ) {
            int l = i + 1, r = n - 1;
            //二分出mid右边界的范围
            int l1 = i + 1, r1 = n - 1;
            while (l1 &lt; r1) {
                int mid = l1 + r1 &gt;&gt; 1;
                long a = s[i + 1];
                long b = s[mid + 1] - s[i + 1];
                if (a &lt;= b) r1 = mid;
                else l1 = mid + 1;
            }
            while (l &lt; r) {
                int mid = l + r &gt;&gt; 1;
                long b = s[mid + 1] - s[i + 1];
                long c = s[n] - s[mid + 1];
                if (b &gt; c) r = mid;
                else l = mid + 1;
            }
            if (l &gt;= l1) ans += l - l1;
            ans %= mod;
        }
        return (int) ans % mod;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1838-最高频元素的频数" tabindex="-1"><a class="header-anchor" href="#_1838-最高频元素的频数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/" target="_blank" rel="noopener noreferrer">1838. 最高频元素的频数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] nums, s;
    int n, k;
    public int maxFrequency(int[] _nums, int _k) {
        nums = _nums;
        k = _k;
        n = nums.length;
        Arrays.sort(nums);
        s = new int[n + 1];
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i];
        int l = 1, r = n;
        while (l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if (check(mid)) l = mid;
            else r = mid - 1;
        }
        return l;
    }
    public boolean check(int len) {
        for (int l = 0; l + len - 1 &lt; n; l ++ ) {
            int r = l + len - 1;
            int cur = s[r + 1] - s[l];
            int t = nums[r] * len;
            if (t - cur &lt;= k) return true;
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_436-寻找右区间" tabindex="-1"><a class="header-anchor" href="#_436-寻找右区间" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-right-interval/" target="_blank" rel="noopener noreferrer">436. 寻找右区间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] findRightInterval(int[][] intervals) {
        int n = intervals.length;
        if (n == 1) return new int[]{-1};
        int[] res = new int[n];
        int[][] map = new int[n][2];
        for (int i = 0; i &lt; n; i ++ ) {
            map[i][0] = intervals[i][0];
            map[i][1] = i;
        }
        Arrays.sort(map, (a, b) -&gt; a[0] - b[0]);
        for (int i = 0; i &lt; n; i ++ ) {
            int k = intervals[i][1];
            int l = 0, r = n - 1;
            while (l &lt; r) {
                int mid = l + r &gt;&gt; 1;
                if (map[mid][0] &gt;= k) r = mid;
                else l = mid + 1;
            }
            if (map[l][0] &gt;= k) res[i] = map[l][1];
            else res[i] = -1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_826-安排工作以达到最大收益" tabindex="-1"><a class="header-anchor" href="#_826-安排工作以达到最大收益" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/most-profit-assigning-work/" target="_blank" rel="noopener noreferrer">826. 安排工作以达到最大收益<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxProfitAssignment(int[] d, int[] p, int[] w) {
        int ans = 0, max = 0;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        //将利润和难度进行关联
        for (int i = 0; i &lt; d.length; i ++ ) {
            //d[i]会有重复，判断后存最大值
            if (!map.containsKey(d[i])) map.put(d[i], p[i]);
            else map.put(d[i], Math.max(map.get(d[i]), p[i]));
        }
        Arrays.sort(d);
        //预处理，防止利润难度不成正比
        for (int i = 0; i &lt; d.length; i ++ ) {
            max = Math.max(max, map.get(d[i]));
            map.put(d[i], max);
        } 
        for (int i : w) {
            int l = 0, r = d.length - 1;
            while (l &lt; r) {
                int mid = l + r &gt;&gt; 1;
                if (d[mid] &gt;= i) r = mid;
                else l = mid + 1;
            }
            if (l == 0 &amp;&amp; d[l] &gt; i) continue;
            if (d[l] &gt; i) ans += map.get(d[l - 1]);
            else ans += map.get(d[l]);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_81-搜索旋转排序数组-ii" tabindex="-1"><a class="header-anchor" href="#_81-搜索旋转排序数组-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener noreferrer">*81. 搜索旋转排序数组 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length;
        int l = 0, r = n - 1;
        //恢复二段性
        while (l &lt; r &amp;&amp; nums[l] == nums[r]) r -- ;
        if (l == r) return nums[r] == target;
        //二分找旋转点
        while (l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if (nums[mid] &gt;= nums[0]) l = mid;
            else r = mid - 1; 
        }
        if (target &gt;= nums[0]) l = 0;
        else if (r + 1 &lt; n) {
            l = r + 1;
            r = n - 1;
        }
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &gt;= target) r = mid;
            else l = mid + 1;
        }
        return nums[l] == target;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_154-寻找旋转排序数组中的最小值-ii" tabindex="-1"><a class="header-anchor" href="#_154-寻找旋转排序数组中的最小值-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener noreferrer">154. 寻找旋转排序数组中的最小值 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length - 1;
        while (l &lt; r &amp;&amp; nums[r] == nums[0]) r -- ;
        if (nums[r] &gt; nums[0]) return nums[0];
        while (l &lt; r) { 
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt; nums[0]) r = mid;
            else l = mid + 1;
        }
        return nums[l];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_153-寻找旋转排序数组中的最小值" tabindex="-1"><a class="header-anchor" href="#_153-寻找旋转排序数组中的最小值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener noreferrer">153. 寻找旋转排序数组中的最小值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length - 1;
        if (nums[r] &gt; nums[0]) return nums[0];
        while (l &lt; r) { 
            int mid = l + r &gt;&gt; 1;
            if (nums[mid] &lt; nums[0]) r = mid;
            else l = mid + 1;
        }
        return nums[l];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_710-黑名单中的随机数" tabindex="-1"><a class="header-anchor" href="#_710-黑名单中的随机数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/random-pick-with-blacklist/" target="_blank" rel="noopener noreferrer">710. 黑名单中的随机数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;int[]&gt; list = new ArrayList&lt;&gt;();
    int[] s = new int[100005];
    Random r = new Random();
    int sz;
    public Solution(int n, int[] bs) {
        Arrays.sort(bs);
        int m = bs.length;
        //我们不对「点」做离散化，而利用 bs 数据范围为 1e5，来对「线段」做离散化。
        if (m == 0) list.add(new int[]{0, n - 1});
        else {
            if (bs[0] != 0) list.add(new int[]{0, bs[0] - 1});
            for (int i = 1; i &lt; m; i ++ ) {
                if (bs[i - 1] == bs[i] - 1) continue;
                list.add(new int[]{bs[i - 1] + 1, bs[i] - 1});
            }
            if (bs[m - 1] != n - 1) list.add(new int[]{bs[m - 1] + 1, n - 1});
        }
        sz = list.size();
        for (int i = 0; i &lt; sz; i ++ ) {
            int[] info = list.get(i);
            s[i + 1] = s[i] + info[1] - info[0] + 1;
        }
    }
    
    public int pick() {
        int val = r.nextInt(s[sz]) + 1;
        int l = 1, r = sz;
        //二分找到val所在线段
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            if (s[mid] &gt;= val) r = mid;
            else l = mid + 1;
        } 
        int[] info = list.get(l);
        //然后再利用该线段的左右端点的值，取出对应的点。
        int a = info[0], b = info[1], end = s[r];
        System.out.println(b);
        return b - (end - val);
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(n, blacklist);
 * int param_1 = obj.pick();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1498-满足条件的子序列数目" tabindex="-1"><a class="header-anchor" href="#_1498-满足条件的子序列数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/" target="_blank" rel="noopener noreferrer">1498. 满足条件的子序列数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int numSubseq(int[] nums, int target) {
        int mod = (int)1e9 + 7;
        int n = nums.length;
        int[] f = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            if (i == 0) f[i] = 1;
            else f[i] = (f[i - 1] &lt;&lt; 1) % mod;
        }
        int ans = 0;
        Arrays.sort(nums);
        for (int i = 0; i &lt; n; i ++ ) {
            int l = i, r = n - 1;
            while (l &lt; r) {
                int mid = l + r + 1 &gt;&gt; 1;
                if (nums[mid] + nums[i] &lt;= target) l = mid;
                else r = mid - 1;
            }
            if (nums[l] + nums[i] &lt;= target) ans = (ans + f[r - i]) % mod;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_793-阶乘函数后-k-个零" tabindex="-1"><a class="header-anchor" href="#_793-阶乘函数后-k-个零" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/" target="_blank" rel="noopener noreferrer">793. 阶乘函数后 K 个零<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    //阶乘函数后k个0的个数取决于有几个5
    public int preimageSizeFZF(int k) {
        if (k &lt;= 1) return 5;
        else return f(k) - f(k - 1);
    }
    public int f(int k) {
        long l = 0, r = (long)1e10;
        while (l &lt; r) {
            long mid = l + r + 1 &gt;&gt; 1;
            if (getCur(mid) &lt;= k) l = mid;
            else r = mid - 1;
        }
        return (int)l;
    }
    public int getCur(long x) {
        long res = 0;
        while (x != 0) {
            res += x / 5;
            x /= 5;
        }
        return (int)res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="前缀和" tabindex="-1"><a class="header-anchor" href="#前缀和" aria-hidden="true">#</a> 前缀和</h2><h4 id="_560-和为-k-的子数组" tabindex="-1"><a class="header-anchor" href="#_560-和为-k-的子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/" target="_blank" rel="noopener noreferrer">560. 和为 K 的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>前缀和优化</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] s = new int[n + 1];
        int ans = 0;
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i];
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        //初始化时前缀和为0的数组出现次数设置为1，用来计算当前前缀和恰好为k的情况。
        map.put(0, 1);
        for (int i = 1; i &lt;= n; i ++ ) {
            //s[j] - s[i] = k -- &gt; s[i] = s[j] - k;
            /*
            *我们可以枚举区间的终点，用哈希表来记录终点前的前缀和出现次数，
            *以当前点为终点的和为k的子数组的出现次数即为当前前缀和减去k后
            *的前缀和的次数。
            */
            ans += map.getOrDefault(s[i] - k, 0);
            map.put(s[i], map.getOrDefault(s[i], 0) + 1);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_930-和相同的二元子数组" tabindex="-1"><a class="header-anchor" href="#_930-和相同的二元子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-subarrays-with-sum/" target="_blank" rel="noopener noreferrer">930. 和相同的二元子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i];
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 1);
        int res = 0;
        for (int i = 1; i &lt;= n; i ++ ) {
            res += map.getOrDefault(s[i] - goal, 0);
            map.put(s[i], map.getOrDefault(s[i], 0) + 1);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_525-连续数组" tabindex="-1"><a class="header-anchor" href="#_525-连续数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/contiguous-array/" target="_blank" rel="noopener noreferrer">525. 连续数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findMaxLength(int[] nums) {
        int n = nums.length;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 0);
        int res = 0;
        for (int i = 1, one = 0, zero = 0; i &lt;= n; i ++ ) {
            int x = nums[i - 1];
            if (x == 0) zero ++ ;
            else one ++ ;
            int s = one - zero;
            if (map.containsKey(s)) res = Math.max(res, i - map.get(s));
            else map.put(s, i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_523-连续的子数组和" tabindex="-1"><a class="header-anchor" href="#_523-连续的子数组和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/continuous-subarray-sum/" target="_blank" rel="noopener noreferrer">523. 连续的子数组和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int n = nums.length;
        if (k == 0) {
            for (int i = 1; i &lt; n; i ++ ) {
                if (nums[i - 1] == 0 &amp;&amp; nums[i] == 0) return true;
            }
            return false;
        }
        int[] s = new int[n + 1];
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i]; 
        for (int i = 2; i &lt;= n; i ++ ) {
        //两个数相减能被k整除等价于两个数除以k的余数相同
            set.add(s[i - 2] % k);
            if (set.contains(s[i] % k)) return true;
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1248-统计「优美子数组」" tabindex="-1"><a class="header-anchor" href="#_1248-统计「优美子数组」" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-number-of-nice-subarrays/" target="_blank" rel="noopener noreferrer">1248. 统计「优美子数组」<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 1);
        for (int i = 0, cnt = 0; i &lt; n; i ++ ) {
            int x = nums[i];
            if (x % 2 == 1) cnt ++ ;
            if (map.containsKey(cnt - k)) ans += map.get(cnt - k);
            map.put(cnt, map.getOrDefault(cnt, 0) + 1);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_974-和可被-k-整除的子数组" tabindex="-1"><a class="header-anchor" href="#_974-和可被-k-整除的子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/subarray-sums-divisible-by-k/" target="_blank" rel="noopener noreferrer">974. 和可被 K 整除的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int n = nums.length;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, 1);
        int ans = 0;
        int sum = 0;
        for (int i = 1; i &lt;= n; i ++ ) {
            sum += nums[i - 1];
            int r = (sum % k + k) % k;
            if (map.containsKey(r)) ans += map.get(r);
            map.put(r, map.getOrDefault(r, 0) + 1);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_221-最大正方形" tabindex="-1"><a class="header-anchor" href="#_221-最大正方形" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximal-square/" target="_blank" rel="noopener noreferrer">221. 最大正方形<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二维前缀和 + 二分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean check(int[][] s, int d) {
        int n = s.length - 1, m = s[0].length - 1;
        for (int i = 0; i &lt;= n - d; i ++ ) {
            for (int j = 0; j &lt;= m - d; j ++ ) {
                int x = i + d - 1, y = j + d - 1;
                if (s[x + 1][y + 1] - s[x + 1][j] - s[i][y + 1] + s[i][j] == d * d)
                    return true;
            }
        }
        return false;
    }

    public int maximalSquare(char[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        int[][] s = new int[n + 1][m + 1];
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m; j ++ )
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + matrix[i][j] - &#39;0&#39;;
        int l = 0, r = Math.min(n, m);
        while (l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if (check(s, mid))
                l = mid;
            else
                r = mid - 1;
        }
        return r * r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6098-统计得分小于-k-的子数组数目" tabindex="-1"><a class="header-anchor" href="#_6098-统计得分小于-k-的子数组数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/" target="_blank" rel="noopener noreferrer">6098. 统计得分小于 K 的子数组数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countSubarrays(int[] nums, long k) {
        int n = nums.length;
        long[] s = new long[n + 1];
        for (int i = 0; i &lt; n; i ++ ) s[i + 1] = s[i] + nums[i] * 1l;
        long ans = 0;
        for (int i = 0, j = 0; i &lt; n; i ++ ) {
            while (j &lt;= i &amp;&amp; (s[i + 1] - s[j]) * (i - j + 1) &gt;= k) j ++ ;
            ans += i - j + 1;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5229-拼接数组的最大分数" tabindex="-1"><a class="header-anchor" href="#_5229-拼接数组的最大分数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/" target="_blank" rel="noopener noreferrer">5229. 拼接数组的最大分数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int work (int[] a, int[] b) {
        int sum = 0;
        for (int x : a) sum += x;
        int dt = 0, f = 0;
        //求最大连续子数组和
        for (int i = 0; i &lt; a.length; i ++ ) {
            f = Math.max(f, 0) + b[i] - a[i];
            dt = Math.max(dt, f);
        }
        return sum + dt;
    }
    public int maximumsSplicedArray(int[] a, int[] b) {
        return Math.max(work(a, b), work(b, a));
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="acwing4405-统计子矩阵" tabindex="-1"><a class="header-anchor" href="#acwing4405-统计子矩阵" aria-hidden="true">#</a> <a href="https://www.acwing.com/problem/content/description/4408/" target="_blank" rel="noopener noreferrer">AcWing4405. 统计子矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二维前缀和</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), m = sc.nextInt();
        long k = sc.nextInt();
        int[][] g = new int[n + 1][m + 1];
        for (int i = 0; i &lt; n; i ++ ) 
            for (int j = 0; j &lt; m; j ++ ) 
                g[i + 1][j + 1] = g[i][j + 1] + g[i + 1][j] - g[i][j] + sc.nextInt();
        
        long res = 0;        
        for (int i = 0; i &lt;= n; i ++ ) 
         for (int j = i + 1; j &lt;= n; j ++ ) 
            for (int l = 0, r = 1; r &lt;= m; r ++ ) {
                while (l &lt; r &amp;&amp; g[j][r] - g[j][l] - g[i][r] + g[i][l] &gt; k) l ++ ;
                res += r - l;
            }
            
        System.out.print(res);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1314-矩阵区域和" tabindex="-1"><a class="header-anchor" href="#_1314-矩阵区域和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/matrix-block-sum/" target="_blank" rel="noopener noreferrer">1314. 矩阵区域和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二维前缀和</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int n = mat.length, m = mat[0].length;
        var s = new int[n + 1][m + 1];
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m ; j ++ )
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + mat[i][j];
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m; j ++ ) {
                int x1 = Math.max(0, i - k);
                int y1 = Math.max(0, j - k);
                int x2 = Math.min(n - 1, i + k);
                int y2 = Math.min(m - 1, j + k);
                mat[i][j] = s[x2 + 1][y2 + 1] - s[x2 + 1][y1] - s[x1][y2 + 1] + s[x1][y1];
            }
        return mat;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="trie字典树" tabindex="-1"><a class="header-anchor" href="#trie字典树" aria-hidden="true">#</a> Trie字典树</h2><h4 id="_208-实现-trie-前缀树" tabindex="-1"><a class="header-anchor" href="#_208-实现-trie-前缀树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener noreferrer">208. 实现 Trie (前缀树)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//字典树 + dfs
class Trie {
    private static class TrieNode {
        TrieNode[] child;
        boolean    isEnd;
        public TrieNode() {
            this.child = new TrieNode[26];
            this.isEnd = false;
        }
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    /**
    * Inserts a word into the trie.
    */
    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] == null) {
                p.child[c - &#39;a&#39;] = new TrieNode();
            }
            p = p.child[c - &#39;a&#39;];
        }
        p.isEnd = true;
    }

    /**
    * Returns if the word is in the trie.
    */
    public boolean search(String word) {
        TrieNode p = root;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] == null) {
                return false;
            }
            p = p.child[c - &#39;a&#39;];
        }
        return p.isEnd;
    }

    /**
    * Returns if there is any word in the trie that starts with the given prefix.
    */
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (int i = 0; i &lt; prefix.length(); i++) {
            char c = prefix.charAt(i);
            if (p.child[c - &#39;a&#39;] == null) {
                return false;
            }
            p = p.child[c - &#39;a&#39;];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_676-实现一个魔法字典" tabindex="-1"><a class="header-anchor" href="#_676-实现一个魔法字典" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/implement-magic-dictionary/" target="_blank" rel="noopener noreferrer">676. 实现一个魔法字典<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MagicDictionary {
    int N = 100 * 100, M = 26, idx = 0;
    int[][] son = new int[N][M];
    boolean[] isEnd = new boolean[N * M];
    
    public void insert(String word) {
        char[] str = word.toCharArray();
        int p = 0;
        for (int i = 0; i &lt; str.length; i ++ ) {
            int u = str[i] - &#39;a&#39;;
            if (son[p][u] == 0) son[p][u] = ++ idx;
            p = son[p][u];
        }
        isEnd[p] = true;
    }

    public boolean dfs (String s, int p, int u, int c) {
        if (isEnd[p] &amp;&amp; u == s.length() &amp;&amp; c == 1) return true;
        if (c &gt; 1 || u == s.length()) return false;

        int x = s.charAt(u) - &#39;a&#39;;
        for (int i = 0; i &lt; 26; i ++ ) {
            if (son[p][i] == 0) continue;
            if (dfs(s, son[p][i], u + 1, (x == i) ? c : c + 1)) 
                return true;
        }
        return false;
    }

    public MagicDictionary() {
        
    }
    
    public void buildDict(String[] dictionary) {
        for (String dic : dictionary) {
            insert(dic);
        }
    }
    
    public boolean search(String searchWord) {
        return dfs(searchWord, 0, 0, 0);
    }
}

/**
 * Your MagicDictionary object will be instantiated and called as such:
 * MagicDictionary obj = new MagicDictionary();
 * obj.buildDict(dictionary);
 * boolean param_2 = obj.search(searchWord);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_745-前缀和后缀搜索" tabindex="-1"><a class="header-anchor" href="#_745-前缀和后缀搜索" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/" target="_blank" rel="noopener noreferrer">745. 前缀和后缀搜索<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class WordFilter {
    public class TrieNode {
        int id;
        TrieNode[] son;
        TrieNode() {
            son = new TrieNode[27];
        }
    }
    TrieNode root = new TrieNode(); 
    public void insert(String s, int id) {
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            int u = c == &#39;#&#39; ? 26 : c - &#39;a&#39;;
            if (node.son[u] == null) node.son[u] = new TrieNode();
            node = node.son[u];
            node.id = id;
        }
    }

    public int search(String s) {
        TrieNode node = root;
        for (char c : s.toCharArray()) {
            int u = c == &#39;#&#39; ? 26 : c - &#39;a&#39;;
            if (node.son[u] == null) return -1;
            node = node.son[u];
        }
        return node.id;
    }

    public WordFilter(String[] words) {
        TrieNode node = root;
        for (int i = 0; i &lt; words.length; i ++ ) {
            String s = &quot;#&quot; + words[i];
            insert(s, i);
            for (int j = words[i].length() - 1; j &gt;= 0; j -- ) {
                s = words[i].charAt(j) + s;
                insert(s, i);
            }
        }
    }
    
    public int f(String pref, String suff) {
        return search(suff + &quot;#&quot; + pref);
    }
}

/**
 * Your WordFilter object will be instantiated and called as such:
 * WordFilter obj = new WordFilter(words);
 * int param_1 = obj.f(pref,suff);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_211-添加与搜索单词-数据结构设计" tabindex="-1"><a class="header-anchor" href="#_211-添加与搜索单词-数据结构设计" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure/" target="_blank" rel="noopener noreferrer">211. 添加与搜索单词 - 数据结构设计<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class WordDictionary {

    TrieNode root = new TrieNode();

    public WordDictionary() {

    }
    
    public void addWord(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int u = c - &#39;a&#39;;
            if (node.son[u] == null) node.son[u] = new TrieNode();
            node = node.son[u];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        return dfs(root, word, 0);
    }

    public boolean dfs(TrieNode p, String s, int i) {
        if (i == s.length()) return p.isEnd;
        if (s.charAt(i) == &#39;.&#39;) {
            for (int k = 0; k &lt; 26; k ++ ) {
                if (p.son[k] != null &amp;&amp; dfs(p.son[k], s, i + 1)) 
                    return true; 
            }
            return false;
        } else {
            int u = s.charAt(i) - &#39;a&#39;;
            if (p.son[u] == null) return false;
            return dfs(p.son[u], s, i + 1);
        }
    }

    public class TrieNode {
        TrieNode[] son;
        boolean isEnd;
        public TrieNode() {
            son = new TrieNode[26];
        }
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="acwing143-最大异或对" tabindex="-1"><a class="header-anchor" href="#acwing143-最大异或对" aria-hidden="true">#</a> <a href="https://www.acwing.com/problem/content/description/145/" target="_blank" rel="noopener noreferrer">AcWing143.最大异或对<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import java.io.*;
import java.util.*;
public class Main {
    static int N = 100010, M = 3000000;
    static int son[][] = new int[M][2];
    static int idx = 0;
    public static void insert(int x) {
        int p = 0;
        for (int i = 30; i &gt;= 0; i -- ) {
            int s = (x &gt;&gt; i) &amp; 1;
            if (son[p][s] == 0) son[p][s] = ++ idx;
            p = son[p][s];
        }
    }
    public static int search(int x) {
        int p = 0, res = 0;
        for (int i = 30; i &gt;= 0; i -- ) {
            int s = (x &gt;&gt; i) &amp; 1;
            if (son[p][1 - s] != 0) {
                res += 1 &lt;&lt; i;
                p = son[p][1 - s];
            } else {
                p = son[p][s];
            }
        }
        return res;
    }
    public static void main(String[] args) throws Exception {
        in.nextToken();
        int n = (int) in.nval;
        int[] a = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            in.nextToken();
            a[i] = (int) in.nval;
        }
        for (int x : a) insert(x);
        int res = 0;
        for (int x : a) 
            res = Math.max(res, search(x));
        pw.print(res);
        pw.close();
    }
    static  StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));
    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_421-数组中两个数的最大异或值" tabindex="-1"><a class="header-anchor" href="#_421-数组中两个数的最大异或值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/" target="_blank" rel="noopener noreferrer">421. 数组中两个数的最大异或值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    TrieNode root = new TrieNode();
    public void insert(int x) {
        var p = root;
        for (int i = 30; i &gt;= 0; i -- ) {
            var k = (x &gt;&gt; i) &amp; 1;
            if (p.son[k] == null) p.son[k] = new TrieNode();
            p = p.son[k];
        }
    }

    public int search(int x) {
        var p = root;
        var res = 0;
        for (int i = 30; i &gt;= 0; i -- ) {
            var k = (x &gt;&gt; i) &amp; 1;
            if (p.son[1 - k] != null) {
                res += 1 &lt;&lt; i;
                p = p.son[1 - k];
            } else 
                p = p.son[k];
        }
        return res;
    }

    public int findMaximumXOR(int[] nums) {
        var res = 0;
        for (int x : nums) {
            insert(x);
            res = Math.max(res, search(x));
        }    
        return res;
    }

    public class TrieNode {
        TrieNode[] son;
        boolean isEnd;
        public TrieNode() {
            son = new TrieNode[2];
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def __init__(self):
        self.idx = 0
        self.son = list()
        self.son.append([0, 0])

    def findMaximumXOR(self, nums: List[int]) -&gt; int:
        def insert(x):
            p = 0
            for i in range(30, -1, -1):
                k = (x &gt;&gt; i) &amp; 1
                if not self.son[p][k]: 
                    self.idx += 1
                    self.son.append([0, 0])
                    self.son[p][k] = self.idx
                p = self.son[p][k]

        def search(x):
            p, res = 0, 0
            for i in range(30, -1, -1):
                k = (x &gt;&gt; i) &amp; 1
                if self.son[p][1 - k]: 
                    res += 1 &lt;&lt; i
                    p = self.son[p][1 - k]
                else:
                    p = self.son[p][k]
            return res
        res = 0
        for x in nums:
            insert(x)
            res = max(res, search(x))
        return res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="哈希" tabindex="-1"><a class="header-anchor" href="#哈希" aria-hidden="true">#</a> 哈希</h2><h4 id="_349-两个数组的交集" tabindex="-1"><a class="header-anchor" href="#_349-两个数组的交集" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener noreferrer">349. 两个数组的交集<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.1</p><h4 id="_771-宝石与石头" tabindex="-1"><a class="header-anchor" href="#_771-宝石与石头" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener noreferrer">771. 宝石与石头<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1512-好数对的数目" tabindex="-1"><a class="header-anchor" href="#_1512-好数对的数目" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/number-of-good-pairs/" target="_blank" rel="noopener noreferrer">1512. 好数对的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1684-统计一致字符串的数目" tabindex="-1"><a class="header-anchor" href="#_1684-统计一致字符串的数目" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/" target="_blank" rel="noopener noreferrer">1684. 统计一致字符串的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_594-最长和谐子序列" tabindex="-1"><a class="header-anchor" href="#_594-最长和谐子序列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener noreferrer">594. 最长和谐子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>哈希计数（Java中的Map提供了getOrDefault()方法，对不存在的键值提供默认值的方法。）</p><h4 id="_1995-统计特殊四元组" tabindex="-1"><a class="header-anchor" href="#_1995-统计特殊四元组" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/count-special-quadruplets/" target="_blank" rel="noopener noreferrer">1995. 统计特殊四元组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_347-前-k-个高频元素" tabindex="-1"><a class="header-anchor" href="#_347-前-k-个高频元素" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener noreferrer">347. 前 K 个高频元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//哈希排序
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);
        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();
        // 根据map的value值正序排，相当于一个小顶堆
        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());
        for (Map.Entry&lt;Integer, Integer&gt; entry : entries) {
            queue.offer(entry);
            if (queue.size() &gt; k) {
                queue.poll();
            }
        }
        int[] res = new int[k];
        for (int i = 0; i &lt; k; i ++ ) res[i] = queue.poll().getKey();
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_205-同构字符串" tabindex="-1"><a class="header-anchor" href="#_205-同构字符串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/isomorphic-strings/" target="_blank" rel="noopener noreferrer">205. 同构字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public boolean isIsomorphic(String s, String t) {
        int[] st = new int[128];
        int[] ts = new int[128];
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int a = s.charAt(i), b = t.charAt(i);
            if (st[a] != 0 &amp;&amp; st[a] != b) return false;
            st[a] = b;
            if (ts[b] != 0 &amp;&amp; ts[b] != a) return false;
            ts[b] = a;            
        }
        return true;
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_890-查找和替换模式" tabindex="-1"><a class="header-anchor" href="#_890-查找和替换模式" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-and-replace-pattern/" target="_blank" rel="noopener noreferrer">890. 查找和替换模式<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) {
        List&lt;String&gt; ans = new ArrayList&lt;&gt;();
        for (String s : words) {
            if (isIsomorphic(s, pattern)) ans.add(s);
        }
        return ans;
    }
    public boolean isIsomorphic(String s, String t) {
        int[] st = new int[128];
        int[] ts = new int[128];
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int a = s.charAt(i), b = t.charAt(i);
            if (st[a] != 0 &amp;&amp; st[a] != b) return false;
            st[a] = b;
            if (ts[b] != 0 &amp;&amp; ts[b] != a) return false;
            ts[b] = a;            
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_30-串联所有单词的子串" tabindex="-1"><a class="header-anchor" href="#_30-串联所有单词的子串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener noreferrer">30. 串联所有单词的子串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//朴素哈希O(n×m×w)
class Solution {
    public List&lt;Integer&gt; findSubstring(String s, String[] words) {
        int n = words.length, m = words[0].length();
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (String word : words) map.put(word, map.getOrDefault(word, 0) + 1);
        out:for (int i = 0; i + m * n &lt;= s.length(); i ++ ) {
            Map&lt;String, Integer&gt; cur = new HashMap&lt;&gt;();
            String sub = s.substring(i, i + n * m);
            for (int j = 0; j &lt; sub.length(); j += m) {
                String item = sub.substring(j, j + m);
                if (!map.containsKey(item)) continue out;
                cur.put(item, cur.getOrDefault(item, 0) + 1);
            }
            if (cur.equals(map)) res.add(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//哈希 + 分组 + 滑窗 O(nw)
class Solution {
    public List&lt;Integer&gt; findSubstring(String s, String[] words) {
        int n = s.length(), m = words.length, w = words[0].length();
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (String word : words) map.put(word, map.getOrDefault(word, 0) + 1);
        //根据当前下标与单词长度的取余结果分为w组
        for (int i = 0; i &lt; w; i ++ ) {
            Map&lt;String, Integer&gt; wd = new HashMap&lt;&gt;();
            //记录有效单词数
            int cnt = 0;
            //每次将下一个单词加入，上一个单词移除
            for (int j = i; j + w &lt;= n; j += w) {
            	//窗口已达到最大，删除首个单词
                if (j &gt;= i + m * w) {
                    String word = s.substring(j - m * w, j - m * w + w);
                    wd.put(word, wd.get(word) - 1);
                    if (map.containsKey(word) &amp;&amp; wd.get(word) &lt; map.get(word)) cnt -- ;
                }
                //添加新的单词
                String word = s.substring(j, j + w);
                wd.put(word, wd.getOrDefault(word, 0) + 1);
                if (map.containsKey(word) &amp;&amp; wd.get(word) &lt;= map.get(word)) cnt ++ ;
                if (cnt == m) res.add(j - (m - 1) * w);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_648-单词替换" tabindex="-1"><a class="header-anchor" href="#_648-单词替换" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/replace-words/" target="_blank" rel="noopener noreferrer">648. 单词替换<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//哈希暴力
class Solution {
    public String replaceWords(List&lt;String&gt; dictionary, String sentence) {
        String[] ss = sentence.split(&quot; &quot;);
        int n = ss.length;
        StringBuilder ans = new StringBuilder();
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        for (String s : dictionary) set.add(s);
        for (int i = 0; i &lt; n; i ++ ) {
            String s = ss[i];
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j &lt; s.length(); j ++ ) {
                sb.append(s.charAt(j));
                if (set.contains(sb.toString())) break;
            }
            ans.append(sb);
            if (i != n - 1)  ans.append(&quot; &quot;);
        }
        return ans.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//字符串哈希
class Solution {
    public String replaceWords(List&lt;String&gt; dictionary, String sentence) {
        int p = 131;
        Set&lt;Long&gt; set = new HashSet&lt;&gt;();
        for (String s : dictionary) {
            long h = 0;
            for (char c : s.toCharArray()) h = h * p + c;
            set.add(h);
        }
        StringBuilder ans = new StringBuilder();
        String[] ss = sentence.split(&quot; &quot;);
        for (int i = 0; i &lt; ss.length; i ++ ) {
            StringBuilder sb = new StringBuilder();
            long h = 0;
            for (char c : ss[i].toCharArray()) {
                sb.append(c);
                h = h * p + c;
                if (set.contains(h)) break;
            }
            ans.append(sb).append(&quot; &quot;);
        }
        return ans.deleteCharAt(ans.length() - 1).toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_676-实现一个魔法字典-1" tabindex="-1"><a class="header-anchor" href="#_676-实现一个魔法字典-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/implement-magic-dictionary/" target="_blank" rel="noopener noreferrer">676. 实现一个魔法字典<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MagicDictionary {
	//根据字符串长度进行哈希然后爆搜
    Map&lt;Integer, List&lt;String&gt;&gt; map;
    public MagicDictionary() {
        map = new HashMap&lt;&gt;();
    }
    
    public void buildDict(String[] dictionary) {
        for (String dic : dictionary) {
            int t = dic.length();
            List&lt;String&gt; list = map.getOrDefault(t, new ArrayList&lt;&gt;());
            list.add(dic);
            map.put(t, list);
        }
    }
    
    public boolean search(String searchWord) {
        int n = searchWord.length();
        if (!map.containsKey(n)) return false;
        List&lt;String&gt; list = map.get(n);
        out:for (int i = 0; i &lt; list.size(); i ++ ) {
            int t = 0;
            String s = list.get(i);
            for (int j = 0; j &lt; n; j ++ ) {
                if (searchWord.charAt(j) == s.charAt(j)) continue;
                else t ++ ;
                if (t &gt; 1) continue out;
            }
            if (t == 1) return true;
        }
        return false;
    }
}

/**
 * Your MagicDictionary object will be instantiated and called as such:
 * MagicDictionary obj = new MagicDictionary();
 * obj.buildDict(dictionary);
 * boolean param_2 = obj.search(searchWord);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_745-前缀和后缀搜索-1" tabindex="-1"><a class="header-anchor" href="#_745-前缀和后缀搜索-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/" target="_blank" rel="noopener noreferrer">745. 前缀和后缀搜索<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//枚举每个前缀和后缀放入map
class WordFilter {
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    public WordFilter(String[] words) {
        for (int i = 0; i &lt; words.length; i ++ ) {
            for (int j = 1; j &lt;= words[i].length(); j ++ ) {
                for (int k = 1; k &lt;= words[i].length(); k ++ ) {
                    String pref = words[i].substring(0, j);
                    String suff = words[i].substring(words[i].length()-k, words[i].length());
                    map.put(pref + &quot; &quot; + suff, i);
                }
            }
        }
    }
    
    public int f(String pref, String suff) {
        return map.getOrDefault(pref + &quot; &quot; + suff, -1);
    }
}

/**
 * Your WordFilter object will be instantiated and called as such:
 * WordFilter obj = new WordFilter(words);
 * int param_1 = obj.f(pref,suff);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_692-前k个高频单词" tabindex="-1"><a class="header-anchor" href="#_692-前k个高频单词" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/top-k-frequent-words/" target="_blank" rel="noopener noreferrer">692. 前K个高频单词<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//哈希排序
class Solution {
    public List&lt;String&gt; topKFrequent(String[] words, int k) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
        for (String s : words) map.put(s, map.getOrDefault(s, 0) + 1);
        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; {
            if (a.getValue().equals(b.getValue())) 
                return b.getKey().compareTo(a.getKey());
            else
                return a.getValue() - b.getValue();
        });
        Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
        for (Map.Entry&lt;String, Integer&gt; entry : entries) {
            q.offer(entry);
            if (q.size() &gt; k) q.poll();
        }
        List&lt;String&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; k; i ++ ) ans.add(q.poll().getKey());
        Collections.reverse(ans);
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_904-水果成篮" tabindex="-1"><a class="header-anchor" href="#_904-水果成篮" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/fruit-into-baskets/" target="_blank" rel="noopener noreferrer">904. 水果成篮<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
	//求两个数的最长连续子序列
    public int totalFruit(int[] f) {
        int res = 0;
        int[] map = new int[f.length];
        for (int i = 0, j = 0, s = 0; i &lt; f.length; i ++ ) {
            if ( ++ map[f[i]] == 1) s ++ ;
            while (s &gt; 2) {
                if (-- map[f[j]] == 0) s -- ;
                j ++ ;
            }
            res = Math.max(res, i - j + 1);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1282-用户分组" tabindex="-1"><a class="header-anchor" href="#_1282-用户分组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/" target="_blank" rel="noopener noreferrer">1282. 用户分组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; groupThePeople(int[] g) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; g.length; i ++ ) {
            int x = g[i];
            if (map.get(x) == null) map.put(x, new ArrayList&lt;&gt;());
            map.get(x).add(i);
            if (map.get(x).size() == x) {
                res.add(new ArrayList&lt;&gt;(map.get(x)));
                map.put(x, null);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1224-最大相等频率" tabindex="-1"><a class="header-anchor" href="#_1224-最大相等频率" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-equal-frequency/" target="_blank" rel="noopener noreferrer">1224. 最大相等频率<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxEqualFreq(int[] nums) {
        int n = nums.length;
        int res = 0, max = 0;
        //记录每个数字出现的频次
        int[] hash = new int[100010];
        //记录每个频次出现的次数
        int[] cnt = new int[100010];
        for (int i = 0; i &lt; n; i ++ ) {
            int x = nums[i];
            if (hash[x] &gt; 0) 
                cnt[hash[x]] -- ;
            hash[x] ++ ;
            cnt[hash[x]] ++ ;

            max = Math.max(max, hash[x]);
            if (max == 1 || max * cnt[max] == i || (max - 1) * (cnt[max - 1] + 1) == i)
                res = i + 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1371-每个元音包含偶数次的最长子字符串" tabindex="-1"><a class="header-anchor" href="#_1371-每个元音包含偶数次的最长子字符串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener noreferrer">1371. 每个元音包含偶数次的最长子字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：状态压缩&amp;前缀和&amp;哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private static String v = &quot;aeiou&quot;;
    public int findTheLongestSubstring(String s) {
        int res = 0;
        int n = s.length();
        //一共5位如果这一位为1就说明是奇数，为0就说明是偶数
        int state = 0; //00000
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        map.put(0, -1);
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; v.length(); j ++ ) 
                if (s.charAt(i) == v.charAt(j)) {
                    state ^= 1 &lt;&lt; j;
                    break;
                }
            if (map.containsKey(state)) 
                res = Math.max(res, i - map.get(state));
            else map.put(state, i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h4><h2 id="原地哈希" tabindex="-1"><a class="header-anchor" href="#原地哈希" aria-hidden="true">#</a> 原地哈希</h2><p><em><strong>特点O(1)空间</strong></em></p><h4 id="_41-缺失的第一个正数" tabindex="-1"><a class="header-anchor" href="#_41-缺失的第一个正数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/first-missing-positive/" target="_blank" rel="noopener noreferrer">41. 缺失的第一个正数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_442-数组中重复的数据" tabindex="-1"><a class="header-anchor" href="#_442-数组中重复的数据" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener noreferrer">442. 数组中重复的数据<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_448-找到所有数组中消失的数字" tabindex="-1"><a class="header-anchor" href="#_448-找到所有数组中消失的数字" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener noreferrer">448. 找到所有数组中消失的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h2 id="模拟" tabindex="-1"><a class="header-anchor" href="#模拟" aria-hidden="true">#</a> 模拟</h2><h4 id="_299-猜数字游戏" tabindex="-1"><a class="header-anchor" href="#_299-猜数字游戏" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener noreferrer">299. 猜数字游戏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_495-提莫攻击" tabindex="-1"><a class="header-anchor" href="#_495-提莫攻击" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener noreferrer">495. 提莫攻击<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_520-检测大写字母" tabindex="-1"><a class="header-anchor" href="#_520-检测大写字母" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener noreferrer">520. 检测大写字母<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_397-整数替换" tabindex="-1"><a class="header-anchor" href="#_397-整数替换" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/integer-replacement/" target="_blank" rel="noopener noreferrer">397. 整数替换<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>暴力模拟 + 备忘录防止重复 （根号n复杂度）</p><h4 id="_384-打乱数组" tabindex="-1"><a class="header-anchor" href="#_384-打乱数组" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/shuffle-an-array/" target="_blank" rel="noopener noreferrer">384. 打乱数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>Knuth洗牌算法</p><p>对于下标为 0 位置，从 [0,n−1] 随机一个位置进行交换，共有 n 种选择；下标为 1 的位置，从 [1,n−1] 随机一个位置进行交换，共有n−1 种选择 ...</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>for (int i = 0; i &lt; n; i++) {
	swap(ans, i, i + random.nextInt(n - i));
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] nums;
    int n;
    Random r;
    public Solution(int[] _nums) {
        nums = _nums;
        n = nums.length;
        r = new Random();
    }
    
    public int[] reset() {
        return nums;
    }
    
    public int[] shuffle() {
        int[] res = nums.clone();
        for (int i = 0; i &lt; n; i ++ ) {
            swap(res, i, i + r.nextInt(n - i));
        }
        return res;
    }

    public void swap(int[] arr, int a, int b) {
        int t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_859-亲密字符串" tabindex="-1"><a class="header-anchor" href="#_859-亲密字符串" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/buddy-strings/" target="_blank" rel="noopener noreferrer">859. 亲密字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_423-从英文中重建数字" tabindex="-1"><a class="header-anchor" href="#_423-从英文中重建数字" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener noreferrer">423. 从英文中重建数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>我们可以先对 <code>s</code> 进行词频统计，然后根据「英文单词中的字符唯一性」确定构建的顺序</p><h4 id="_50-pow-x-n" tabindex="-1"><a class="header-anchor" href="#_50-pow-x-n" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener noreferrer">50. Pow(x, n)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_506-相对名次" tabindex="-1"><a class="header-anchor" href="#_506-相对名次" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/relative-ranks/" target="_blank" rel="noopener noreferrer">506. 相对名次<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1816-截断句子" tabindex="-1"><a class="header-anchor" href="#_1816-截断句子" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/truncate-sentence/" target="_blank" rel="noopener noreferrer">1816. 截断句子<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_794-有效的井字游戏" tabindex="-1"><a class="header-anchor" href="#_794-有效的井字游戏" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/valid-tic-tac-toe-state/" target="_blank" rel="noopener noreferrer">794. 有效的井字游戏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_748-最短补全词" tabindex="-1"><a class="header-anchor" href="#_748-最短补全词" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/shortest-completing-word/" target="_blank" rel="noopener noreferrer">748. 最短补全词<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_2275-按位与结果大于零的最长组合" tabindex="-1"><a class="header-anchor" href="#_2275-按位与结果大于零的最长组合" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/" target="_blank" rel="noopener noreferrer">2275. 按位与结果大于零的最长组合<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int largestCombination(int[] nums) {
        /*对于一个序列，其中每一个元素转换为二进制后看成一个32位的数组，
         每一位不是0就是1。一个序列要想“与运算”后不为0，
         其实只要序列中某一位全都是1即可。于是我们可以对原数组每个元素按位求和，
         最大的那个和就是最长“与运算”后结果不为0的序列长度。
        */
        int n = nums.length, ans = 0;
        for (int i = 0; i &lt; 32; i ++ ) {
            int cnt = 0;
            for (int j = 0; j &lt; n; j ++ ) {
                if ((nums[j] &gt;&gt; i &amp; 1) == 1) cnt ++ ;
            }
            ans = Math.max(ans, cnt);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_735-行星碰撞" tabindex="-1"><a class="header-anchor" href="#_735-行星碰撞" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/asteroid-collision/" target="_blank" rel="noopener noreferrer">735. 行星碰撞<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        ArrayDeque&lt;Integer&gt; s = new ArrayDeque&lt;&gt;();
        for (int x : asteroids) {
            if (x &gt; 0) s.push(x);
            else {
                while (s.size() &gt; 0 &amp;&amp; s.peek() &gt; 0 &amp;&amp; s.peek() &lt; -x) s.pop();
                if (s.size() &gt; 0 &amp;&amp; s.peek() == -x) s.pop();
                else if (s.size() == 0 || s.peek() &lt; 0) s.push(x);
            }
        }
        if (s.size() == 0) return new int[]{};
        int[] res = new int[s.size()];
        for (int i = 0; i &lt; res.length; i ++ ) res[i] = s.pollLast();
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_118-杨辉三角" tabindex="-1"><a class="header-anchor" href="#_118-杨辉三角" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/pascals-triangle/" target="_blank" rel="noopener noreferrer">118. 杨辉三角<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList();
        for (int i = 0; i &lt; numRows; i ++ ) {
            List&lt;Integer&gt; tem = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt;= i; j ++ ) {
                if (j == 0 || j == i) tem.add(1);
                else tem.add(ans.get(i - 1).get(j - 1) + ans.get(i - 1).get(j));
            }
            ans.add(tem);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-ii-041-滑动窗口的平均值" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-041-滑动窗口的平均值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/qIsx9U/" target="_blank" rel="noopener noreferrer">剑指 Offer II 041. 滑动窗口的平均值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MovingAverage {
    int sum = 0, n;
    ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
    /** Initialize your data structure here. */
    public MovingAverage(int size) {
        n = size;
    }
    
    public double next(int val) {
        if (q.size() &gt;= n) sum -= q.poll();
        sum += val;
        q.add(val);
        return sum * 1.0 / q.size();
    }
}

/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage obj = new MovingAverage(size);
 * double param_1 = obj.next(val);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1260-二维网格迁移" tabindex="-1"><a class="header-anchor" href="#_1260-二维网格迁移" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shift-2d-grid/" target="_blank" rel="noopener noreferrer">1260. 二维网格迁移<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] g, int k) {
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        int n = g.length, m = g[0].length;
        int[] arr = new int[m * n];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                int idx = i * m + j + k;
                idx %= (m * n);
                arr[idx] = g[i][j];
            }
        }
        for (int i = 0; i &lt; n; i ++ ) {
            List&lt;Integer&gt; tem = new ArrayList&lt;&gt;();
            for (int j = 0; j &lt; m; j ++ ) {
                tem.add(arr[i * m + j]);
            }
            res.add(tem);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_169-多数元素" tabindex="-1"><a class="header-anchor" href="#_169-多数元素" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/majority-element/" target="_blank" rel="noopener noreferrer">169. 多数元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int majorityElement(int[] nums) {
        int r = 0, c = 0;
        for (int x : nums) {
            if (c == 0) {
                r = x;
                c = 1;
            } else if (r == x) {
                c ++ ;
            } else {
                c -- ;
            }
        }
        return r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_592-分数加减运算" tabindex="-1"><a class="header-anchor" href="#_592-分数加减运算" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/" target="_blank" rel="noopener noreferrer">592. 分数加减运算<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a; 
    }
    public String fractionAddition(String ex) {
        if (ex.charAt(0) != &#39;-&#39;) ex = &quot;+&quot; + ex;
        int a = 0, b = 1;
        for (int i = 0; i &lt; ex.length(); ) {
            int t = i + 1;
            while (ex.charAt(t) != &#39;/&#39;) t ++ ;
            int c = Integer.parseInt(ex.substring(i + 1, t));
            int j = t + 1;
            while (j &lt; ex.length() &amp;&amp; Character.isDigit(ex.charAt(j))) j ++ ;
            int d = Integer.parseInt(ex.substring(t + 1, j));
            if (ex.charAt(i) == &#39;-&#39;) c = -c;
            a = a * d + b * c;
            b = b * d;
            i = j;
        } 
        int z = gcd(a, b);
        a /= z; b /= z;
        if (b &lt; 0) {
            a = -a;
            b = -b;
        }
        return a + &quot;/&quot; + b;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_622-设计循环队列" tabindex="-1"><a class="header-anchor" href="#_622-设计循环队列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/design-circular-queue/" target="_blank" rel="noopener noreferrer">622. 设计循环队列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MyCircularQueue {
    int[] q;
    int hh = 0, tt = 0;
    public MyCircularQueue(int k) {
        //将长度开到k + 1，目的是区分队空和队满的情况
        q = new int[k + 1];
    }
    
    public boolean enQueue(int x) {
        if (isFull()) return false;
        q[tt ++ ] = x;
        if (tt == q.length) tt = 0;
        return true;
    }
    
    public boolean deQueue() {
        if (isEmpty()) return false;
        hh ++ ;
        if (hh == q.length) hh = 0;
        return true;
    }
    
    public int Front() {
        if (isEmpty()) return -1;
        return q[hh];
    }
    
    public int Rear() {
        if (isEmpty()) return -1;
        int t = tt - 1;
        return t &lt; 0 ? q[q.length - 1] : q[t];
    }
    
    public boolean isEmpty() {
        return hh == tt;
    }
    
    public boolean isFull() {
        return (tt + 1) % q.length == hh;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_224-基本计算器" tabindex="-1"><a class="header-anchor" href="#_224-基本计算器" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/basic-calculator/" target="_blank" rel="noopener noreferrer">224. 基本计算器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void calc(ArrayDeque&lt;Integer&gt; num, ArrayDeque&lt;Character&gt; op) {
        var b = num.pop();
        var a = num.pop();
        if (op.peek() == &#39;+&#39;) num.push(a + b);
        else num.push(a - b);
        op.pop();
    }

    public int calculate(String rs) {
        StringBuilder sb = new StringBuilder();
        for (char x : rs.toCharArray())
            if (x != &#39; &#39;)
                sb.append(x);
        String s = sb.toString();
        ArrayDeque&lt;Integer&gt; num = new ArrayDeque&lt;&gt;();
        ArrayDeque&lt;Character&gt; op = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i ++ ) {
            char c = s.charAt(i);
            if (c == &#39; &#39;) continue;
            if (c == &#39;+&#39; || c == &#39;-&#39;) {
                //特殊符号处理
                if (i == 0 || s.charAt(i - 1) == &#39;-&#39; || s.charAt(i - 1) == &#39;(&#39;) 
                    num.push(0);
                op.push(c);
            } else if (c == &#39;(&#39;) {
                op.push(c);
            } else if (c == &#39;)&#39;) {
                op.pop();
                while (!op.isEmpty() &amp;&amp; op.peek() != &#39;(&#39;) calc(num, op);
            } else {
                int k = i;
                while (k &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(k))) k ++ ;
                num.push(Integer.parseInt(s.substring(i, k)));
                i = k - 1;
                while (!op.isEmpty() &amp;&amp; op.peek() != &#39;(&#39;) calc(num, op);
            }
        }
        return num.pop();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_640-求解方程" tabindex="-1"><a class="header-anchor" href="#_640-求解方程" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/solve-the-equation/" target="_blank" rel="noopener noreferrer">640. 求解方程<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public Pair&lt;Integer, Integer&gt; work(String s) {
        int a = 0, b = 0;
        if (s.charAt(0) != &#39;-&#39;) s = &#39;+&#39; + s;
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int j = i + 1;
            while (j &lt; s.length() &amp;&amp; Character.isDigit(s.charAt(j))) j ++ ;
            int c = 1;
            if (i + 1 &lt;= j - 1) c = Integer.parseInt(s.substring(i + 1, j));
            if (s.charAt(i) == &#39;-&#39;) c *= -1;
            if (j &lt; s.length() &amp;&amp; s.charAt(j) == &#39;x&#39;) {
                a += c;
                i = j;
            }
            else {
                b += c;
                i = j - 1;
            }   
        }
        return new Pair(a, b);
    }
    public String solveEquation(String equation) {
        String[] ss = equation.split(&quot;=&quot;);
        //左右分别合并同类项，再分类讨论答案
        Pair&lt;Integer, Integer&gt; l = work(ss[0]), r = work(ss[1]);
        int A = l.getKey() - r.getKey(), B = r.getValue() - l.getValue();
        if (A == 0 &amp;&amp; B == 0) return &quot;Infinite solutions&quot;;
        else if (A == 0 &amp;&amp; B != 0) return &quot;No solution&quot;;
        else return &quot;x=&quot; + B / A;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2196-根据描述创建二叉树" tabindex="-1"><a class="header-anchor" href="#_2196-根据描述创建二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/create-binary-tree-from-descriptions/" target="_blank" rel="noopener noreferrer">2196. 根据描述创建二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public TreeNode createBinaryTree(int[][] descriptions) {
        //用去重和构建二叉树
        Map&lt;Integer, TreeNode&gt; map = new HashMap&lt;&gt;();
        //用来确定根节点
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int[] node : descriptions) {
            int p = node[0], c = node[1], left = node[2];
            set.add(c);
            if (!map.containsKey(p)) map.put(p, new TreeNode(p));
            if (!map.containsKey(c)) map.put(c, new TreeNode(c));
            if (left == 1) map.get(p).left = map.get(c);
            else map.get(p).right = map.get(c);
        }
        TreeNode res = null;
        for (int x : map.keySet())
            if (!set.contains(x))
                res = map.get(x);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_641-设计循环双端队列" tabindex="-1"><a class="header-anchor" href="#_641-设计循环双端队列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/design-circular-deque/" target="_blank" rel="noopener noreferrer">641. 设计循环双端队列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MyCircularDeque {
    int[] q;
    int hh, tt, sz, n;
    public MyCircularDeque(int k) {
        n = k;
        sz = 0;
        hh = tt = 0;
        q = new int[k];
    }
    
    public boolean insertFront(int value) {
        if (isFull()) return false;
        hh = (hh + n - 1) % n;
        q[hh] = value;
        sz ++ ;
        return true;
    }
    
    public boolean insertLast(int value) {
        if (isFull()) return false;
        q[tt ++ ] = value;
        tt %= n;
        sz ++ ;
        return true;
    }
    
    public boolean deleteFront() {
        if (isEmpty()) return false;
        hh = (hh  + 1) % n;
        sz -- ;
        return true;
    }
    
    public boolean deleteLast() {
        if (isEmpty()) return false;
        tt = (tt - 1 + n) % n;
        sz -- ;
        return true;
    }
    
    public int getFront() {
        if (isEmpty()) return -1;
        return q[hh];
    }
    
    public int getRear() {
        if (isEmpty()) return -1;
        int t = tt - 1;
        return t &lt; 0 ? q[q.length - 1] : q[t];
    }
    
    public boolean isEmpty() {
        return sz == 0;
    }
    
    public boolean isFull() {
        return sz == n;
    }
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque obj = new MyCircularDeque(k);
 * boolean param_1 = obj.insertFront(value);
 * boolean param_2 = obj.insertLast(value);
 * boolean param_3 = obj.deleteFront();
 * boolean param_4 = obj.deleteLast();
 * int param_5 = obj.getFront();
 * int param_6 = obj.getRear();
 * boolean param_7 = obj.isEmpty();
 * boolean param_8 = obj.isFull();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1329-将矩阵按对角线排序" tabindex="-1"><a class="header-anchor" href="#_1329-将矩阵按对角线排序" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sort-the-matrix-diagonally/" target="_blank" rel="noopener noreferrer">1329. 将矩阵按对角线排序<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] diagonalSort(int[][] mat) {
        int n = mat.length, m = mat[0].length;
        int[] t = new int[m + n];
        for (int i = 0; i &lt; n; i ++ ) {
            int idx = 0;
            for (int x = i, y = 0; x &lt; n &amp;&amp; y &lt; m; x ++ , y ++ ) 
                t[idx ++ ] = mat[x][y];
            Arrays.sort(t, 0, idx);
            for (int j = 0, x = i, y = 0; j &lt; idx; j ++ ) 
                mat[x ++ ][y ++ ] = t[j];
        }
        for (int i = 0; i &lt; m; i ++ ) {
            int idx = 0;
            for (int x = 0, y = i; x &lt; n &amp;&amp; y &lt; m; x ++ , y ++ ) 
                t[idx ++ ] = mat[x][y];
            Arrays.sort(t, 0, idx);
            for (int j = 0, x = 0, y = i; j &lt; idx; j ++) 
                mat[x ++ ][y ++ ] = t[j];
        }
        return mat;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1360-日期之间隔几天" tabindex="-1"><a class="header-anchor" href="#_1360-日期之间隔几天" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/number-of-days-between-two-dates/" target="_blank" rel="noopener noreferrer">1360. 日期之间隔几天<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] month = new int[]{0,31,28,31,30,31,30,31,31,30,31,30,31};
    public int daysBetweenDates(String date1, String date2) {
        return Math.abs(get(date1) - get(date2));
    }
    public int isleap(int year) {
        //四年一闰，百年不闰，四百年再闰
        if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) return 1;
        return 0;
    }
    public int get(String date) {
        String[] s = date.split(&quot;-&quot;);
        int y = Integer.parseInt(s[0]);
        int m = Integer.parseInt(s[1]);
        int d = Integer.parseInt(s[2]);
        int res = 0;
        for (int i = 1971; i &lt; y; i ++ ) 
            res += 365 + isleap(i);
        for (int i = 1; i &lt; m; i ++ ) {
            if (i == 2) res += isleap(y);
            res += month[i];
        }
        res += d;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_38-外观数列" tabindex="-1"><a class="header-anchor" href="#_38-外观数列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-and-say/" target="_blank" rel="noopener noreferrer">38. 外观数列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String countAndSay(int n) {
        if (n == 1) return &quot;1&quot;;
        String s = countAndSay(n - 1);
        StringBuilder res = new StringBuilder();
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int j = i;
            while (j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) j ++ ;
            res.append(j - i).append(s.charAt(i));
            i = j - 1;
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1073-负二进制数相加" tabindex="-1"><a class="header-anchor" href="#_1073-负二进制数相加" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/adding-two-negabinary-numbers/" target="_blank" rel="noopener noreferrer">1073. 负二进制数相加<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void swap(int[] ss, int l, int r) {
        int t = ss[l];
        ss[l] = ss[r];
        ss[r] = t;
    }
    public void reverse(int[] ss, int l, int r) {
        while (l &lt; r) {
            swap(ss, l, r);
            l ++ ;
            r -- ;
        }
    }
    public int[] addNegabinary(int[] A, int[] B) {
        reverse(A, 0, A.length - 1);
        reverse(B, 0, B.length - 1);
        var C = new ArrayList&lt;Integer&gt;();
        //1 + 1 = 110
        //11 + 1 = 0
        for (int i = 0, a = 0, b = 0, c = 0; i &lt; Math.max(A.length, B.length) || a &gt; 0 || b &gt; 0; i ++ ) {
            if (a == 1 &amp;&amp; b == 2) a = b = 0;
            c = b;
            b = a;
            a = 0;
            if (i &lt; A.length) c += A[i];
            if (i &lt; B.length) c += B[i];
            C.add(c &amp; 1); 
            c &gt;&gt;= 1;
            a += c;
            b += c;
        }
        while (C.size() &gt; 1 &amp;&amp; C.get(C.size() - 1) == 0) C.remove(C.size() - 1);
        Collections.reverse(C);
        return C.stream().mapToInt(x -&gt; x).toArray();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_842-将数组拆分成斐波那契序列" tabindex="-1"><a class="header-anchor" href="#_842-将数组拆分成斐波那契序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/split-array-into-fibonacci-sequence/" target="_blank" rel="noopener noreferrer">842. 将数组拆分成斐波那契序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; splitIntoFibonacci(String s) {
        for (int i = 1; i &lt;= 10 &amp;&amp; i &lt; s.length(); i ++ ) {
            for (int j = i + 1; j &lt;= i + 10 &amp;&amp; j &lt; s.length(); j ++ ) {
                long a = Long.parseLong(s.substring(0, i));
                long b = Long.parseLong(s.substring(i, j));
                List&lt;Integer&gt; res = dfs(a, b, s);
                if (res.size() != 0) return res;
            }
        }
        return new ArrayList&lt;&gt;();
    }
    public List&lt;Integer&gt; dfs(long a, long b, String s) {
        var res = new ArrayList&lt;Integer&gt;();
        res.add((int)a);
        res.add((int)b);
        StringBuilder t = new StringBuilder().append(a).append(b);
        while (t.length() &lt; s.length()) {
            long c = a + b;
            if (c &gt;= Integer.MAX_VALUE) return new ArrayList&lt;&gt;();
            t.append(c);
            res.add((int)c);
            a = b;
            b = c;
        }
        if (!t.toString().equals(s)) return new ArrayList&lt;&gt;();
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_289-生命游戏" tabindex="-1"><a class="header-anchor" href="#_289-生命游戏" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/game-of-life/" target="_blank" rel="noopener noreferrer">289. 生命游戏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    static int[][] ds = new int[][]{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, - 1}, {1, -1}};
    //最后一位为初始状态，第二位为新状态
    public void gameOfLife(int[][] board) {
        int n = board.length, m = board[0].length;
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                int live = 0;
                for (int[] d : ds) {
                    int x = i + d[0], y = j + d[1];
                    if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m)
                        live += board[x][y] &amp; 1;
                }
                if ((board[i][j] &amp; 1) &gt; 0) {
                    if (live &gt;= 2 &amp;&amp; live &lt;= 3)
                        board[i][j] = 3;
                } else if (live == 3) 
                    board[i][j] = 2;
            }
        }
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m; j ++ )
                board[i][j] &gt;&gt;= 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_950-按递增顺序显示卡牌" tabindex="-1"><a class="header-anchor" href="#_950-按递增顺序显示卡牌" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/reveal-cards-in-increasing-order/" target="_blank" rel="noopener noreferrer">950. 按递增顺序显示卡牌<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] deckRevealedIncreasing(int[] deck) {
        Arrays.sort(deck);
        int n = deck.length;
        var q = new ArrayDeque&lt;Integer&gt;();
        for (int i = 0; i &lt; n; i ++ ) q.add(i);
        int idx = 0;
        var res = new int[n];
        while (!q.isEmpty()) {
            int t = q.poll();
            res[t] = deck[idx ++ ];
            if (!q.isEmpty()) 
                q.add(q.poll());
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_647-回文子串" tabindex="-1"><a class="header-anchor" href="#_647-回文子串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener noreferrer">647. 回文子串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：中心扩展</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int countSubstrings(String s) {
        var res = 0;
        var n = s.length();
        for (int i = 0; i &lt; n * 2 - 1; i ++ ) {
            int l = i / 2, r = l + i % 2;
            while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) {
                res ++ ;
                l -- ;
                r ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="面试题-01-08-零矩阵" tabindex="-1"><a class="header-anchor" href="#面试题-01-08-零矩阵" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/zero-matrix-lcci/" target="_blank" rel="noopener noreferrer">面试题 01.08. 零矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void setZeroes(int[][] matrix) {
        int n = matrix.length, m = matrix[0].length;
        Set&lt;Integer&gt; row = new HashSet&lt;&gt;();
        Set&lt;Integer&gt; col = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m; j ++ )
                if (matrix[i][j] == 0) {
                    row.add(i);
                    col.add(j);
                }
        for (int i = 0; i &lt; n; i ++ )
            if (row.contains(i))
                Arrays.fill(matrix[i], 0);
        for (int j = 0; j &lt; m; j ++ )
            if (col.contains(j)) 
                for (int i = 0; i &lt; n; i ++ )
                    matrix[i][j] = 0;   
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_912-排序数组" tabindex="-1"><a class="header-anchor" href="#_912-排序数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sort-an-array/" target="_blank" rel="noopener noreferrer">912. 排序数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：手撕堆排</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] h;
    public void swap(int a, int b) {
        int t = h[a];
        h[a] = h[b];
        h[b] = t;
    }
    public void down(int u, int k) {
        int t = u;
        if (u * 2 &lt; k &amp;&amp; h[t] &gt; h[u * 2]) t = u * 2;
        if (u * 2 + 1 &lt; k &amp;&amp; h[t] &gt; h[u * 2 + 1]) t = u * 2 + 1;
        if (u != t) {
            swap(u ,t);
            down(t, k);
        } 
    }
    public void buildHeap(int[] nums, int n) {
        h = new int[n + 1];
        //建堆
        for (int i = 1; i &lt;= n; i ++ )
            h[i] = nums[i - 1];
        for (int i = n / 2; i &gt; 0; i -- )
            down(i, h.length);
    }
    public void headSort(int[] nums) {
        int n = nums.length;
        buildHeap(nums, n);
        //每次取出堆顶并删除
        for (int i = 0; i &lt; nums.length; i ++ ) {
            nums[i] = h[1];
            swap(1, n - i);
            down(1, n - i);
        }
    }
    public int[] sortArray(int[] nums) {
        headSort(nums);
        return nums;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-55-i-二叉树的深度" tabindex="-1"><a class="header-anchor" href="#剑指-offer-55-i-二叉树的深度" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 55 - I. 二叉树的深度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.11</p><h4 id="_938-二叉搜索树的范围和" tabindex="-1"><a class="header-anchor" href="#_938-二叉搜索树的范围和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/range-sum-of-bst/" target="_blank" rel="noopener noreferrer">938. 二叉搜索树的范围和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.13</p><h4 id="_617-合并二叉树" tabindex="-1"><a class="header-anchor" href="#_617-合并二叉树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener noreferrer">617. 合并二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_589-n-叉树的前序遍历" tabindex="-1"><a class="header-anchor" href="#_589-n-叉树的前序遍历" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">589. N 叉树的前序遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_590-n-叉树的后序遍历" tabindex="-1"><a class="header-anchor" href="#_590-n-叉树的后序遍历" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener noreferrer">590. N 叉树的后序遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.15</p><h4 id="剑指-offer-27-二叉树的镜像" tabindex="-1"><a class="header-anchor" href="#剑指-offer-27-二叉树的镜像" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 27. 二叉树的镜像<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>递归</p><h4 id="_700-二叉搜索树中的搜索" tabindex="-1"><a class="header-anchor" href="#_700-二叉搜索树中的搜索" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">700. 二叉搜索树中的搜索<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.16</p><h4 id="_1302-层数最深叶子节点的和" tabindex="-1"><a class="header-anchor" href="#_1302-层数最深叶子节点的和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener noreferrer">1302. 层数最深叶子节点的和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>dfs/bfs</p><h4 id="_222-完全二叉树的节点个数" tabindex="-1"><a class="header-anchor" href="#_222-完全二叉树的节点个数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener noreferrer">222. 完全二叉树的节点个数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        TreeNode l = root.left, r = root.right;
        int x = 1, y = 1;
        while (l != null) {
            l = l.left;
            x ++ ;
        }
        while (r != null) {
            r = r.right;
            y ++ ;
        }
        if (x == y) return (1 &lt;&lt; x) - 1;
        return countNodes(root.left) + countNodes(root.right) + 1;     
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="面试题-04-02-最小高度树" tabindex="-1"><a class="header-anchor" href="#面试题-04-02-最小高度树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/minimum-height-tree-lcci/" target="_blank" rel="noopener noreferrer">面试题 04.02. 最小高度树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_108-将有序数组转换为二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_108-将有序数组转换为二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">108. 将有序数组转换为二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_111-二叉树的最小深度" tabindex="-1"><a class="header-anchor" href="#_111-二叉树的最小深度" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">111. 二叉树的最小深度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>注意陷阱：左右子树中 一个为空，一个不为空的情况</p><p>11.17</p><h4 id="_654-最大二叉树" tabindex="-1"><a class="header-anchor" href="#_654-最大二叉树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener noreferrer">654. 最大二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_100-相同的树" tabindex="-1"><a class="header-anchor" href="#_100-相同的树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener noreferrer">100. 相同的树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_783-二叉搜索树节点最小距离" tabindex="-1"><a class="header-anchor" href="#_783-二叉搜索树节点最小距离" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/" target="_blank" rel="noopener noreferrer">783. 二叉搜索树节点最小距离<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_230-二叉搜索树中第k小的元素" tabindex="-1"><a class="header-anchor" href="#_230-二叉搜索树中第k小的元素" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener noreferrer">230. 二叉搜索树中第K小的元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>二叉搜索树的中序遍历是有序的，因此我们可以直接对「二叉搜索树」进行中序遍历，保存遍历过程中的第k个数即可（783同理可找到最小距离）</p><h4 id="_429-n-叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_429-n-叉树的层序遍历" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">429. N 叉树的层序遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_563-二叉树的坡度" tabindex="-1"><a class="header-anchor" href="#_563-二叉树的坡度" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener noreferrer">563. 二叉树的坡度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_559-n-叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#_559-n-叉树的最大深度" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener noreferrer">559. N 叉树的最大深度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_897-递增顺序搜索树" tabindex="-1"><a class="header-anchor" href="#_897-递增顺序搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener noreferrer">897. 递增顺序搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_99-恢复二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_99-恢复二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/recover-binary-search-tree/" target="_blank" rel="noopener noreferrer">99. 恢复二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_109-有序链表转换二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_109-有序链表转换二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">109. 有序链表转换二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_96-不同的二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_96-不同的二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener noreferrer">96. 不同的二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_98-验证二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_98-验证二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener noreferrer">98. 验证二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_101-对称二叉树" tabindex="-1"><a class="header-anchor" href="#_101-对称二叉树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">101. 对称二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_404-左叶子之和" tabindex="-1"><a class="header-anchor" href="#_404-左叶子之和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener noreferrer">404. 左叶子之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_872-叶子相似的树" tabindex="-1"><a class="header-anchor" href="#_872-叶子相似的树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/leaf-similar-trees/" target="_blank" rel="noopener noreferrer">872. 叶子相似的树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_701-二叉搜索树中的插入操作" tabindex="-1"><a class="header-anchor" href="#_701-二叉搜索树中的插入操作" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">701. 二叉搜索树中的插入操作<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_671-二叉树中第二小的节点" tabindex="-1"><a class="header-anchor" href="#_671-二叉树中第二小的节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener noreferrer">671. 二叉树中第二小的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_513-找树左下角的值" tabindex="-1"><a class="header-anchor" href="#_513-找树左下角的值" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener noreferrer">513. 找树左下角的值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//bfs
class Solution {
    public int findBottomLeftValue(TreeNode root) {
        ArrayDeque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
        q.add(root);
        while (!q.isEmpty()) {
            root = q.poll();
            if (root.right != null) q.add(root.right);
            if (root.left != null) q.add(root.left);
        }
        return root.val;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs
class Solution {
    int res = 0, dep = -1;
    public int findBottomLeftValue(TreeNode root) {
        dfs(root, 0);
        return res;
    }
    public void dfs(TreeNode root, int depth) {
        if (root == null) return;
        if (depth &gt; dep) {
            dep = depth;
            res = root.val;
        }
        dfs(root.left, depth + 1);
        dfs(root.right, depth + 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1325-删除给定值的叶子节点" tabindex="-1"><a class="header-anchor" href="#_1325-删除给定值的叶子节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/" target="_blank" rel="noopener noreferrer">1325. 删除给定值的叶子节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_114-二叉树展开为链表" tabindex="-1"><a class="header-anchor" href="#_114-二叉树展开为链表" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener noreferrer">114. 二叉树展开为链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_538-把二叉搜索树转换为累加树" tabindex="-1"><a class="header-anchor" href="#_538-把二叉搜索树转换为累加树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener noreferrer">538. 把二叉搜索树转换为累加树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>二叉搜索树中序遍历倒以下为递减序列</p><h4 id="_173-二叉搜索树迭代器" tabindex="-1"><a class="header-anchor" href="#_173-二叉搜索树迭代器" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener noreferrer">173. 二叉搜索树迭代器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1609-奇偶树" tabindex="-1"><a class="header-anchor" href="#_1609-奇偶树" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/even-odd-tree/" target="_blank" rel="noopener noreferrer">1609. 奇偶树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_449-序列化和反序列化二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_449-序列化和反序列化二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener noreferrer">449. 序列化和反序列化二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_331-验证二叉树的前序序列化" tabindex="-1"><a class="header-anchor" href="#_331-验证二叉树的前序序列化" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">331. 验证二叉树的前序序列化<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean isValidSerialization(String s) {
        int n = s.length();
        int num = 0;
        for (int i = n - 1; i &gt;= 0; i -- ) {
            char c = s.charAt(i);
            if (c == &#39;,&#39;) continue;
            else if (c ==&#39;#&#39;) num ++ ;
            else {
                while (i &gt; 0 &amp;&amp; s.charAt(i - 1) != &#39;,&#39;) i -- ;
                if (num &gt;= 2) num -- ;
                else {
                    if (num &lt; 2) return false;
                } 
            }
        } 
        if (num != 1) return false;
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-ii-047-二叉树剪枝" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-047-二叉树剪枝" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/pOCWxh/" target="_blank" rel="noopener noreferrer">剑指 Offer II 047. 二叉树剪枝<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        if (root == null) return null;
        root.left = pruneTree(root.left);
        root.right = pruneTree(root.right);
        if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0) root = null;
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_113-路径总和-ii" tabindex="-1"><a class="header-anchor" href="#_113-路径总和-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener noreferrer">113. 路径总和 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    ArrayDeque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {
        dfs(root, targetSum);
        return res;
    }
    public void dfs(TreeNode root, int sum) {
        if (root == null) return;
        path.add(root.val);
        sum -= root.val;
        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0)
            res.add(new ArrayList&lt;&gt;(path));
        dfs(root.left, sum);
        dfs(root.right, sum);
        path.pollLast();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_437-路径总和-iii" tabindex="-1"><a class="header-anchor" href="#_437-路径总和-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noopener noreferrer">437. 路径总和 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs + 前缀和
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    Map&lt;Integer, Integer&gt; cnt = new HashMap&lt;&gt;();
    public int pathSum(TreeNode root, int targetSum) {
        cnt.put(0, 1);
        dfs(root, targetSum, 0);
        return ans;
    }
    public void dfs(TreeNode root, int target, int cur) {
        if (root == null) return;
        cur += root.val;
        //Si - Sj = T --&gt; Sj = Si - T --&gt; Sj = cnt - target
        if (cnt.containsKey(cur - target)) ans += cnt.get(cur - target);
        cnt.put(cur, cnt.getOrDefault(cur, 0) + 1);
        dfs(root.right, target, cur);
        dfs(root.left, target, cur);
        cnt.put(cur, cnt.get(cur) - 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_515-在每个树行中找最大值" tabindex="-1"><a class="header-anchor" href="#_515-在每个树行中找最大值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener noreferrer">515. 在每个树行中找最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//bfs
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;Integer&gt; largestValues(TreeNode root) {
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        ArrayDeque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
        if (root == null) return res;
        q.add(root);
        while (!q.isEmpty()) {
            int count = q.size();
            int max = Integer.MIN_VALUE;
            while (count -- &gt; 0) {
                TreeNode node = q.poll();
                max = Math.max(max, node.val);
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            res.add(max);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs
class Solution {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    int max = Integer.MAX_VALUE;
    public List&lt;Integer&gt; largestValues(TreeNode root) {
        dfs(root, 0);
        return res;
    }
    public void dfs(TreeNode root, int depth) {
        if (root == null) return;
        if (depth == res.size()) res.add(root.val);
        else res.set(depth, Math.max(res.get(depth), root.val));
        dfs(root.left, depth + 1);
        dfs(root.right, depth + 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_919-完全二叉树插入器" tabindex="-1"><a class="header-anchor" href="#_919-完全二叉树插入器" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/" target="_blank" rel="noopener noreferrer">919. 完全二叉树插入器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法1：队列</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class CBTInserter {
    ArrayDeque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
    TreeNode root;
    public CBTInserter(TreeNode _root) {
        root = _root;
        TreeNode cur = root;
        if (cur != null) q.add(cur);
        while (!q.isEmpty()) {
            cur = q.peek();
            if (cur.left != null) q.add(cur.left);
            if (cur.right != null) q.add(cur.right);

            //如果该节点满了就poll
            if (cur.right != null) q.poll();
            else break;
        }
    }
    
    public int insert(int val) {
        TreeNode cur = q.peek();
        TreeNode node = new TreeNode(val);
        if (cur.left == null) cur.left = node;
        else {
            cur.right = node;
            q.poll();
        }
        q.add(node);
        return cur.val;
    }
    
    public TreeNode get_root() {
        return root;
    }
}

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter obj = new CBTInserter(root);
 * int param_1 = obj.insert(val);
 * TreeNode param_2 = obj.get_root();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2：list模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class CBTInserter {
    ArrayList&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();
    int idx = 0;
    public CBTInserter(TreeNode root) {
        list.add(root);
        int cur = 0;
        while (cur &lt; list.size()) {
            TreeNode node = list.get(cur);
            if (node.left != null) list.add(node.left);
            if (node.right != null) list.add(node.right);
            cur ++ ;
        }
    }
    
    public int insert(int val) {
        while (list.get(idx).left != null &amp;&amp; list.get(idx).right != null) idx ++;
        TreeNode cur = list.get(idx);
        TreeNode node = new TreeNode(val);
        if (cur.left == null) cur.left = node;
        else {
            cur.right = node;
            idx ++ ;
        }
        list.add(node);
        return cur.val;
    }
    
    public TreeNode get_root() {
        return list.get(0);
    }
}

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter obj = new CBTInserter(root);
 * int param_1 = obj.insert(val);
 * TreeNode param_2 = obj.get_root();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1161-最大层内元素和" tabindex="-1"><a class="header-anchor" href="#_1161-最大层内元素和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">1161. 最大层内元素和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：层序遍历</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxLevelSum(TreeNode root) {
        int res = 0, max = Integer.MIN_VALUE;
        //当前层数
        int t = 1;
        ArrayDeque&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();
        q.add(root);
        while (!q.isEmpty()) {
            int cur = 0, num = q.size();
            while (num -- &gt; 0) {
                TreeNode node = q.poll();
                cur += node.val;
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            if (cur &gt; max) {
                max = cur;
                res = t;
            }
            t ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：深搜</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int[] map = new int[10010];
    int depth = 0;
    public int maxLevelSum(TreeNode root) {
        dfs(root, 1);
        int res = 0, max = -10010;
        for (int i = 1; i &lt;= depth; i ++ ) {
            if (max &lt; map[i]) {
                max = map[i];
                res = i;
            }
        }
        return res;
    }
    public void dfs(TreeNode root, int l) {
        if (root == null) return;
        depth = Math.max(depth, l);
        map[l] += root.val;
        dfs(root.left, l + 1);
        dfs(root.right, l + 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_889-根据前序和后序遍历构造二叉树" tabindex="-1"><a class="header-anchor" href="#_889-根据前序和后序遍历构造二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener noreferrer">889. 根据前序和后序遍历构造二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：深搜</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    public TreeNode constructFromPrePost(int[] pre, int[] pos) {
        for (int i = 0; i &lt; pre.length; i ++ )
            map.put(pos[i], i);
        return dfs(pre, pos, 0, pre.length - 1, 0, pos.length - 1);
    }
    public TreeNode dfs(int[] pre, int[] pos, int prl, int prr, int pol, int por) {
        if (prl &gt; prr) return null;
        TreeNode root = new TreeNode(pre[prl]);
        if (prl == prr) return root;
        int k = map.get(pre[prl + 1]) - pol;
        root.left = dfs(pre, pos, prl + 1, prl + 1 + k, pol, pol + k);
        root.right = dfs(pre, pos, prl + 1 + k + 1, prr, pol + k + 1, por - 1);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_105-从前序与中序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#_105-从前序与中序遍历序列构造二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">105. 从前序与中序遍历序列构造二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递归</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    public TreeNode buildTree(int[] pre, int[] in) {
        for (int i = 0; i &lt; in.length; i ++ ) 
            map.put(in[i], i);
        return dfs(pre, in, 0, pre.length - 1, 0, in.length - 1);
    }
    public TreeNode dfs(int[] pre, int[] in, int pl, int pr, int il, int ir) {
        if (il &gt; ir) return null;
        int k = map.get(pre[pl]) - il;
        TreeNode root = new TreeNode(pre[pl]);
        root.left = dfs(pre, in, pl + 1, pl + k, il, il + k - 1);
        root.right = dfs(pre, in, pl + k + 1, pr, il + k + 1, ir);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_106-从中序与后序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#_106-从中序与后序遍历序列构造二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener noreferrer">106. 从中序与后序遍历序列构造二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递归</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        int n = inorder.length;
        for (int i = 0; i &lt; n; i ++ ) map.put(inorder[i], i);
        return dfs(postorder, inorder, 0, n - 1, 0, n - 1);
    }
    public TreeNode dfs(int[] pos, int[] in, int pl, int pr, int il, int ir) {
        if (il &gt; ir) return null;
        int k = map.get(pos[pr]) - il;
        TreeNode root = new TreeNode(pos[pr]);
        root.left = dfs(pos, in, pl, pl + k - 1, il, il + k - 1);
        root.right = dfs(pos, in, pl + k, pr - 1, il + k + 1, ir);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1008-前序遍历构造二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_1008-前序遍历构造二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener noreferrer">1008. 前序遍历构造二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递归</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public TreeNode bstFromPreorder(int[] pre) {
        return dfs(pre, 0, pre.length - 1);
    }
    public TreeNode dfs(int[] pre, int l, int r) {
        if (l &gt; r) return null;
        TreeNode root = new TreeNode(pre[l]);
        int j = l;
        while (j + 1 &lt;= r &amp;&amp; pre[l] &gt; pre[j + 1]) j ++ ;
        root.left = dfs(pre, l + 1, j);
        root.right = dfs(pre, j + 1, r);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_687-最长同值路径" tabindex="-1"><a class="header-anchor" href="#_687-最长同值路径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-univalue-path/" target="_blank" rel="noopener noreferrer">687. 最长同值路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//与124类似
class Solution {
    private int res = 0;
    public int longestUnivaluePath(TreeNode root) {
        if (root == null) return 0;
        dfs(root, root.val);
        return res;
    }
    public int dfs(TreeNode root, int val) {
        if (root == null) return 0;
        int l = dfs(root.left, root.val);
        int r = dfs(root.right, root.val);
        res = Math.max(res, l + r);
        if (root.val == val) return Math.max(l, r) + 1;
        else return 0;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1339-分裂二叉树的最大乘积" tabindex="-1"><a class="header-anchor" href="#_1339-分裂二叉树的最大乘积" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/" target="_blank" rel="noopener noreferrer">1339. 分裂二叉树的最大乘积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：记忆化dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int mod = (int)1e9 + 7;
    long res = 0;
    Map&lt;TreeNode, Long&gt; map = new HashMap&lt;&gt;();
    public int maxProduct(TreeNode root) {
        map.put(null, 0l);
        dfs(root);
        for (TreeNode node : map.keySet()) 
            res = Math.max(res, (map.get(root) - map.get(node)) * map.get(node));
        return (int) (res % mod);
    }

    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        dfs(root.right);
        map.put(root, root.val * 1l + map.get(root.left) + map.get(root.right));
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1373-二叉搜索子树的最大键值和" tabindex="-1"><a class="header-anchor" href="#_1373-二叉搜索子树的最大键值和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/" target="_blank" rel="noopener noreferrer">1373. 二叉搜索子树的最大键值和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int res = 0;
    public class Node {
        boolean isSearch;
        int mx, mn, sum;
        public Node(boolean isSearch, int mx, int mn, int sum) {
            this.isSearch = isSearch;
            this.mx = mx;
            this.mn = mn;
            this.sum = sum;
        }
    }
    public int maxSumBST(TreeNode root) {
        dfs(root);
        return res;
    }
    public Node dfs(TreeNode root) {
        if (root == null) return new Node(true, -100000, 100000, 0);
        var l = dfs(root.left);
        var r = dfs(root.right);
        if (l.isSearch &amp;&amp; r.isSearch &amp;&amp; l.mx &lt; root.val &amp;&amp; r.mn &gt; root.val) {
            res = Math.max(res, root.val + l.sum + r.sum);
            return new Node(true, Math.max(r.mx, root.val), Math.min(l.mn, root.val), root.val + l.sum + r.sum);
        }
        else 
            return new Node(false, 0, 0, 0);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_921-使括号有效的最少添加" tabindex="-1"><a class="header-anchor" href="#_921-使括号有效的最少添加" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/" target="_blank" rel="noopener noreferrer">921. 使括号有效的最少添加<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minAddToMakeValid(String s) {
        int res = 0, cur = 0;
        for (char x : s.toCharArray()) {
            if (x == &#39;(&#39;) cur ++ ;
            else {
                if (cur != 0) cur -- ;
                else res ++ ;
            }
        } 
        while (cur -- &gt; 0) 
            res ++ ;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_295-数据流的中位数" tabindex="-1"><a class="header-anchor" href="#_295-数据流的中位数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-median-from-data-stream/" target="_blank" rel="noopener noreferrer">295. 数据流的中位数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class MedianFinder {
    
    PriorityQueue&lt;Integer&gt; a, b;
    public MedianFinder() {
        b = new PriorityQueue&lt;&gt;();
        a = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
    }
    
    public void addNum(int num) {
        a.add(num);
        b.add(a.poll());
        if (b.size() &gt; a.size())
            a.add(b.poll());
    }
    
    public double findMedian() {
        if (a.size() == b.size())
            return (a.peek() + b.peek()) / 2.0;
        else
            return a.peek();
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_856-括号的分数" tabindex="-1"><a class="header-anchor" href="#_856-括号的分数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/score-of-parentheses/" target="_blank" rel="noopener noreferrer">856. 括号的分数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int scoreOfParentheses(String s) {
        var stk = new ArrayDeque&lt;Integer&gt;();
        stk.push(0);
        for (char c : s.toCharArray()) {
            if (c == &#39;(&#39;) stk.push(0);
            else {
                int cur = stk.pop();
                stk.push(stk.pop() + (cur == 0 ? 1 : cur * 2));
            } 
        }
        return stk.peek();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int scoreOfParentheses(String s) {
        int layer = 0, res = 0;
        for (int i = 0; i &lt; s.length(); i ++ )
            if (s.charAt(i) == &#39;(&#39;) layer ++ ;
            else {
                layer -- ;
                if (s.charAt(i - 1) == &#39;(&#39;)
                    res += 1 &lt;&lt; layer;
            }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_32-最长有效括号" tabindex="-1"><a class="header-anchor" href="#_32-最长有效括号" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener noreferrer">32. 最长有效括号<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」
class Solution {
    public int longestValidParentheses(String s) {
        int res = 0;
        ArrayDeque&lt;Integer&gt; stk = new ArrayDeque&lt;&gt;();
        stk.push(-1);
        for (int i = 0, cur = 0; i &lt; s.length(); i ++ ) {
            if (s.charAt(i) == &#39;(&#39;) stk.push(i);
            else {
                stk.pop();
                if (stk.isEmpty())
                    stk.push(i);
                else 
                    res = Math.max(res, i - stk.peek());
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestValidParentheses(String s) {
        int l = 0, r = 0, res = 0;
        for (int i = 0; i &lt; s.length(); i ++ ) {
            if (s.charAt(i) == &#39;(&#39;) l ++ ;
            else r ++ ;
            if (l == r) res = Math.max(res, r * 2);
            else if (r &gt; l) r = l = 0;
        }

        l = r = 0;
        for (int i = s.length() - 1; i &gt;= 0; i -- ) {
            if (s.charAt(i) == &#39;(&#39;) l ++ ;
            else r ++ ;
            if (l == r) res = Math.max(res, r * 2);
            else if (l &gt; r) r = l = 0;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2386-找出数组的第-k-大和" tabindex="-1"><a class="header-anchor" href="#_2386-找出数组的第-k-大和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/" target="_blank" rel="noopener noreferrer">2386. 找出数组的第 K 大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：堆</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long kSum(int[] nums, int k) {
        int n = nums.length;
        var sum = 0L;
        for (int i = 0; i &lt; n; i ++ )
            if (nums[i] &gt;= 0) sum += nums[i];
            else nums[i] = -nums[i];
        var q = new PriorityQueue&lt;long[]&gt;((a, b) -&gt; Long.compare(b[0], a[0]));
        Arrays.sort(nums);
        q.add(new long[]{sum, 0L});
        while ( -- k &gt; 0) {
            var p = q.poll();
            var s = p[0];
            var i = (int) p[1];
            if (i &lt; nums.length) {
                q.add(new long[]{s - nums[i], i + 1});
                if (i &gt; 0) q.add(new long[]{s + nums[i - 1] - nums[i], i + 1});
            }
        }
        return q.peek()[0];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_769-最多能完成排序的块" tabindex="-1"><a class="header-anchor" href="#_769-最多能完成排序的块" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted/" target="_blank" rel="noopener noreferrer">769. 最多能完成排序的块<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxChunksToSorted(int[] arr) {
        int n = arr.length, res = 0;
        for (int i = 0, max = -1; i &lt; n; i ++ ) {
            max = Math.max(max, arr[i]);
            if (max == i) res ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_56-合并区间" tabindex="-1"><a class="header-anchor" href="#_56-合并区间" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener noreferrer">56. 合并区间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法1：排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] merge(int[][] arr) {
        if (arr.length == 0 || arr == null) return arr;
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        Arrays.sort(arr, (a, b) -&gt; a[0] - b[0]);
        int st = arr[0][0], end = arr[0][1];
        for (int i = 1; i &lt; arr.length; i ++ ) {
            int a = arr[i][0], b = arr[i][1];
            //当前区间不能合并
            if (a &gt; end) {
                res.add(new int[]{st, end});
                st = a;
                end = b;
            } else {
                //能合并需要更新有端点
                end = Math.max(end, b);
            }
        }
        res.add(new int[]{st, end});
        return res.toArray(new int[res.size()][2]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法2：BitSet位图</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//运用api
class Solution {
    public int[][] merge(int[][] arr) {
        BitSet bitSet = new BitSet();
        int max = 0;
        for (int[] ss : arr) {
            /*比如[1,4]和[5,6]两个区间在数轴上是不连续的，但在BitSet上却
            是连续的。乘2是为了让它们从BitSet上看也是不连续的*/
            // bitSet.set() 函数 [x,y)
            int temp = ss[1] * 2 + 1;
            bitSet.set(ss[0] * 2, temp, true);
            max = Math.max(max, temp);
        }

        int index = 0, count = 0;
        while (index &lt; max) {
            int start = bitSet.nextSetBit(index);
            int end = bitSet.nextClearBit(start);

            int[] item = {start / 2, (end - 1) / 2};
            arr[count ++ ] = item;
            index = end;
        }

        int[][] ret = new int[count][2];
        for (int i = 0; i &lt; count; i ++ ) {
            ret[i] = arr[i];
        }
        return ret;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//手动实现
class Solution {
    boolean[] bitSet = new boolean[20010];
    //返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。
    public int nextSetBit(int i) {
        while (bitSet[i] == false) i ++ ;
        return i;
    }
    //返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。
    public int nextClearBit(int i) {
        while (bitSet[i] == true) i ++ ;
        return i;
    }
    public int[][] merge(int[][] arr) {
        int max = 0;
        for (int[] ss : arr) {
            int begin = ss[0] * 2;
            int end = ss[1] * 2 + 1;
            for (int i = begin; i &lt; end; i ++ ) bitSet[i] = true;
            max = Math.max(max, end);
        }

        ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        int index = 0;
        //合并区间
        while (index &lt; max) {
            int begin = nextSetBit(index);
            int end = nextClearBit(begin);
 
            res.add(new int[]{begin / 2, (end - 1) / 2};);
            index = end;
        }

        return res.toArray(new int[res.size()][2]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_31-下一个排列" tabindex="-1"><a class="header-anchor" href="#_31-下一个排列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener noreferrer">31. 下一个排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution { 
    public void nextPermutation(int[] nums) {
        int k = nums.length - 1;
        while (k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k -- ;
        if (k == 0) { 
            //不存在下一个排列
            Arrays.sort(nums);
        } else {
            int t = k;
            //找到大于nums[k - 1]的最小值的索引
            while (t &lt; nums.length &amp;&amp; nums[t] &gt; nums[k - 1]) t ++ ;
            //交换以后对剩下的数升序排列
            swap(t - 1, k - 1, nums);
            Arrays.sort(nums, k, nums.length);
        }
    }
    public void swap(int a, int b, int[] nums) {
        int t = nums[a];
        nums[a] = nums[b];
        nums[b] = t;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-66-构建乘积数组" tabindex="-1"><a class="header-anchor" href="#剑指-offer-66-构建乘积数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 66. 构建乘积数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] constructArr(int[] a) {
        int n = a.length;
        int[] ans = new int[n];
        //先乘右边的
        for (int i = 0, cnt = 1; i &lt; n; i ++ ) {
            ans[i] = cnt;
            cnt *= a[i];
        }
        //再乘左边的
        for (int i = n - 1, cnt = 1; i &gt;= 0; i -- ) {
            ans[i] *= cnt;
            cnt *= a[i];
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_581-最短无序连续子数组" tabindex="-1"><a class="header-anchor" href="#_581-最短无序连续子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener noreferrer">581. 最短无序连续子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：排序</strong></p><p>O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span></span></span></span>),O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>)</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findUnsortedSubarray(int[] nums) {
        var n = nums.length;
        var temp = nums.clone();
        Arrays.sort(temp);
        int l = 0, r = n - 1;
        while (l &lt; n &amp;&amp; temp[l] == nums[l]) l ++ ;
        while (l &lt; r &amp;&amp; temp[r] == nums[r]) r -- ;
        return r - l + 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：扫描</strong></p><p>O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>),O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length, l = 0, r = n - 1;
        while (l + 1 &lt; n &amp;&amp; nums[l] &lt;= nums[l + 1]) l ++ ;
        while (r &gt; l &amp;&amp; nums[r - 1] &lt;= nums[r]) r -- ;
        if (l == r) return 0;
        for (int i = l + 1; i &lt; n; i ++ )
            while (l &gt;= 0 &amp;&amp; nums[i] &lt; nums[l])
                l -- ;
        for (int i = r - 1; i &gt;= 0; i -- )
            while (r &lt; n &amp;&amp; nums[i] &gt; nums[r])
                r ++ ;
        return r - l - 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_238-除自身以外数组的乘积" tabindex="-1"><a class="header-anchor" href="#_238-除自身以外数组的乘积" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/product-of-array-except-self/" target="_blank" rel="noopener noreferrer">238. 除自身以外数组的乘积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Arrays.fill(ans, 1);
        int l = 1, r = 1;
        for (int i = 0; i &lt; n; i ++ ) {
            ans[i] *= l;
            l *= nums[i];

            ans[n - i - 1] *= r;
            r *= nums[n - i - 1];
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_399-除法求值" tabindex="-1"><a class="header-anchor" href="#_399-除法求值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/evaluate-division/" target="_blank" rel="noopener noreferrer">399. 除法求值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    //转为多源最短路问题解决a -&gt; b = c, b -&gt; a = 1 / c, a -&gt; c = a -&gt; b * b -&gt; c;
    public double[] calcEquation(List&lt;List&lt;String&gt;&gt; e, double[] val, List&lt;List&lt;String&gt;&gt; qu) {
        Set&lt;String&gt; vers = new HashSet&lt;&gt;();
        Map&lt;String, Map&lt;String, Double&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; e.size(); i ++ ) {
            List&lt;String&gt; list = e.get(i);
            String a = list.get(0), b = list.get(1);
            double c = val[i];
            Map&lt;String, Double&gt; m1 = map.getOrDefault(a, new HashMap&lt;&gt;());
            Map&lt;String, Double&gt; m2 = map.getOrDefault(b, new HashMap&lt;&gt;());
            m1.put(b, c);
            m2.put(a, 1/ c);
            map.put(a, m1);
            map.put(b, m2);
            vers.add(a);
            vers.add(b);
        }
        //弗洛伊德
        for (String k : vers) {
            for (String i : vers) {
                for (String j : vers) {
                    if (map.get(i).containsKey(k) &amp;&amp; map.get(k).containsKey(j)) {
                        map.get(i).put(j, map.get(i).get(k) * map.get(k).get(j));
                    }
                }
            }
        }

        double[] ans = new double[qu.size()];
        for (int i = 0; i &lt; qu.size(); i ++ ) {
            List&lt;String&gt; q = qu.get(i);
            String a = q.get(0), b = q.get(1);
            if (map.containsKey(a) &amp;&amp; map.get(a).containsKey(b)) ans[i] = map.get(a).get(b);
            else ans[i] = -1.0;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-45-把数组排成最小的数" tabindex="-1"><a class="header-anchor" href="#剑指-offer-45-把数组排成最小的数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 45. 把数组排成最小的数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String minNumber(int[] nums) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int num : nums) {
            list.add(String.valueOf(num));
        }
        list.sort((o1, o2) -&gt; (o1 + o2).compareTo(o2 + o1));
        return String.join(&quot;&quot;, list);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-44-数字序列中某一位的数字" tabindex="-1"><a class="header-anchor" href="#剑指-offer-44-数字序列中某一位的数字" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 44. 数字序列中某一位的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    /* 数字范围    数量  位数    占多少位
    1-9        9      1       9
    10-99      90     2       180
    100-999    900    3       2700
    1000-9999  9000   4       36000  ...

    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;
    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002
    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;
    */
    public int findNthDigit(int n) {
        int d = 1;//n所在数字的位数
        long  st = 1;//数字范围开始的第一个数
        long  count = 9;//占多少位
        while (n &gt; count) {
            n -= count;
            d ++ ;
            st *= 10;
            count = d * st * 9;
        }
        long num = st + (n - 1) / d;
        return Long.toString(num).charAt((n - 1) % d) - &#39;0&#39;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_54-螺旋矩阵" tabindex="-1"><a class="header-anchor" href="#_54-螺旋矩阵" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank" rel="noopener noreferrer">54. 螺旋矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; spiralOrder(int[][] g) {
        int[] dx = new int[]{0, 1, 0, -1}, dy = new int[]{1, 0, -1, 0};
        int m = g.length, n = g[0].length;
        boolean[][] st = new boolean[m][n];
        int t = m * n;
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0, x = 0, y = 0, d = 0; i &lt; t; i ++ ) {
            ans.add(g[x][y]);
            st[x][y] = true;
            int a = x + dx[d], b = y + dy[d];
            //检验是否合法，不合法则更新方向，并重新计算下一个位置
            if (a &lt; 0 || a &gt;= m || b &lt; 0 || b &gt;= n || st[a][b]) {
                d ++ ;
                d %= 4;
                a = x + dx[d];
                b = y + dy[d];
            }
            x = a;
            y = b;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_59-螺旋矩阵-ii" tabindex="-1"><a class="header-anchor" href="#_59-螺旋矩阵-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener noreferrer">59. 螺旋矩阵 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] generateMatrix(int n) {
        int[][] ans = new int[n][n];
        int[] dx = new int[]{0, 1, 0, -1}, dy = new int[]{1, 0, -1, 0};
        for (int i = 0, x = 0, y = 0, d = 0; i &lt; n * n; i ++ ) {
            ans[x][y] = i + 1;
            int a = x + dx[d], b = y + dy[d];
            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n || ans[a][b] != 0) {
                d ++ ;
                d %= 4;
                a = x + dx[d];
                b = y + dy[d];
            }
            x = a;
            y = b;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_57-插入区间" tabindex="-1"><a class="header-anchor" href="#_57-插入区间" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/insert-interval/" target="_blank" rel="noopener noreferrer">57. 插入区间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] insert(int[][] arrs, int[] newArr) {
        List&lt;int[]&gt; res = new ArrayList&lt;&gt;();
        boolean has_in = false;
        for (int[] arr : arrs) {
            if (arr[0] &gt; newArr[1]) {
                if (!has_in) {
                    res.add(newArr);
                    has_in = true;
                }
                res.add(arr);
            } else if (arr[1] &lt; newArr[0]) {
                res.add(arr);
            } else {
                newArr[0] = Math.min(newArr[0], arr[0]);
                newArr[1] = Math.max(newArr[1], arr[1]);
            }
        }
        if (!has_in) res.add(newArr);
        return res.toArray(new int[res.size()][2]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_498-对角线遍历" tabindex="-1"><a class="header-anchor" href="#_498-对角线遍历" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/diagonal-traverse/" target="_blank" rel="noopener noreferrer">498. 对角线遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int n = mat.length, m = mat[0].length;
        int[] ans = new int[n * m];
        int idx = 0;
        //以对角线坐标的和枚举
        for (int i = 0; i &lt; n + m - 1; i ++ ) {
            if (i % 2 == 0) {
                for (int j = Math.min(i, n - 1); j &gt;= Math.max(0, 1 - m + i); j -- ) 
                    ans[idx ++ ] = mat[j][i - j];
            } else {
                for (int j = Math.max(0, 1 - m + i); j &lt;= Math.min(i, n - 1); j ++ )
                    ans[idx ++ ] = mat[j][i - j];
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6111-螺旋矩阵-iv" tabindex="-1"><a class="header-anchor" href="#_6111-螺旋矩阵-iv" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/spiral-matrix-iv/" target="_blank" rel="noopener noreferrer">6111. 螺旋矩阵 IV<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] spiralMatrix(int m, int n, ListNode head) {
        int[][] ans = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) Arrays.fill(ans[i], -2);
        int[] dx = new int[]{0, 1, 0, -1}, dy = new int[]{1, 0, -1, 0};
        for (int i = 0, x = 0, y = 0, d = 0; i &lt; m * n; i ++ ) {
            ans[x][y] = head != null ? head.val : -1;
            if (head != null) head = head.next;
            int a = x + dx[d], b = y + dy[d];
            if (a &lt; 0 || a &gt;= m || b &lt; 0 || b &gt;= n || ans[a][b] != -2) {
                d ++ ;
                d %= 4;
                a = x + dx[d];
                b = y + dy[d];
            }
            x = a;
            y = b;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_565-数组嵌套" tabindex="-1"><a class="header-anchor" href="#_565-数组嵌套" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/array-nesting/" target="_blank" rel="noopener noreferrer">565. 数组嵌套<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-左闭右开 ext-左闭右开 line-numbers-mode"><pre class="language-左闭右开"><code>class Solution {
    //每个点出度和入读都是1，采取原地标记
    public int arrayNesting(int[] nums) {
        int ans = 0;
        int n = nums.length;
        for (int i = 0; i &lt; n; i ++ ) {
            if (nums[i] == -1) continue;
            int cur = 0, j = i;
            while (nums[j] != -1) {
                cur ++ ;
                int t = nums[j];
                nums[j] = -1;
                j = t;
            }
            ans = Math.max(ans, cur);
        }
        return ans;
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2420-找到所有好下标" tabindex="-1"><a class="header-anchor" href="#_2420-找到所有好下标" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-all-good-indices/" target="_blank" rel="noopener noreferrer">2420. 找到所有好下标<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递推</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; goodIndices(int[] nums, int k) {
        int n = nums.length;
        var f = new int[n];
        var g = new int[n];
        Arrays.fill(f, 1);Arrays.fill(g, 1);
        for (int i = 1; i &lt; n; i ++ ) 
            if (nums[i] &lt;= nums[i - 1])
                f[i] = f[i - 1] + 1;
        for (int i = n - 1; i &gt; 0; i -- )
            if (nums[i] &gt;= nums[i - 1]) 
                g[i - 1] = g[i] + 1;
        var res = new ArrayList&lt;Integer&gt;();
        for (int i = k; i &lt; n - k; i ++ )
            if (f[i - 1] &gt;= k &amp;&amp; g[i + 1] &gt;= k)
                res.add(i);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_915-分割数组" tabindex="-1"><a class="header-anchor" href="#_915-分割数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/" target="_blank" rel="noopener noreferrer">915. 分割数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">partitionDisjoint</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">var</span> l <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            p <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            l<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            q <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>l<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                res <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">partitionDisjoint</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
        l<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
        p<span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000010</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            p <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            l<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> p
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            q <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
            r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> q
        res <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> l<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>p&#39;y
                <span class="token keyword">return</span> i
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1773-统计匹配检索规则的物品数量" tabindex="-1"><a class="header-anchor" href="#_1773-统计匹配检索规则的物品数量" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-items-matching-a-rule/" target="_blank" rel="noopener noreferrer">1773. 统计匹配检索规则的物品数量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -&gt; int:
        res, idx = 0, 0 if ruleKey[0] == &#39;t&#39; else (1 if ruleKey[0] == &#39;c&#39; else 2)
        return sum(v[idx] == ruleValue for v in items)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="数论" tabindex="-1"><a class="header-anchor" href="#数论" aria-hidden="true">#</a> 数论</h2><h4 id="_319-灯泡开关" tabindex="-1"><a class="header-anchor" href="#_319-灯泡开关" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/bulb-switcher/" target="_blank" rel="noopener noreferrer">319. 灯泡开关<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>数论问题</p><h4 id="_343-整数拆分" tabindex="-1"><a class="header-anchor" href="#_343-整数拆分" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener noreferrer">343. 整数拆分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>数论</p><h4 id="_6168-恰好移动-k-步到达某一位置的方法数目" tabindex="-1"><a class="header-anchor" href="#_6168-恰好移动-k-步到达某一位置的方法数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/" target="_blank" rel="noopener noreferrer">6168. 恰好移动 k 步到达某一位置的方法数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：逆元求组合数</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private int mod = (int)1e9 + 7;
    
    public int qmi(int m, int k, int p) {
        long res = 1l % p, t = m * 1l;
        while (k != 0) {
            if ((k &amp; 1) != 0) res = res * t % p;
            t = t * t % p;
            k &gt;&gt;= 1;
        }
        return (int)res;
    }

    public int numberOfWays(int startPos, int endPos, int k) {
        int m = Math.abs(endPos - startPos);
        if ((m - k) % 2 != 0 || k &lt; m) return 0;
        int r = (k + m) / 2;
        long res = 1;
        for (int i = k; i &gt; k - r; i -- ) 
            res = res * i % mod;
        for (int i = 1; i &lt;= r; i ++ ) {
            res = res * qmi(i, mod - 2, mod) % mod;
        }
        return (int)res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_204-计数质数" tabindex="-1"><a class="header-anchor" href="#_204-计数质数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-primes/" target="_blank" rel="noopener noreferrer">204. 计数质数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int countPrimes(int n) {
        var cnt = 0;
        var st = new boolean[n + 1];
        var primes = new int[n];
        for (int i = 2; i &lt; n; i ++ ) {
            if (!st[i]) primes[cnt ++ ] = i;
            for (int j = 0; primes[j] &lt;= n / i; j ++ ) {
                st[primes[j] * i] = true;
                if (i % primes[j] == 0) break;
            }     
        }
        return cnt;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口" aria-hidden="true">#</a> 滑动窗口</h2><h4 id="_594-最长和谐子序列-1" tabindex="-1"><a class="header-anchor" href="#_594-最长和谐子序列-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener noreferrer">594. 最长和谐子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>Arrays.sort()排序 滑动窗口</p><h4 id="_438-找到字符串中所有字母异位词" tabindex="-1"><a class="header-anchor" href="#_438-找到字符串中所有字母异位词" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener noreferrer">438. 找到字符串中所有字母异位词<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_3-无重复字符的最长子串" tabindex="-1"><a class="header-anchor" href="#_3-无重复字符的最长子串" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreferrer">3. 无重复字符的最长子串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_424-替换后的最长重复字符" tabindex="-1"><a class="header-anchor" href="#_424-替换后的最长重复字符" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener noreferrer">424. 替换后的最长重复字符<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_713-乘积小于-k-的子数组" tabindex="-1"><a class="header-anchor" href="#_713-乘积小于-k-的子数组" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener noreferrer">713. 乘积小于 K 的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_209-长度最小的子数组-1" tabindex="-1"><a class="header-anchor" href="#_209-长度最小的子数组-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">209. 长度最小的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_187-重复的dna序列" tabindex="-1"><a class="header-anchor" href="#_187-重复的dna序列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener noreferrer">187. 重复的DNA序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_220-存在重复元素-iii" tabindex="-1"><a class="header-anchor" href="#_220-存在重复元素-iii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener noreferrer">220. 存在重复元素 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><blockquote><p>TreeSet的用法</p><p>public boolean add(E e)：添加元素</p><p>public boolean addAll(Collection c)：通过集合添加元素</p><p>public E ceiling(E e)：返回大于或等于给定键值的最小键值</p><p>public void clear()：清空集合</p><p>public Object clone()：克隆集合</p><p>public Comparator comparator()：用于在此树映射中维护顺序的比较器，如果使用其键的自然顺序，则为null</p><p>public boolean contains(Object o) ：是否包含这个元素</p><p>public Iterator descendingIterator()：用于按降序迭代元素。</p><p>public E first()：获取首点</p><p>public E floor(E e)：返回小于或等于给定键值的最大键值</p><p>public SortedSet headSet(E toElement)：返回key&lt;=toElement集合</p><p>public NavigableSet headSet(E toElement, boolean inclusive)：返回key&lt;=toElement集合，inclusive=true返回的集合在原set中，会包含自己，否则不会包含</p><p>public E higher(E e)：返回严格大于给定键值的最小键值</p><p>public boolean isEmpty()：判断集合是否为空</p><p>public Iterator iterator() ：迭代输出</p><p>public E last()：获取最后的值</p><p>public E lower(E e)：返回严格小于给定键值的最大键值</p><p>public E pollFirst()：获取第一个值并移除第一个值</p><p>public E pollLast()：获取最后值并移除这个值</p><p>public boolean remove(Object o)：移除元素</p><p>public int size() ：当前set容量</p><p>public Spliterator spliterator() ： 方法用于拆分set元素，并逐个迭代它们。</p><p>public NavigableSet subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)：返回from到to之间的值，fromInclusive和toInclusive代表是否包含当前值</p><p>public SortedSet subSet(E fromElement, E toElement)：返回from到to之间的值，包含from，不包含to，即[左闭右开）</p><p>public SortedSet tailSet(E fromElement)：返回&gt;=fromElement值的集合元素</p></blockquote><h4 id="_395-至少有-k-个重复字符的最长子串" tabindex="-1"><a class="header-anchor" href="#_395-至少有-k-个重复字符的最长子串" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener noreferrer">395. 至少有 K 个重复字符的最长子串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestSubstring(String s, int k) {
        int[] map = new int[26];
        int n = s.length();
        int ans = 0;
        for (int p = 1; p &lt;= 26; p ++ ) {
            Arrays.fill(map, 0);   
            // x 代表 [j, i] 区间所有的字符种类数量；
            // y 代表满足「出现次数不少于 k」的字符种类数量
            for (int i = 0, j = 0, x = 0, y = 0; i &lt; n; i ++ ) {
                int u = s.charAt(i) - &#39;a&#39;;
                map[u] ++;
                // 如果添加到 cnt 之后为 1，说明字符总数 +1
                if (map[u] == 1) x ++ ;
                // 当区间所包含的字符种类数量 tot 超过了当前限定的数量 p，
                //那么我们要删除掉一些字母，即「左指针」右移
                if (map[u] == k) y ++ ;
                while (x &gt; p) {
                    int t = s.charAt(j ++ ) - &#39;a&#39;;
                    map[t] -- ;
                    // 如果添加到 cnt 之后为 0，说明字符总数-1
                    if (map[t] == 0) x --;
                    // 如果添加到 cnt 之后等于 k - 1，说明该字符从达标变为不达标，达标数量 - 1
                    if (map[t] == k - 1) y -- ;
                }
                // 当所有字符都符合要求，更新答案
                if (x == y) ans = Math.max(ans, i - j + 1);
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1695-删除子数组的最大得分" tabindex="-1"><a class="header-anchor" href="#_1695-删除子数组的最大得分" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-erasure-value/" target="_blank" rel="noopener noreferrer">1695. 删除子数组的最大得分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_3-无重复字符的最长子串-1" tabindex="-1"><a class="header-anchor" href="#_3-无重复字符的最长子串-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreferrer">3. 无重复字符的最长子串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_643-子数组最大平均数-i" tabindex="-1"><a class="header-anchor" href="#_643-子数组最大平均数-i" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener noreferrer">643. 子数组最大平均数 I<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1004-最大连续1的个数-iii" tabindex="-1"><a class="header-anchor" href="#_1004-最大连续1的个数-iii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener noreferrer">1004. 最大连续1的个数 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_239-滑动窗口最大值-1" tabindex="-1"><a class="header-anchor" href="#_239-滑动窗口最大值-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener noreferrer">239. 滑动窗口最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1838-最高频元素的频数-1" tabindex="-1"><a class="header-anchor" href="#_1838-最高频元素的频数-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/" target="_blank" rel="noopener noreferrer">1838. 最高频元素的频数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxFrequency(int[] nums, int k) {
        Arrays.sort(nums);
        int res = 0, tem = 0;
        for (int i = 0, j = 0; i &lt; nums.length; i ++ ) {
            while (nums[i] * (i - j) - tem &gt; k) tem -= nums[j ++ ];
            tem += nums[i];
            res = Math.max(res, i - j + 1);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1156-单字符重复子串的最大长度" tabindex="-1"><a class="header-anchor" href="#_1156-单字符重复子串的最大长度" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/swap-for-longest-repeated-character-substring/" target="_blank" rel="noopener noreferrer">1156. 单字符重复子串的最大长度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxRepOpt1(String s) {
        List&lt;Integer&gt;[] p = new List[26];
        Arrays.setAll(p, e -&gt; new ArrayList&lt;&gt;());
        for (int i = 0; i &lt; s.length(); i ++ )
            p[s.charAt(i) - &#39;a&#39;].add(i);
        int res = 0;
        for (List&lt;Integer&gt; q : p) {
            //中间有一个空位
            for (int i = 0, j = 0; i &lt; q.size(); i ++ ) {
                //中间多于一个空间
                while (q.get(i) - q.get(j) &gt; i - j + 1) j ++ ;
                int t = q.get(i) - q.get(j) + 1;
                if (i + 1 &lt; q.size() || j &gt; 0) {
                    res = Math.max(res, t);
                }
            }

            //中间没有空位
            for (int i = 0, j = 0; i &lt; q.size(); i ++ ) {
                while (q.get(i) - q.get(j) &gt; i - j) j ++ ;
                int t = q.get(i) - q.get(j) + 1;
                if (i + 1 &lt; q.size() || j &gt; 0) t ++ ;
                res = Math.max(res, t);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="双指针" tabindex="-1"><a class="header-anchor" href="#双指针" aria-hidden="true">#</a> 双指针</h2><h4 id="_15-三数之和" tabindex="-1"><a class="header-anchor" href="#_15-三数之和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener noreferrer">15. 三数之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：排序 + 双指针</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
        Arrays.sort(nums);
        int n = nums.length;
        for (int i = 0; i &lt; n - 2; i ++ ) {
            //nums[i]如果大于0则三数之和必大于0
            if (nums[i] &gt; 0) break;
            //去重
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;
            for (int j = i + 1, k = n - 1; j &lt; k; j ++ ) {
                List&lt;Integer&gt; tem = new ArrayList&lt;&gt;();
                //去重
                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) continue;
                while (k &gt; j &amp;&amp; nums[i] + nums[j] + nums[k] &gt; 0) k -- ;
                //没有合适的答案
                if (k == j) continue;
                if (nums[i] + nums[j] + nums[k] == 0) {
                    tem.add(nums[i]);tem.add(nums[j]);tem.add(nums[k]);
                    ans.add(tem);
                }
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a></h4><h4 id="_18-四数之和" tabindex="-1"><a class="header-anchor" href="#_18-四数之和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener noreferrer">18. 四数之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1574-删除最短的子数组使剩余数组有序" tabindex="-1"><a class="header-anchor" href="#_1574-删除最短的子数组使剩余数组有序" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" target="_blank" rel="noopener noreferrer">1574. 删除最短的子数组使剩余数组有序<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_75-颜色分类" tabindex="-1"><a class="header-anchor" href="#_75-颜色分类" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sort-colors/" target="_blank" rel="noopener noreferrer">75. 颜色分类<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法1：常规排序</strong></p><p><strong>解法2：三指针排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }
    //j指向0的部分，k指向2的部分
    public void sortColors(int[] nums) {
        for (int i = 0, j = 0, k = nums.length - 1; i &lt;= k; ) {
            if (nums[i] == 2) swap(nums, i ++ , k -- );
            else if (nums[i] == 0) swap(nums, i ++ , j ++ );
            else i ++ ;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a></h4><h4 id="_264-丑数-ii" tabindex="-1"><a class="header-anchor" href="#_264-丑数-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ugly-number-ii/" target="_blank" rel="noopener noreferrer">264. 丑数 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//写法1，容量未固定内存消耗大
class Solution {
    public int nthUglyNumber(int n) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        list.add(1);
        for (int i = 0, j = 0, k = 0; list.size() &lt; n;) {
            int t = Math.min(list.get(i) * 2, Math.min(list.get(j) * 3, list.get(k) * 5));
            list.add(t);
            if (list.get(i) * 2 == t) i ++ ;
            if (list.get(j) * 3 == t) j ++ ;
            if (list.get(k) * 5 == t) k ++ ;
        }
        //for (int i : list) System.out.println(i);
        return list.get(n - 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//三指针多路归并
//写法2固定容量，比写法1的动态扩容内存少一点
//s[i]表示第i + 1个丑数
//idx表示当前正在生成的丑数的下标
class Solution {
    public int nthUglyNumber(int n) {
        int[] s = new int[n];
        s[0] = 1;
        for (int i = 0, j = 0, k = 0, idx = 1; idx &lt; n; idx ++ ) {
            int t = Math.min(s[i] * 2, Math.min(s[j] * 3, s[k] * 5));
            s[idx] = t;
            if (s[i] * 2 == t) i ++ ;
            if (s[j] * 3 == t) j ++ ;
            if (s[k] * 5 == t) k ++ ;
        }
        return s[n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_16-最接近的三数之和" tabindex="-1"><a class="header-anchor" href="#_16-最接近的三数之和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/3sum-closest/" target="_blank" rel="noopener noreferrer">16. 最接近的三数之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int threeSumClosest(int[] nums, int target) {
        int n = nums.length;
        Arrays.sort(nums);
        int ans = nums[0] + nums[1] + nums[n - 1];
        for (int i = 0; i &lt; n; i ++ ) {
            int l = i + 1, r = n - 1;
            while (l &lt; r) {
                int t = nums[i] + nums[l] + nums[r];
                if (Math.abs(t - target) &lt; Math.abs(ans - target)) ans = t;
                if (t &lt; target) l ++ ;
                else if (t &gt; target) r --;
                else return t;     
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_209-长度最小的子数组-2" tabindex="-1"><a class="header-anchor" href="#_209-长度最小的子数组-2" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">209. 长度最小的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int ans = Integer.MAX_VALUE;
        int n = nums.length;
        for (int i = 0, j = 0, count = 0; i &lt; n; i ++ ) {
            count += nums[i];
            while (count &gt;= target) {
                ans = Math.min(i - j + 1, ans);
                count -= nums[j ++ ];
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1498-满足条件的子序列数目-1" tabindex="-1"><a class="header-anchor" href="#_1498-满足条件的子序列数目-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/" target="_blank" rel="noopener noreferrer">1498. 满足条件的子序列数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int numSubseq(int[] nums, int target) {
        int mod = (int)1e9 + 7;
        int n = nums.length;
        int[] f = new int[n];
        //预处理2的n次方
        for (int i = 0; i &lt; n; i ++ ) {
            if (i == 0) f[i] = 1;
            else f[i] = (f[i - 1] &lt;&lt; 1) % mod;
        }
        long ans = 0;
        Arrays.sort(nums);
        // 2. 双指针i和j表示最小元素和最大元素下标
        // 例如j为1，i为5，则j的右边有5-1=4个元素，以j为最小元素的子序列，就是这4个元素的子集，共有2的4次方个
        for (int i = n - 1, j = 0; i &gt;= j;) {
            if (nums[i] + nums[j] &gt; target) i -- ;
            else {
                ans = (ans + f[i - j]) % mod;
                j ++ ;
            }
        }
        return (int) ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6117-坐上公交的最晚时间" tabindex="-1"><a class="header-anchor" href="#_6117-坐上公交的最晚时间" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/" target="_blank" rel="noopener noreferrer">6117. 坐上公交的最晚时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        int n = buses.length, m = passengers.length;
        Arrays.sort(buses);
        Arrays.sort(passengers);
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (int x : passengers) s.add(x);
        int ans = 0;
        //双指针模拟上车 i 表示车， j 表示乘客
        for(int i = 0, j = 0; i &lt; buses.length; i ++) {
            int cur = 0;
            while(cur &lt; capacity &amp;&amp; j &lt; passengers.length &amp;&amp; passengers[j] &lt;= buses[i]) {  
                // 如果车 i 还有位置
                if (!s.contains(passengers[j] - 1) &amp;&amp; passengers[j] - 1 &lt;= buses[i]) {  
                    // 如果可以在某乘客前上车(passengers[j] - 1)
                    ans = Math.max(ans, passengers[j] - 1);
                }
                j ++ ;
                cur ++ ;
            }
            // 是否可以卡点上车(车来了再上车)
            if (cur &lt; capacity &amp;&amp; !s.contains(buses[i])){
                ans = Math.max(ans, buses[i]);
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_777-在lr字符串中交换相邻字符" tabindex="-1"><a class="header-anchor" href="#_777-在lr字符串中交换相邻字符" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/swap-adjacent-in-lr-string/" target="_blank" rel="noopener noreferrer">777. 在LR字符串中交换相邻字符<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean canTransform(String start, String end) {
        char[] a = start.toCharArray(), b = end.toCharArray();
        int n = a.length;
        int j = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            if (a[i] == &#39;X&#39;) continue;
            while (j &lt; n &amp;&amp; b[j] == &#39;X&#39;) j ++ ;
            if (j == n) return false;
            if (a[i] != b[j]) return false;
            if (a[i] == &#39;L&#39; &amp;&amp; i &lt; j) return false;
            if (a[i] == &#39;R&#39; &amp;&amp; i &gt; j) return false;
            j ++ ;
        }
        for (int i = j; i &lt; n; i ++ ) 
            if (b[i] != &#39;X&#39;) 
                return false;
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="图论" tabindex="-1"><a class="header-anchor" href="#图论" aria-hidden="true">#</a> 图论</h2><h4 id="面试题-08-10-颜色填充" tabindex="-1"><a class="header-anchor" href="#面试题-08-10-颜色填充" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/color-fill-lcci/" target="_blank" rel="noopener noreferrer">面试题 08.10. 颜色填充<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1034-边界着色" tabindex="-1"><a class="header-anchor" href="#_1034-边界着色" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/coloring-a-border/" target="_blank" rel="noopener noreferrer">1034. 边界着色<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h2 id="dp" tabindex="-1"><a class="header-anchor" href="#dp" aria-hidden="true">#</a> DP</h2><h4 id="_70-爬楼梯" tabindex="-1"><a class="header-anchor" href="#_70-爬楼梯" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener noreferrer">70. 爬楼梯<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i &lt;= n; i ++ ) {
            //要么从上个位置转移过来，要么从上上个位置转移过来
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        return dp[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_64-最小路径和" tabindex="-1"><a class="header-anchor" href="#_64-最小路径和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener noreferrer">64. 最小路径和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minPathSum(int[][] g) {
        int n = g.length, m = g[0].length;
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                if (i == 0 &amp;&amp; j == 0) continue;
                else if (i == 0) g[i][j] += g[i][j - 1];
                else if (j == 0) g[i][j] += g[i - 1][j];
                else g[i][j] += Math.min(g[i][j - 1], g[i - 1][j]);
            }
        }
        return g[n - 1][m - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_62-不同路径" tabindex="-1"><a class="header-anchor" href="#_62-不同路径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener noreferrer">62. 不同路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) {
            for (int j = 0; j &lt; n; j ++ ) {
                if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;
                else {
                    if (i &gt; 0) dp[i][j] = dp[i][j] + dp[i - 1][j];
                    if (j &gt; 0) dp[i][j] = dp[i][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_63-不同路径-ii" tabindex="-1"><a class="header-anchor" href="#_63-不同路径-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener noreferrer">63. 不同路径 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int uniquePathsWithObstacles(int[][] g) {
        int m = g.length, n = g[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) {
            for (int j = 0; j &lt; n; j ++ ) {
                if (g[i][j] == 0) {
                    if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;
                    else {
                        if (i &gt; 0) dp[i][j] = dp[i][j] + dp[i - 1][j];
                        if (j &gt; 0) dp[i][j] = dp[i][j] + dp[i][j - 1];
                    }
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_338-比特位计数" tabindex="-1"><a class="header-anchor" href="#_338-比特位计数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener noreferrer">338. 比特位计数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="剑指-offer-46-把数字翻译成字符串" tabindex="-1"><a class="header-anchor" href="#剑指-offer-46-把数字翻译成字符串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 46. 把数字翻译成字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int translateNum(int num) {
        String str = String.valueOf(num);
        int n = str.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i &lt;= n; i ++ ) {
            String sub = str.substring(i - 2, i);
            if (sub.compareTo(&quot;10&quot;) &gt;= 0 &amp;&amp; sub.compareTo(&quot;25&quot;) &lt;= 0) {
                dp[i] = dp[i - 1] + dp[i - 2];
            } else {
                //不能从下面两格转移上来
                dp[i] = dp[i - 1];
            }
        }
        return dp[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_62-不同路径-1" tabindex="-1"><a class="header-anchor" href="#_62-不同路径-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener noreferrer">62. 不同路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) {
            for (int j = 0; j &lt; n; j ++ ) {
                if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;
                else {
                    if (i &gt; 0) dp[i][j] = dp[i][j] + dp[i - 1][j];
                    if (j &gt; 0) dp[i][j] = dp[i][j] + dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_63-不同路径-ii-1" tabindex="-1"><a class="header-anchor" href="#_63-不同路径-ii-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener noreferrer">63. 不同路径 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int uniquePathsWithObstacles(int[][] g) {
        int m = g.length, n = g[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) {
            for (int j = 0; j &lt; n; j ++ ) {
                if (g[i][j] == 0) {
                    if (i == 0 &amp;&amp; j == 0) dp[i][j] = 1;
                    else {
                        if (i &gt; 0) dp[i][j] = dp[i][j] + dp[i - 1][j];
                        if (j &gt; 0) dp[i][j] = dp[i][j] + dp[i][j - 1];
                    }
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_198-打家劫舍" tabindex="-1"><a class="header-anchor" href="#_198-打家劫舍" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener noreferrer">198. 打家劫舍<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(dp[0], nums[1]);
        for (int i = 2; i &lt; n; i ++ ) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_213-打家劫舍-ii" tabindex="-1"><a class="header-anchor" href="#_213-打家劫舍-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener noreferrer">213. 打家劫舍 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];
        int res = 0;
        //记录偷第一个
        int[] dp1 = new int[n];
        //记录不偷第一个
        int[] dp2 = new int[n];
        dp1[0] = nums[0];
        dp1[1] = Math.max(nums[0], nums[1]);
        dp2[0] = 0;
        dp2[1] = nums[1];
        for (int i = 2; i &lt; n; i ++ ) {
            if (i == n - 1) {
                //偷了第一个就不能偷最后一个
                dp1[i] = dp1[i - 1];
                dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i]);
            } else {
                dp1[i] = Math.max(dp1[i - 1], dp1[i - 2] + nums[i]);
                dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i]);
            }
        }
        return Math.max(dp1[n - 1], dp2[n - 1]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_337-打家劫舍-iii" tabindex="-1"><a class="header-anchor" href="#_337-打家劫舍-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener noreferrer">337. 打家劫舍 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//树形dp
/*我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷
任何一个节点能偷到的最大钱的状态可以定义为
当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数
root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
*/
class Solution {
    public int rob(TreeNode root) {
        int[] f = dfs(root);
        return Math.max(f[0], f[1]);
    }
    public int[] dfs(TreeNode root) {
        if (root == null) return new int[]{0, 0};
        int[] res = new int[2];
        int[] l = dfs(root.left);
        int[] r = dfs(root.right);

        res[0] = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        res[1] = l[0] + r[0] + root.val;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_300-最长递增子序列" tabindex="-1"><a class="header-anchor" href="#_300-最长递增子序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener noreferrer">300. 最长递增子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//O(n * n)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int ans = 1;
        //dp[i]表示以nums[i]结尾的最长递增子序列的长度
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; i; j ++ ) {
                if (nums[j] &lt; nums[i])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//O(n * logn)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        //dp[i]表示最长子序列长度为i时的最小的结尾num值
        int[] dp = new int[n + 1];
        dp[1] = nums[0];
        int res = 1;
        for (int i = 1; i &lt; n; i ++ ) {
            int l = 0, r = res;
            while (l &lt; r) {
                int mid = l + r + 1 &gt;&gt; 1;
                if (dp[mid] &lt; nums[i]) l = mid;
                else r = mid - 1;
            }
            dp[r + 1] = nums[i];
            res = Math.max(res, r + 1);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_152-乘积最大子数组" tabindex="-1"><a class="header-anchor" href="#_152-乘积最大子数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-product-subarray/" target="_blank" rel="noopener noreferrer">152. 乘积最大子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxProduct(int[] nums) {
        int res = nums[0];
        int f = nums[0], g = nums[0];
        for (int i = 1; i &lt; nums.length; i ++ ) {
            int a = nums[i], fa = a * f, ga = a * g;
            f = Math.max(a, Math.max(fa, ga));
            g = Math.min(a, Math.min(fa, ga));
            res = Math.max(res, f);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_139-单词拆分" tabindex="-1"><a class="header-anchor" href="#_139-单词拆分" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener noreferrer">139. 单词拆分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean wordBreak(String s, List&lt;String&gt; wordDict) {
        int n = s.length();
        //dp[i]表示字符串s的前i个字符能否拆分成wordDict
        boolean[] dp = new boolean[n + 1];
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        dp[0] = true;
        for (String word : wordDict) set.add(word);
        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 0; j &lt; i; j ++ ) {
                if (dp[j] &amp;&amp; set.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-42-连续子数组的最大和" tabindex="-1"><a class="header-anchor" href="#剑指-offer-42-连续子数组的最大和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 42. 连续子数组的最大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxSubArray(int[] nums) {
        int f = -101;
        int ans = -101;
        for (int i : nums) {
            f = Math.max(i, f + i);
            ans = Math.max(f, ans);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_53-最大子数组和" tabindex="-1"><a class="header-anchor" href="#_53-最大子数组和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener noreferrer">53. 最大子数组和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE;
        for (int i = 0, last = 0; i &lt; nums.length; i ++ ) {
            last = nums[i] + Math.max(last, 0);
            ans = Math.max(ans, last);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1359-有效的快递序列数目" tabindex="-1"><a class="header-anchor" href="#_1359-有效的快递序列数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/" target="_blank" rel="noopener noreferrer">1359. 有效的快递序列数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    static final int MOD = (int)1e9 + 7;
    public int countOrders(int n) {
        long[] f = new long[n + 1];
        f[1] = 1;
        for (int i = 2; i &lt;= n; i ++ ) {
            long x = 2l * i - 1;
            f[i] = (x * x + x) / 2 * f[i - 1];
            f[i] %= MOD;
        }
        return (int)f[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优化空间</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    static final int MOD = (int)1e9 + 7;
    public int countOrders(int n) {
        long res = 1;
        for (int i = 2; i &lt;= n; i ++ ) {
            res *= i * (2 * i - 1l);
            res %= MOD;
        }
        return (int)res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1143-最长公共子序列" tabindex="-1"><a class="header-anchor" href="#_1143-最长公共子序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener noreferrer">1143. 最长公共子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestCommonSubsequence(String a, String b) {
        int n = a.length(), m = b.length();
        //f[i][j]表示第一个字符串的前i个字符和第二个字符串的前j个字符的最长公共子序列
        int[][] f = new int[n + 1][m + 1];
        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 1; j &lt;= m; j ++ ) {
                f[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);
                if (a.charAt(i - 1) == b.charAt(j - 1))
                    f[i][j] = Math.max(f[i][j], f[i - 1][j - 1] + 1);
            }
        }
        return f[n][m];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_322-零钱兑换" tabindex="-1"><a class="header-anchor" href="#_322-零钱兑换" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener noreferrer">322. 零钱兑换<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：记忆化搜索</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] map;
    public int coinChange(int[] coins, int amount) {
        if (amount == 0) return 0;
        map = new int[amount + 1];
        return dfs(coins, amount);
    }

    public int dfs(int[] coins, int rem) {
        if (rem &lt; 0) return -1;
        if (rem == 0) return 0;
        if (map[rem] != 0) return map[rem];
        int min = Integer.MAX_VALUE;
        for (int x : coins) {
            int res = dfs(coins, rem - x);
            if (res &gt;= 0 &amp;&amp; res &lt; min)
                min = res + 1;
        }
        return map[rem] = min == Integer.MAX_VALUE ? -1 : min;
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：动态规划</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int coinChange(int[] coins, int m) {
        int[] f = new int[m + 1];
        Arrays.fill(f, 10010);
        f[0] = 0; 
        for (int v : coins)
            for (int j = v; j &lt;= m; j ++ )
                f[j] = Math.min(f[j - v] + 1, f[j]);
        return f[m] == 10010 ? -1 : f[m];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_940-不同的子序列-ii" tabindex="-1"><a class="header-anchor" href="#_940-不同的子序列-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/distinct-subsequences-ii/" target="_blank" rel="noopener noreferrer">940. 不同的子序列 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：序列dp</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int distinctSubseqII(String s) {
        int mod = (int) 1e9 + 7;
        var n = s.length();
        //f[i][j]表示前i个字符j结尾的个数
        var f = new int[n + 1][26];
        for (int i = 1; i &lt;= n; i ++ ) {
            int c = s.charAt(i - 1) - &#39;a&#39;;
            for (int j = 0; j &lt; 26; j ++ ) {
                if (c != j) {
                    f[i][j] = f[i - 1][j];
                } else {
                    int cur = 1;
                    for (int k = 0; k &lt; 26; k ++ )
                        cur = (cur + f[i - 1][k]) % mod;
                    f[i][j] = cur;
                }
            }
        }
        var res = 0;
        for (int i = 0; i &lt; 26; i ++ ) res = (res + f[n][i]) % mod;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优化</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int distinctSubseqII(String s) {
        int mod = (int) 1e9 + 7;
        var n = s.length();
        var f = new int[26];
        var res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            var c = s.charAt(i) - &#39;a&#39;;
            //总数中不包含f[c]的个数，避免重复
            var other = res - f[c];
            f[c] = res + 1;
            res = ((f[c] + other) % mod + mod) % mod;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1235-规划兼职工作" tabindex="-1"><a class="header-anchor" href="#_1235-规划兼职工作" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-profit-in-job-scheduling/" target="_blank" rel="noopener noreferrer">1235. 规划兼职工作<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：序列DP&amp;二分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        var job = new ArrayList&lt;int[]&gt;();
        var n = startTime.length;
        // f[i]为考虑前 i 个工作，所能取得的最大收益
        var f = new int[n + 10];
        for (var i = 0; i &lt; n; i ++ )
            job.add(new int[]{startTime[i], endTime[i], profit[i]});
        Collections.sort(job, (a, b) -&gt; a[1] - b[1]);
        for (int i = 1; i &lt;= n; i ++ ) {
            var info = job.get(i - 1);
            int a = info[0], b = info[1], c = info[2];
            f[i] = Math.max(f[i - 1], c);
            int l = 0, r = i - 1;
            while (l &lt; r) {
                var mid = l + r + 1 &gt;&gt; 1;
                if (job.get(mid)[1] &lt;= a) l = mid;
                else r = mid - 1; 
            }
            if (job.get(l)[1] &lt;= a) f[i] = Math.max(f[i], f[l + 1] + c);
        }
        return f[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bfs" tabindex="-1"><a class="header-anchor" href="#bfs" aria-hidden="true">#</a> BFS</h2><h4 id="_127-单词接龙" tabindex="-1"><a class="header-anchor" href="#_127-单词接龙" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener noreferrer">127. 单词接龙<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：BFS</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int ladderLength(String start, String end, List&lt;String&gt; bank) {
        var set = new HashSet&lt;String&gt;();
        var map = new HashMap&lt;String, Integer&gt;();
        var q = new ArrayDeque&lt;String&gt;();
        for (String x : bank) set.add(x);
        map.put(start, 0);
        q.add(start);
        while (!q.isEmpty()) {
            var s = q.poll();
            var cs = s.toCharArray();
            var step = map.get(s);
            for (int i = 0; i &lt; cs.length; i ++ ) {
                for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c ++ ) {
                    if (c == cs[i]) continue;
                    var t = cs[i];
                    cs[i] = c;
                    var sub = new String(cs);
                    if (set.contains(sub) &amp;&amp; !map.containsKey(sub)) {
                        map.put(sub, step + 1);
                        if (end.equals(sub))
                            return map.get(sub) + 1;
                        q.add(sub);
                    }
                    cs[i] = t;
                }
            }
        }
        return 0;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>朴素的 BFS 可能会带来「搜索空间爆炸」的情况。</p><p>想象一下，如果我们的 wordList 足够丰富（包含了所有单词），对于一个长度为 10 的 beginWord 替换一次字符可以产生 10 * 25 个新单词（每个替换点可以替换另外 25 个小写字母），第一层就会产生 250 个单词；第二层会产生超过 6 * 10^4 个新单词 ...</p><p>随着层数的加深，这个数字的增速越快，这就是「搜索空间爆炸」问题。</p><p><strong>在朴素的 BFS 实现中，空间的瓶颈主要取决于搜索空间中的最大宽度。</strong></p><p>「双向 BFS」 可以很好的解决这个问题：</p><p><strong>同时从两个方向开始搜索，一旦搜索到相同的值，意味着找到了一条联通起点和终点的最短路径。</strong></p><p>「双向 BFS」的基本实现思路如下：</p><p>1、创建「两个队列」分别用于两个方向的搜索； 2、创建「两个哈希表」用于「解决相同节点重复搜索」和「记录转换次数」； 3、为了尽可能让两个搜索方向“平均”，每次从队列中取值进行扩展时，先判断哪个队列容量较少； 4、如果在搜索过程中「搜索到对方搜索过的节点」，说明找到了最短路径。</p><p>「双向 BFS」基本思路对应的伪代码大致如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>d1、d2 为两个方向的队列
m1、m2 为两个方向的哈希表，记录每个节点距离起点的
    
// 只有两个队列都不空，才有必要继续往下搜索
// 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
while(!d1.isEmpty() &amp;&amp; !d2.isEmpty()) {
    if (d1.size() &lt;= d2.size()) {
        update(d1, m1, m2);
    } else {
        update(d2, m2, m1);
    }
}

// update 为将当前队列 d 中包含的元素取出，进行「一次完整扩展」的逻辑（按层拓展）
void update(Deque d, Map cur, Map other) {}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：双向BFS</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Set&lt;String&gt; set;
    public int bfs(ArrayDeque&lt;String&gt; q, Map&lt;String, Integer&gt; m1, Map&lt;String, Integer&gt; m2) {
        var size = q.size();
        while (size -- &gt; 0) {
            var s = q.poll();
            var cs = s.toCharArray();
            var step = m1.get(s);
            for (int i = 0; i &lt; cs.length; i ++ ) {
                for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c ++ ) {
                    if (c == cs[i]) continue;
                    var t = cs[i];
                    cs[i] = c;
                    var sub = new String(cs);
                    if (set.contains(sub) &amp;&amp; !m1.containsKey(sub)) {
                        if (m2.containsKey(sub))
                            return step + 1 + m2.get(sub);
                        else {
                            m1.put(sub, step + 1);
                            q.add(sub);
                        }
                    }
                    cs[i] = t;
                }
            }
        }
        return -1;
    }

    public int ladderLength(String start, String end, List&lt;String&gt; bank) {
        set = new HashSet&lt;String&gt;();
        var q1 = new ArrayDeque&lt;String&gt;();
        var q2 = new ArrayDeque&lt;String&gt;();
        var m1 = new HashMap&lt;String, Integer&gt;();
        var m2 = new HashMap&lt;String, Integer&gt;();
        for (String x : bank) set.add(x);
        if (!set.contains(end)) return 0;
        m1.put(start, 0); m2.put(end, 0);
        q1.add(start); q2.add(end);
        while (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) {
            var t = -1;
            if (q1.size() &lt;= q2.size()) t = bfs(q1, m1, m2);
            else t = bfs(q2, m2, m1);
            if (t != -1) return t + 1;
        }
        return 0;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_433-最小基因变化" tabindex="-1"><a class="header-anchor" href="#_433-最小基因变化" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener noreferrer">433. 最小基因变化<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>BFS</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minMutation(String start, String end, String[] bank) {
        Set&lt;String&gt; set = new HashSet&lt;&gt;();
        for (String s : bank) set.add(s);
        Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;();
        Queue&lt;String&gt; q = new LinkedList&lt;&gt;();
        char[] item = new char[]{&#39;A&#39;,&#39;C&#39;,&#39;G&#39;,&#39;T&#39;};
        q.add(start);
        map.put(start, 0);
        while (!q.isEmpty()) {
            int size = q.size();
            while (size -- &gt; 0) {
                String s = q.poll();
                char[] cs = s.toCharArray();
                int step = map.get(s);
                for (int i = 0; i &lt; 8; i ++ ) {
                    for (char c : item) {
                        if (c == cs[i]) continue;
                        char[] st = cs.clone();
                        st[i] = c;
                        String sub = String.valueOf(st);
                        if (!set.contains(sub)) continue;
                        if (map.containsKey(sub)) continue;
                        if (sub.equals(end)) return step + 1;
                        q.add(sub);
                        map.put(sub, step + 1);
                    }
                }
            }
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>双向BFS</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Set&lt;String&gt; set = new HashSet&lt;&gt;();
    char[] item = new char[]{&#39;A&#39;,&#39;C&#39;,&#39;G&#39;,&#39;T&#39;};
    public int minMutation(String s, String e, String[] bank) {
        for (String t : bank) set.add(t);
        Queue&lt;String&gt; q1 = new LinkedList&lt;&gt;(), q2 = new LinkedList&lt;&gt;();
        Map&lt;String, Integer&gt; m1 = new HashMap&lt;&gt;(), m2 = new HashMap&lt;&gt;();
        q1.add(s);
        q2.add(e);
        m1.put(s, 0);
        m2.put(e,0); 
        int ans = -1;
        while (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) {
            int t = -1;
            if (q1.size() &lt;= q2.size()) {
                t = update(q1, m1, m2);
            } else {
                t = update(q2, m2, m1);
            }
            if (t != -1) ans = t;
        }
        return ans;
    }
    public int update(Queue&lt;String&gt; q, Map&lt;String, Integer&gt; cur, Map&lt;String, Integer&gt; other) {
        int size = q.size();
        while (size -- &gt; 0) {
            String s = q.poll();
            char[] cs = s.toCharArray();
            for (int i = 0; i &lt; 8; i ++ ) {
                for (char c : item) {
                    char[] ss = cs.clone();
                    ss[i] = c;
                    String sub = String.valueOf(ss);
                    if (set.contains(sub) &amp;&amp; !cur.containsKey(sub)) {
                        if (other.containsKey(sub)) {
                            return cur.get(s) + 1 + other.get(sub);
                        } else {
                            q.add(sub);
                            cur.put(sub, cur.get(s) + 1);
                        }
                    }
                }
            } 
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6081-到达角落需要移除障碍物的最小数目" tabindex="-1"><a class="header-anchor" href="#_6081-到达角落需要移除障碍物的最小数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/" target="_blank" rel="noopener noreferrer">6081. 到达角落需要移除障碍物的最小数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    final static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int minimumObstacles(int[][] g) {
        int m = g.length, n = g[0].length;
        int[][] dis = new int[m][n];
        for (int[] d : dis) Arrays.fill(d, Integer.MAX_VALUE);
        dis[0][0] = 0;
        Deque&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        q.addFirst(new int[]{0, 0});
        while (!q.isEmpty()) {
            int[] p = q.poll();
            int x = p[0], y = p[1];
            for (int[] d : dirs) {
                int nx = d[0] + x, ny = d[1] + y;
                if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n) {
                    int t = g[nx][ny];
                    if (dis[x][y] + t &lt; dis[nx][ny]) {
                        dis[nx][ny] = dis[x][y] + t;
                        if (t == 0) q.addFirst(new int[]{nx, ny});
                        else q.addLast(new int[]{nx, ny});
                    }
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}class Solution {
    final static int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int minimumObstacles(int[][] g) {
        int m = g.length, n = g[0].length;
        int[][] dis = new int[m][n];
        for (int[] d : dis) Arrays.fill(d, Integer.MAX_VALUE);
        dis[0][0] = 0;
        Deque&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        q.addFirst(new int[]{0, 0});
        while (!q.isEmpty()) {
            int[] p = q.poll();
            int x = p[0], y = p[1];
            for (int[] d : dirs) {
                int nx = d[0] + x, ny = d[1] + y;
                if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n) {
                    int t = g[nx][ny];
                    if (dis[x][y] + t &lt; dis[nx][ny]) {
                        dis[nx][ny] = dis[x][y] + t;
                        //优先走短路，利用双端队列的性质极大地优化了时间复杂度
                        if (t == 0) q.addFirst(new int[]{nx, ny});
                        else q.addLast(new int[]{nx, ny});
                    }
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_116-填充每个节点的下一个右侧节点指针" tabindex="-1"><a class="header-anchor" href="#_116-填充每个节点的下一个右侧节点指针" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener noreferrer">116. 填充每个节点的下一个右侧节点指针<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Node last = root;
        while (last.left != null) {
            for (Node p = last; p != null; p = p.next) {
                p.left.next = p.right;
                if (p.next != null) p.right.next = p.next.left;
            }
            //从下一层的左边遍历
            last = last.left;
        }
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_117-填充每个节点的下一个右侧节点指针-ii" tabindex="-1"><a class="header-anchor" href="#_117-填充每个节点的下一个右侧节点指针-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener noreferrer">117. 填充每个节点的下一个右侧节点指针 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Node cur = root;
        while (cur != null) {
        	//维护当前层的时候将下一层next的关系建出来
            Node dummy = new Node(-1);
            Node tail = dummy;
            for (Node p = cur; p != null; p = p.next) {
                if (p.left != null) tail = tail.next = p.left;
                if (p.right != null) tail = tail.next = p.right;
            }
            cur = dummy.next;
        }
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_690-员工的重要性" tabindex="-1"><a class="header-anchor" href="#_690-员工的重要性" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/employee-importance/" target="_blank" rel="noopener noreferrer">690. 员工的重要性<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for Employee.
class Employee {
    public int id;
    public int importance;
    public List&lt;Integer&gt; subordinates;
};
*/

class Solution {
    public int getImportance(List&lt;Employee&gt; employees, int id) {
        int ans = 0;
        Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;();
        for (Employee e : employees) map.put(e.id, e);
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(id);
        while (!q.isEmpty()) {
            int t = q.size();
            while (t -- &gt; 0) {
                int i = q.poll();
                Employee e = map.get(i);
                ans += e.importance;
                List&lt;Integer&gt; list = e.subordinates;
                for (int p : list) q.add(p);
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="acwing3675-逃离迷宫" tabindex="-1"><a class="header-anchor" href="#acwing3675-逃离迷宫" aria-hidden="true">#</a> <a href="https://www.acwing.com/problem/content/description/3678/" target="_blank" rel="noopener noreferrer">AcWing3675.逃离迷宫<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>import java.util.*;
import java.io.*;
public class Main {
    private int N = 110;
    private int k ,x1 , y1, x2, y2;
    private char[][] g;
    private boolean[][] st;
    private final int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    
    
    public void solve(InputReader in, PrintWriter out) {
        g = new char[N][N];
        st = new boolean[N][N];
        int t = in.nextInt();
        out : for (int i = 0; i &lt; t; i ++ ) {
            int m = in.nextInt(), n = in.nextInt();
            for (int j = 0; j &lt; m; j ++ )
                    g[j] = in.next().toCharArray();
            k = in.nextInt();
            y1 = in.nextInt() - 1;
            x1 = in.nextInt() - 1;
            y2 = in.nextInt() - 1;
            x2 = in.nextInt() - 1;
            for (int j = 0; j &lt; N; j ++ ) Arrays.fill(st[j], false);
            //只入队转弯的点
            ArrayDeque&lt;Node&gt; q = new ArrayDeque&lt;&gt;();
            q.add(new Node(x1, y1, -1));
            Node p, next = new Node(), temp = new Node();
            while (!q.isEmpty()) {
                p = q.poll();
                //System.out.println(p.x+&quot;:&quot;+p.y);
                if (p.x == x2 &amp;&amp; p.y == y2 &amp;&amp; p.s &lt;= k) {
                    //System.out.println(&quot;yes&quot;);
                    out.println(&quot;yes&quot;);
                    continue out;
                }
                for (int[] d : dirs) {
                    next.x = p.x + d[0];
                    next.y = p.y + d[1];
                    while (next.x &gt;= 0 &amp;&amp; next.x &lt; m &amp;&amp; next.y &gt;=0 &amp;&amp; next.y &lt; n &amp;&amp; g[next.x][next.y] == &#39;.&#39;) {
                        if (!st[next.x][next.y]) {
                            next.s = p.s + 1;
                            st[next.x][next.y] = true;
                            q.add(new Node(next));
                        }
                        //往一个方向走
                        temp.x = next.x + d[0];
                        temp.y = next.y + d[1];
                        next = temp;
                    }
                }
            }
            //System.out.println(&quot;no&quot;);
            out.println(&quot;no&quot;);
        }
        out.close();
    }
    
    public static void main(String[] args) throws IOException {
        new Main().solve(new InputReader(System.in), new PrintWriter(System.out));
    }
    
    public static class Node {
        int x, y, s;
        public Node() {}
        public Node(int x, int y, int s) {
            this.x = x;
            this.y = y;
            this.s = s;
        }
        public Node(Node node) {
            this.x = node.x;
            this.y = node.y;
            this.s = node.s;
        }
    }
}
//手写快读类
class InputReader {
    private final BufferedReader reader;
    private StringTokenizer tokenizer;

    public InputReader(InputStream stream) {
        reader = new BufferedReader(new InputStreamReader(stream), 32768);
        tokenizer = null;
    }

    public String next() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            try {
                tokenizer = new StringTokenizer(reader.readLine());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        return tokenizer.nextToken();
    }

    public String nextLine() {
        String str;
        try {
            str = reader.readLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return str;
    }

    public boolean hasNext() {
        while (tokenizer == null || !tokenizer.hasMoreTokens()) {
            String nextLine;
            try {
                nextLine = reader.readLine();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            if (nextLine == null) {
                return false;
            }
            tokenizer = new StringTokenizer(nextLine);
        }
        return true;
    }

    public int nextInt() {
        return Integer.parseInt(next());
    }

    public long nextLong() {
        return Long.parseLong(next());
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1345-跳跃游戏-iv" tabindex="-1"><a class="header-anchor" href="#_1345-跳跃游戏-iv" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/jump-game-iv/" target="_blank" rel="noopener noreferrer">1345. 跳跃游戏 IV<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minJumps(int[] arr) {
        int n = arr.length;
        if (n == 1) return 0;
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = n - 1; i &gt;= 0; i -- ) {
            int x = arr[i];
            if (!map.containsKey(x)) map.put(x, new LinkedList&lt;&gt;());
            map.get(x).add(i); 
        }
        boolean[] st = new boolean[n];
        //存下标&amp;步数
        ArrayDeque&lt;int[]&gt; q = new ArrayDeque&lt;&gt;();
        st[0] = true;
        q.add(new int[]{0, 0});
        while (!q.isEmpty()) {
            int a = q.peek()[0], b = q.peek()[1];
            q.poll();
            //System.out.println(a + &quot;:&quot; + b);
            if (a + 1 == n - 1) return b + 1;
            if (!st[a + 1]) {
                st[a + 1] = true;
                q.add(new int[]{a + 1, b + 1});
            } 
            if (a &gt; 0 &amp;&amp; !st[a - 1]) {
                st[a - 1] = true;
                q.add(new int[]{a - 1, b + 1});
            }
            if (map.containsKey(arr[a])) {
                for (int x : map.get(arr[a])) {
                    if (x != a &amp;&amp; !st[x]) {
                        if (x == n - 1) return b + 1;
                        st[x] = true;
                        q.add(new int[]{x, b + 1});
                    }
                }
                map.remove(arr[a]);
            }
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_785-判断二分图" tabindex="-1"><a class="header-anchor" href="#_785-判断二分图" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/is-graph-bipartite/" target="_blank" rel="noopener noreferrer">785. 判断二分图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean isBipartite(int[][] g) {
        int[] st = new int[g.length];
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; g.length; i ++ ) {
            if (st[i] != 0) continue;
            q.add(i);
            st[i] = 1;
            while (!q.isEmpty()) {
                int x = q.poll();
                for (int v : g[x]) {
                    if (st[v] == st[x]) return false;
                    if (st[v] == 0) {
                        st[v] = -st[x];
                        q.add(v);
                    }
                }
            }
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_854-相似度为-k-的字符串" tabindex="-1"><a class="header-anchor" href="#_854-相似度为-k-的字符串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/k-similar-strings/" target="_blank" rel="noopener noreferrer">854. 相似度为 K 的字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int kSimilarity(String s1, String s2) {
        int n = s1.length();
        char[] c = s2.toCharArray();
        var map = new HashMap&lt;String, Integer&gt;();
        var q = new ArrayDeque&lt;String&gt;();
        q.add(s1);
        map.put(s1, 0);
        while (!q.isEmpty()) {
            var s = q.poll();
            char[] t = s.toCharArray();
            for (int i = 0; i &lt; n; i ++ ) {
                if (t[i] != c[i]) {
                    for (int j = i + 1; j &lt; n; j ++ ) {
                        if (t[j] == c[i]) {
                            swap(t, i, j);
                            var p = new String(t);
                            if (p.equals(s2))
                                return map.get(s) + 1;
                            if (!map.containsKey(p)) {
                                map.put(p, map.get(s) + 1);
                                q.add(p);
                            }
                            swap(t, i, j);
                        }
                    }
                    break;
                }
            }
        }
        return 0;
    }
    public void swap(char[] s, int a, int b) {
        char c = s[a];
        s[a] = s[b];
        s[b] = c;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_994-腐烂的橘子" tabindex="-1"><a class="header-anchor" href="#_994-腐烂的橘子" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/rotting-oranges/" target="_blank" rel="noopener noreferrer">994. 腐烂的橘子<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：BFS</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int orangesRotting(int[][] g) {
        int n = g.length, m = g[0].length;
        var q = new ArrayDeque&lt;Pair&lt;Integer, Integer&gt;&gt;();
        int num = 0;
        int[] dx = new int[]{-1, 0, 1, 0}, dy = new int[]{0, 1, 0, -1};
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; m; j ++ )
                if (g[i][j] == 1) 
                    num ++ ;
                else if (g[i][j] == 2) 
                    q.add(new Pair&lt;&gt;(i, j));
        int t = 0;
        while (!q.isEmpty() &amp;&amp; num &gt; 0) {
            t ++ ;
            int size = q.size();
            while (size -- &gt; 0) {
                int x = q.peek().getKey(), y = q.peek().getValue();
                q.poll();
                for (int i = 0; i &lt; 4; i ++ ) {
                    int a = x + dx[i], b = y + dy[i];
                    if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || g[a][b] != 1) continue;
                    g[a][b] = 2;
                    num -- ;
                    q.add(new Pair&lt;&gt;(a, b));
                }
            }
        }
        return num == 0 ? t : -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def orangesRotting(self, g: List[List[int]]) -&gt; int:
        n, m, num = len(g), len(g[0]), 0
        q = collections.deque()
        for i, row in enumerate(g):
            for j, x in enumerate(row):
                if x == 1: num += 1
                elif  x == 2: q.append((i, j))
        t = 0
        while q and num:
            t += 1
            size = len(q)
            while size &gt; 0:
                size -= 1
                x, y = q.popleft()
                for nx, ny in (x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1):
                    if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m and g[nx][ny] == 1:
                        q.append((nx, ny))
                        num -= 1
                        g[nx][ny] = 2
        return t if num == 0 else -1 


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_934-最短的桥" tabindex="-1"><a class="header-anchor" href="#_934-最短的桥" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shortest-bridge/" target="_blank" rel="noopener noreferrer">934. 最短的桥<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：BFS</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    static int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    public int shortestBridge(int[][] g) {
        var n = g.length;
        var q = new ArrayDeque&lt;int[]&gt;();
        var p = new ArrayList&lt;int[]&gt;();
        for (var i = 0; i &lt; n; i ++ ) {
            for (var j = 0; j &lt; n; j ++ ) {
                if (g[i][j] == 1) {
                    q.add(new int[]{i, j});
                    g[i][j] = -1;
                    while (!q.isEmpty()) {
                        var cell = q.poll();
                        p.add(cell);
                        for (int[] d : dirs) {
                            int x = cell[0] + d[0], y = cell[1] + d[1];
                            if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; g[x][y] == 1) {
                                q.add(new int[]{x, y});
                                g[x][y] = -1;
                            }
                        }
                    }
                }
                for (int[] x : p) q.add(x);
                int step = 0;
                while (!q.isEmpty()) {
                    var size = q.size();
                    while (size -- &gt; 0) {
                        var cell = q.poll();
                        for (int[] d : dirs) {
                            int x = cell[0] + d[0], y = cell[1] + d[1];
                            if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) {
                                if (g[x][y] == 0) {
                                    q.add(new int[]{x, y});
                                    g[x][y] = -1;
                                } else if (g[x][y] == 1) {
                                    return step;
                                }
                            }
                        }
                    } 
                    step ++ ;
                }
            }
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：并查集&amp;双向BFS</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    static int N = 10010;
    static int[] p = new int[N];
    static int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    int n;
    public int getIdx(int x, int y) {
        return x * n + y;
    }

    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }

    public void union(int a, int b) {
        p[find(a)] = find(b);    
    }

    public int shortestBridge(int[][] g) {
        n = g[0].length;
        for (int i = 0; i &lt;= n * n; i ++ ) p[i] = i;
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; n; j ++ ) {
                if (g[i][j] == 0) continue;
                for (int[] d : dirs) {
                    int x = i + d[0], y = j + d[1];
                    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= n) continue;
                    if (g[x][y] == 0) continue;
                    union(getIdx(x, y), getIdx(i, j));
                }
            }
        int a = -1;
        //d1, d2存储a岛和b岛的点
        var d1 = new ArrayDeque&lt;int[]&gt;();
        var d2 = new ArrayDeque&lt;int[]&gt;();
        //m1, m2记录从该岛屿出发到该点的距离
        var m1 = new HashMap&lt;Integer, Integer&gt;();
        var m2 = new HashMap&lt;Integer, Integer&gt;();
        for (var i = 0; i &lt; n; i ++ ) {
            for (var j = 0; j &lt; n; j ++ ) {
                if (g[i][j] == 0) continue;
                int idx = getIdx(i, j), root = find(idx);
                if (a == -1) a = root;
                if (root == a) {
                    d1.add(new int[]{i, j});
                    m1.put(idx, 0);
                } else {
                    d2.add(new int[]{i, j});
                    m2.put(idx, 0);
                }
            }
        }
        //双向BFS求解最短通路
        while (!d1.isEmpty() &amp;&amp; !d2.isEmpty()) {
            int t = -1;
            if (d1.size() &lt; d2.size()) t = bfs(d1, m1, m2);
            else t = bfs(d2, m2, m1);
            if (t != -1) return t - 1;
        }
        return -1;
    }

    public int bfs(ArrayDeque&lt;int[]&gt; q, Map&lt;Integer, Integer&gt; m1, Map&lt;Integer, Integer&gt; m2) {
        int size = q.size();
        while (size -- &gt; 0) {
            var info = q.poll();
            int x = info[0], y = info[1], idx = getIdx(x, y), step = m1.get(idx);
            for (int[] d : dirs) {
                int nx = x + d[0], ny = y + d[1], nidx = getIdx(nx, ny);
                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n) continue;
                if (m1.containsKey(nidx)) continue;
                if (m2.containsKey(nidx)) return step + 1 + m2.get(nidx);
                q.add(new int[]{nx, ny});
                m1.put(nidx, step + 1);
            }
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="dfs" tabindex="-1"><a class="header-anchor" href="#dfs" aria-hidden="true">#</a> DFS</h2><h4 id="_17-电话号码的字母组合" tabindex="-1"><a class="header-anchor" href="#_17-电话号码的字母组合" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener noreferrer">17. 电话号码的字母组合<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_39-组合总和" tabindex="-1"><a class="header-anchor" href="#_39-组合总和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener noreferrer">39. 组合总和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] cs, int target) {
        dfs(cs, 0, target);
        return ans;
    }

    public void dfs(int[] cs, int u, int target) {
        if(target == 0){
            //对象引用问题，不new 一个新的，后续 path 发生变化，结果也会变
            ans.add(new ArrayList&lt;&gt;(path));
            return;
        }
        if (u == cs.length) return;

        for (int i = 0; i * cs[u] &lt;= target; i ++ ) {
            dfs(cs, u + 1, target - cs[u] * i);
            path.add(cs[u]);
        }

        for(int i = 0; i * cs[u] &lt;= target; i ++){
            path.remove(path.size() - 1);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_47-全排列-ii" tabindex="-1"><a class="header-anchor" href="#_47-全排列-ii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener noreferrer">47. 全排列 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; ans;
    List&lt;Integer&gt; list;
    boolean[] st;
    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        ans = new ArrayList&lt;&gt;();
        list = new ArrayList&lt;&gt;();
        st = new boolean[n];
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int u) {
        if (u == nums.length) {
            ans.add(new ArrayList&lt;&gt;(list));
            return;
        }

        for (int i = 0; i &lt; nums.length; i ++ ) {
            if (!st[i]) {
            	//保证相同数字要按顺序使用，即保证相同数字的相对顺序不变即可
                if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i] &amp;&amp; !st[i - 1]) continue;
                st[i] = true;
                list.add(nums[i]);
                dfs(nums, u + 1);
                st[i] = false;
                list.remove(list.size() - 1);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_695-岛屿的最大面积" tabindex="-1"><a class="header-anchor" href="#_695-岛屿的最大面积" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/max-area-of-island/" target="_blank" rel="noopener noreferrer">695. 岛屿的最大面积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>floodfill</p><h4 id="_698-划分为k个相等的子集" tabindex="-1"><a class="header-anchor" href="#_698-划分为k个相等的子集" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener noreferrer">698. 划分为k个相等的子集<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>剪枝：</p><pre><code>1、从大到小枚举

2、nums[i] == nums[i + 1] nums[i]失败，nums[i + 1]一定失败

3、当前第一个数失败，直接跳过

4、当前最后一个数失败，直接跳过
</code></pre><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] nums;
    boolean[] st;
    int n;
    int avg;
    public boolean canPartitionKSubsets(int[] _nums, int k) {
        nums = _nums;
        n = nums.length;
        st = new boolean[n];
        int sum = 0;
        for (int x : nums) sum += x;
        //可行性剪枝
        if (sum % k != 0) return false;
        avg = sum / k;
        //从大到小枚举
        nums = Arrays.stream(nums).boxed().sorted((a, b) -&gt; b - a).mapToInt(i -&gt; i).toArray();
        return dfs(0, 0, k);
    }
    /*
    *start：当前这组从第几个开始搜
    *cur：当前组总和
    *k：已经搜了几组
     */
    public boolean dfs(int start, int cur, int k) {
        //枚举完毕返回true
        if (k == 0) return true;
        //枚举完一组继续下一组
        if (cur == avg) return dfs(0, 0, k - 1);
        for (int i = start; i &lt; n; i ++ ) {
            if (st[i] || cur + nums[i] &gt; avg) continue;
            st[i] = true;
            if (dfs(i + 1, cur + nums[i], k)) return true;
            st[i] = false;
            //剪枝nums[i] == nums[i + 1] nums[i]失败，nums[i + 1]一定失败
            while (i + 1 &lt; n &amp;&amp; nums[i + 1] == nums[i]) i ++ ;
            //当前组的第一个数或者最后一个数失败那么一定失败
            if (cur == 0) return false;
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-12-矩阵中的路径" tabindex="-1"><a class="header-anchor" href="#剑指-offer-12-矩阵中的路径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 12. 矩阵中的路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    char[][] g;
    String word;
    int n, m;
    boolean[][] st;
    public boolean exist(char[][] board, String _word) {
        g = board;
        n = g.length;
        m = g[0].length;
        word = _word;
        st = new boolean[n][m];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                if (g[i][j] == word.charAt(0)) {
                    st[i][j] = true;
                    if (dfs(i, j, 0)) return true;
                    st[i][j] = false;
                }
            }
        }
        return false;
    }
    int[] dx = new int[]{-1, 0, 1, 0}, dy = new int[]{0, 1, 0, -1};
    public boolean dfs(int i, int j, int u) {
        if (u == word.length() - 1) return true;
        for (int k = 0; k &lt; 4; k ++ ) {
            int x = i + dx[k], y = j + dy[k];
            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue;
            if (g[x][y] != word.charAt(u + 1)) continue;
            if (!st[x][y]) {
                st[x][y] = true;
                if (dfs(x, y, u + 1)) return true;
                st[x][y] = false;
            }
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-34-二叉树中和为某一值的路径" tabindex="-1"><a class="header-anchor" href="#剑指-offer-34-二叉树中和为某一值的路径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 34. 二叉树中和为某一值的路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) {
        dfs(root, target);
        return res;
    }
    public void dfs(TreeNode root, int t) {
        if (root == null) return;
        path.add(root.val);
        if (t == root.val &amp;&amp; root.left == null &amp;&amp; root.right == null) 
        	res.add(new ArrayList&lt;&gt;(path));
        dfs(root.left, t - root.val);
        dfs(root.right, t - root.val);
        path.remove(path.size() - 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-26-树的子结构" tabindex="-1"><a class="header-anchor" href="#剑指-offer-26-树的子结构" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 26. 树的子结构<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if (A == null || B == null) return false;
        return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    public boolean dfs(TreeNode A, TreeNode B) {
        if (B == null) return true;
        if (A == null) return false;
        return A.val == B.val &amp;&amp; dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-36-二叉搜索树与双向链表" tabindex="-1"><a class="header-anchor" href="#剑指-offer-36-二叉搜索树与双向链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 36. 二叉搜索树与双向链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    public void dfs(Node root) {
        if (root == null) return;
        dfs(root.left);
        //如果pre为空，则说明是第一节点，头节点，然后用head保存头节点
        if (pre == null) head = root;
        //如果不为空，那就说明是中间的节点，并且pre保存的是上一个节点
        //让上一个节点的右指针指向当前节点
        else if (pre != null) pre.right = root;
        //将当前节点的做指针指向父节点
        root.left = pre;
        //保存当前节点，用于下层递归创建
        pre = root;
        dfs(root.right);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-38-字符串的排列" tabindex="-1"><a class="header-anchor" href="#剑指-offer-38-字符串的排列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 38. 字符串的排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    List&lt;Character&gt; path = new ArrayList&lt;&gt;();
    boolean[] st;
    char[] ss;
    public String[] permutation(String s) {
        int n = s.length();
        ss = s.toCharArray();
        st = new boolean[n];
        Arrays.sort(ss);
        dfs(ss, n);
        String[] ans = new String[list.size()];
        //for (List&lt;Character&gt; i : list) System.out.println(i);
        for (int i = 0; i &lt; list.size(); i ++ ) ans[i] = list.get(i);
        return ans;
    }
    public void dfs(char[] ss, int k) {
        if (k == path.size()) {
            StringBuilder sb = new StringBuilder();
            for (char c : path) sb.append(c);
            list.add(sb.toString());
        }

        for (int i = 0; i &lt; ss.length; i ++ ) {
            if (!st[i]) {
                if (i &gt; 0 &amp;&amp; ss[i] == ss[i - 1] &amp;&amp; !st[i - 1]) continue;
                st[i] = true;
                path.add(ss[i]);
                dfs(ss, k);
                st[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_494-目标和" tabindex="-1"><a class="header-anchor" href="#_494-目标和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener noreferrer">494. 目标和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs
class Solution {
    public int findTargetSumWays(int[] nums, int t) {
        return dfs(nums, t, 0);
    }
    public int dfs(int[] nums, int t, int u) {
        if (u == nums.length) return t == 0 ? 1 : 0;
        int l = dfs(nums, t - nums[u], u + 1);
        int r = dfs(nums, t + nums[u], u + 1);
        return l + r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs + 记忆化搜索
class Solution {
    public int findTargetSumWays(int[] nums, int t) {
        return dfs(nums, t, 0);
    }
    public int dfs(int[] nums, int t, int u) {
        if (u == nums.length) return t == 0 ? 1 : 0;
        int l = dfs(nums, t - nums[u], u + 1);
        int r = dfs(nums, t + nums[u], u + 1);
        return l + r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_403-青蛙过河" tabindex="-1"><a class="header-anchor" href="#_403-青蛙过河" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/frog-jump/" target="_blank" rel="noopener noreferrer">403. 青蛙过河<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//记忆化搜索
class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    Map&lt;String, Boolean&gt; cache = new HashMap&lt;&gt;();
    public boolean canCross(int[] stones) {
        int n = stones.length;
        for (int i = 0; i &lt; n; i ++ ) map.put(stones[i], i);
        if (stones[1] != 1) return false;
        return dfs(stones, n, 1, 1);
    }
    /**
     * 判定是否能够跳到最后一块石子
     * @param ss 石子列表【不变】
     * @param n  石子列表长度【不变】
     * @param u  当前所在的石子的下标
     * @param k  上一次是经过多少步跳到当前位置的
     * @return 是否能跳到最后一块石子
     */
    public boolean dfs(int[] ss, int n, int u, int k) {
        if (u == n - 1) return true;
        String key = u + &quot;_&quot; + k;
        if (cache.containsKey(key)) return cache.get(key);
        else 
        for (int i = -1; i &lt;= 1; i ++ ) {
            if (i + k == 0) continue;
            //理论上下一个石头的编号
            int next = ss[u] + i + k;
            if (map.containsKey(next)) {
                boolean cur = dfs(ss, n, map.get(next), k + i);
                cache.put(key, cur);
                if (cur) return true;
            }
        }
        cache.put(key, false);
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_337-打家劫舍-iii-1" tabindex="-1"><a class="header-anchor" href="#_337-打家劫舍-iii-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener noreferrer">337. 打家劫舍 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//记忆化搜索
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map&lt;TreeNode, Integer&gt; map = new HashMap&lt;&gt;();
    public int rob(TreeNode root) {
        if (root == null) return 0;
        if (map.containsKey(root)) return map.get(root);
        int a = root.val;
        if (root.left != null) a += rob(root.left.left) + rob(root.left.right);
        if (root.right != null) a += rob(root.right.left) + rob(root.right.right);
        int b = rob(root.left) + rob(root.right);
        map.put(root, Math.max(a, b));
        return Math.max(a, b);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_394-字符串解码" tabindex="-1"><a class="header-anchor" href="#_394-字符串解码" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/decode-string/" target="_blank" rel="noopener noreferrer">394. 字符串解码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int u = 0;
    public String decodeString(String s) {
        return dfs(s);
    }
    public String dfs(String s) {
        StringBuilder res = new StringBuilder();
        while (u &lt; s.length() &amp;&amp; s.charAt(u) != &#39;]&#39;) {
            if (s.charAt(u) &gt;= &#39;a&#39; &amp;&amp; s.charAt(u) &lt;= &#39;z&#39; || s.charAt(u) &gt;= &#39;A&#39; &amp;&amp; s.charAt(u) &lt;= &#39;Z&#39;) {
                res.append(s.charAt(u ++ ));
            }
            else if (s.charAt(u) &gt;= &#39;0&#39; &amp;&amp; s.charAt(u) &lt;= &#39;9&#39;) {
                int k = u;
                while (s.charAt(k) &gt;= &#39;0&#39; &amp;&amp; s.charAt(k) &lt;= &#39;9&#39;) k ++ ;
                int x = Integer.parseInt(s.substring(u, k));
                u = k + 1;
                String y = dfs(s);
                //过滤掉右括号
                u ++ ;
                //System.out.println(s.charAt(u));
                while (x &gt; 0) {
                    res.append(y);
                    x -- ;
                }
            }
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_22-括号生成" tabindex="-1"><a class="header-anchor" href="#_22-括号生成" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener noreferrer">22. 括号生成<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;String&gt; ans = new ArrayList&lt;&gt;();
    public List&lt;String&gt; generateParenthesis(int n) {
        dfs(n, 0, 0, &quot;&quot;);
        return ans;
    }
    //任意前缀中&quot;(&quot;数量&gt;=&quot;)&quot;数量
    //左右括号数量相等
    public void dfs(int n, int l, int r, String s) {
        if (l == n &amp;&amp; r == n) ans.add(s);
        else {
            if (l &lt; n) dfs(n, l + 1, r, s + &quot;(&quot;);
            if (r &lt; n &amp;&amp; l &gt; r) dfs(n, l, r + 1, s + &quot;)&quot;);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-33-二叉搜索树的后序遍历序列-1" tabindex="-1"><a class="header-anchor" href="#剑指-offer-33-二叉搜索树的后序遍历序列-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 33. 二叉搜索树的后序遍历序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return verify(postorder, 0, postorder.length - 1);
    }
    public boolean verify(int[] pos, int l, int r) {
        if (l &gt;= r) return true;
        int m = l;
        //划分左右子树
        while (pos[m] &lt; pos[r]) m ++ ;
        for (int i = m; i &lt; r; i ++ ) {
            if (pos[i] &lt; pos[r]) return false;
        }
        return verify(pos, l, m - 1) &amp;&amp; verify(pos, m, r - 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_297-二叉树的序列化与反序列化" tabindex="-1"><a class="header-anchor" href="#_297-二叉树的序列化与反序列化" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener noreferrer">297. 二叉树的序列化与反序列化<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    private StringBuilder sb = new StringBuilder();
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        dfs1(root);
        return sb.toString();
    }
    public void dfs1(TreeNode root) {
        if (root == null) {
            sb.append(&quot;null.&quot;);
            return;
        }
        sb.append(root.val).append(&quot;.&quot;);
        dfs1(root.left);
        dfs1(root.right);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] t = data.split(&quot;\\.&quot;);
        List&lt;String&gt; list = new LinkedList&lt;&gt;(Arrays.asList(t));
        return dfs2(list);
    }
    public TreeNode dfs2(List&lt;String&gt; list) {
        if (list.get(0).equals(&quot;null&quot;)) {
            list.remove(0);
            return null;
        }
        TreeNode res = new TreeNode(Integer.valueOf(list.get(0)));
        list.remove(0);
        res.left = dfs2(list);
        res.right = dfs2(list);
        return res;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5289-公平分发饼干" tabindex="-1"><a class="header-anchor" href="#_5289-公平分发饼干" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/fair-distribution-of-cookies/" target="_blank" rel="noopener noreferrer">5289. 公平分发饼干<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] sum = new int[10], q;
    int ans = (int)1e9, n;
    public void dfs(int u) {
        if (u == q.length) {
            int mx = 0;
            for (int i = 0; i &lt; n; i ++ ) mx = Math.max(mx, sum[i]);
            ans = Math.min(ans, mx);
            return; 
        }
        for (int i = 0; i &lt; n; i ++ ) {
            sum[i] += q[u];
            //剪枝，当前组如果大于1e9则不可能优化最优解，就不进行递归
            if (sum[i] &lt;= ans) {
                dfs(u + 1);
            }
            sum[i] -= q[u];
        }
    }
    public int distributeCookies(int[] cookies, int k) {
        n = k;
        q = cookies;
        dfs(0);
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_90-子集-ii" tabindex="-1"><a class="header-anchor" href="#_90-子集-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener noreferrer">90. 子集 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    int[] nums;
    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] _nums) {
        nums = _nums;
        Arrays.sort(nums);
        dfs(0);
        return ans;
    }
    public void dfs(int u) {
        if (u == nums.length) {
            ans.add(new ArrayList&lt;&gt;(path));
            return;
        }
        int k = u + 1;
        while (k &lt; nums.length &amp;&amp; nums[k] == nums[u]) k ++ ;
        
        for (int i = 0; i &lt;= k - u; i ++ ) {
            dfs(k);
            path.add(nums[u]);
        }
        for (int i = 0; i &lt;= k - u; i ++ ) {
            path.remove(path.size() - 1);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_508-出现次数最多的子树元素和" tabindex="-1"><a class="header-anchor" href="#_508-出现次数最多的子树元素和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/most-frequent-subtree-sum/" target="_blank" rel="noopener noreferrer">508. 出现次数最多的子树元素和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    int max = 0;
    public int[] findFrequentTreeSum(TreeNode root) {
        dfs(root);
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int t : map.keySet()) if (map.get(t) == max) list.add(t);
        int[] ans = new int[list.size()];
        for (int i = 0; i &lt; list.size(); i ++ ) ans[i] = list.get(i);
        return ans;
    }
    public int dfs(TreeNode root) {
        if (root == null) return 0;
        int l = dfs(root.left), r = dfs(root.right);
        int ans = l + r + root.val;
        map.put(ans, map.getOrDefault(ans, 0) + 1);
        max = Math.max(max, map.get(ans));
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -&gt; List[int]:
        map = Counter()
        def dfs(root):
            if not root: return 0
            l, r = dfs(root.left), dfs(root.right)
            res = l + r + root.val
            map[res] += 1
            return res
        dfs(root)
        mx = max(map.values())
        return [x for x, c in map.items() if c == mx]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_241-为运算表达式设计优先级" tabindex="-1"><a class="header-anchor" href="#_241-为运算表达式设计优先级" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener noreferrer">241. 为运算表达式设计优先级<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    char cs[];
    public List&lt;Integer&gt; diffWaysToCompute(String expression) {
        cs = expression.toCharArray();
        return dfs(0, cs.length - 1);
    }
    public List&lt;Integer&gt; dfs(int l, int r) {
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = l; i &lt;= r; i ++ ) {
            if (cs[i] &gt;= &#39;0&#39; &amp;&amp; cs[i] &lt;=&#39;9&#39;) continue;
            List&lt;Integer&gt; l1 = dfs(l,i - 1), r1 = dfs(i + 1, r);
            for (int a : l1) {
                for (int b : r1) {
                    int cur = 0;
                    if (cs[i] == &#39;+&#39;) cur = a + b;
                    else if (cs[i] == &#39;-&#39;) cur = a - b;
                    else cur = a * b;
                    ans.add(cur);
                }
            }
        }
        if (ans.isEmpty()) {
            int cur = 0;
            for (int i = l; i &lt;= r; i ++ ) cur = cur * 10 + (cs[i] - &#39;0&#39;);
            ans.add(cur);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_95-不同的二叉搜索树-ii" tabindex="-1"><a class="header-anchor" href="#_95-不同的二叉搜索树-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener noreferrer">95. 不同的二叉搜索树 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;TreeNode&gt; generateTrees(int n) {
        return dfs(1, n);
    }
    public List&lt;TreeNode&gt; dfs(int l, int r) { 
        List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;();
        if (l &gt; r) {
            ans.add(null);
            return ans;
        }
        for (int i = l; i &lt;= r; i ++ ) {
            List&lt;TreeNode&gt; l1 = dfs(l, i - 1), l2 = dfs(i + 1, r);
            for (TreeNode ll : l1) {
                for (TreeNode rr: l2) {
                    TreeNode root = new TreeNode(i);
                    root.left = ll;
                    root.right = rr;
                    ans.add(root);
                }
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6110-网格图中递增路径的数目" tabindex="-1"><a class="header-anchor" href="#_6110-网格图中递增路径的数目" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/" target="_blank" rel="noopener noreferrer">6110. 网格图中递增路径的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//记忆化搜索
class Solution {
    int mod = (int) 1e9 + 7;
    int m, n;
    //定义f[i][j]表示以i行j列的格子位起点的路径数
    int[][] g, f;
    int[] dx = new int[]{-1, 0, 1, 0}, dy = new int[]{0, 1, 0, -1};
    public int countPaths(int[][] grid) {
        g = grid;
        m = g.length;
        n = g[0].length;
        f = new int[m][n];
        for (int i = 0; i &lt; m; i ++ ) Arrays.fill(f[i], -1);
        long ans = 0;
        //枚举所有起点
        for (int i = 0; i &lt; m; i ++ ) {
            for (int j = 0; j &lt; n; j ++ ) {
                ans = (ans + dfs(i, j)) % mod;
            }
        }
        return (int) ans;
    }
    public int dfs(int i, int j) {
        if (f[i][j] != -1) return f[i][j];
        int res = 1;
        for (int k = 0; k &lt; 4; k ++ ) {
            int x = i + dx[k], y = j + dy[k];
            if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) continue;
            if (g[x][y] &lt;= g[i][j]) continue;
            res = (res + dfs(x, y)) % mod; 
        }
        return f[i][j] = res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_129-求根节点到叶节点数字之和" tabindex="-1"><a class="header-anchor" href="#_129-求根节点到叶节点数字之和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener noreferrer">129. 求根节点到叶节点数字之和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    public int sumNumbers(TreeNode root) {
        dfs(root, 0);
        return ans;
    }
    public void dfs (TreeNode root, int cur) {
        cur = cur * 10 + root.val;
        if (root.left == null &amp;&amp; root.right == null) ans += cur;
        if (root.left != null) dfs(root.left, cur);
        if (root.right != null) dfs(root.right, cur);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_116-填充每个节点的下一个右侧节点指针-1" tabindex="-1"><a class="header-anchor" href="#_116-填充每个节点的下一个右侧节点指针-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener noreferrer">116. 填充每个节点的下一个右侧节点指针<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        Node ans = dfs(root);
        return ans;
    }
    public Node dfs(Node root) {
        if (root == null || root.right == null) return root;
        //树的左子树指向右子树
        root.left.next = root.right;
        //右子树的右节点指向下一个节点
        if (root.next != null) root.right.next = root.next.left;
        dfs(root.left);dfs(root.right);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_117-填充每个节点的下一个右侧节点指针-ii-1" tabindex="-1"><a class="header-anchor" href="#_117-填充每个节点的下一个右侧节点指针-ii-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener noreferrer">117. 填充每个节点的下一个右侧节点指针 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        dfs(root);
        return root;
    }
    public Node dfs(Node root) {
        if (root == null || (root.left == null &amp;&amp; root.right == null)) return root;
        //左右都不空
        if (root.left != null &amp;&amp; root.right != null) {
            root.left.next = root.right;
            root.right.next = getNextNode(root);
        }
        //左空右不空
        if (root.left == null) root.right.next = getNextNode(root);
        //左不空右不空
        if (root.right == null) root.left.next = getNextNode(root);
        //注意优先建立右子树关系
        //[2,1,3,0,7,9,1,2,null,1,0,null,null,8,8,null,null,null,null,7]
        dfs(root.right);dfs(root.left);
        return root;
    }
    //找到下一个具有左或右子节点的Node
    public Node getNextNode(Node root) {
        while (root.next != null) {
            if (root.next.left != null) return root.next.left;
            if (root.next.right != null) return root.next.right;
            root = root.next;
        }
        return null;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_199-二叉树的右视图" tabindex="-1"><a class="header-anchor" href="#_199-二叉树的右视图" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreferrer">199. 二叉树的右视图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
    public List&lt;Integer&gt; rightSideView(TreeNode root) {
        dfs(root, 0);
        return ans;
    }
    public void dfs(TreeNode root, int u) {
        if (root == null) return;
        if (ans.size() == u) ans.add(root.val);
        dfs(root.right, u + 1);dfs(root.left, u + 1);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_130-被围绕的区域" tabindex="-1"><a class="header-anchor" href="#_130-被围绕的区域" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/surrounded-regions/" target="_blank" rel="noopener noreferrer">130. 被围绕的区域<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int n, m;
    char[][] g;
    boolean[][] st;
    //先标记不会被覆盖的
    public void solve(char[][] board) {
        g = board;
        n = board.length;
        m = board[0].length;
        st = new boolean[n][m];
        for (int i = 0; i &lt; n; i ++ ) {
            if (g[i][0] == &#39;O&#39;) dfs(i, 0);
            if (g[i][m - 1] == &#39;O&#39;) dfs(i, m - 1);
        }
        
        for (int j = 0; j &lt; m; j ++ ) {
            if (g[0][j] == &#39;O&#39;) dfs(0, j);
            if (g[n - 1][j] == &#39;O&#39;) dfs(n - 1, j);
        }

        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                if (!st[i][j]) board[i][j] = &#39;X&#39;;
            }
        }
    }
    int[] dx = new int[]{-1, 0, 1, 0}, dy = new int[]{0, 1, 0, -1};
    public void dfs(int i, int j) {
        st[i][j] = true;
        for (int k = 0; k &lt; 4; k ++ ) {
            int a = i + dx[k], b = j + dy[k];
            if (a &lt; 0 || a &gt;= n) continue;
            if (b &lt; 0 || b &gt;= m) continue;
            if (st[a][b]) continue;
            if (g[a][b] != &#39;O&#39;) continue;
            dfs(a, b);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_124-二叉树中的最大路径和" tabindex="-1"><a class="header-anchor" href="#_124-二叉树中的最大路径和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener noreferrer">124. 二叉树中的最大路径和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int res = -Integer.MAX_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return res;
    }
    public int dfs(TreeNode root) {
        if (root == null) return 0;
        int l = Math.max(0, dfs(root.left)),r = Math.max(0, dfs(root.right));
        res = Math.max(res, root.val + l + r);
        return root.val + Math.max(l, r);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_329-矩阵中的最长递增路径" tabindex="-1"><a class="header-anchor" href="#_329-矩阵中的最长递增路径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener noreferrer">329. 矩阵中的最长递增路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int n, m;
    int[][] g, f;
    public int longestIncreasingPath(int[][] matrix) {
        g = matrix;
        n = g.length;
        m = g[0].length;
        f = new int[n][m];
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) Arrays.fill(f[i], -1);
        for (int i = 0; i &lt; n; i ++ ) { 
            for (int j = 0; j &lt; m; j ++) {
                res = Math.max(res, dfs(i, j));
            }
        }
        return res;
    }
    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    public int dfs(int i, int j) {
        if (f[i][j] != -1) return f[i][j];
        f[i][j] = 1;
        for (int[] d : dirs) {
            int x = i + d[0], y = j + d[1];
            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue;
            if (g[x][y] &lt;= g[i][j]) continue;
            f[i][j] = Math.max(f[i][j], dfs(x, y) + 1);
        }
        return f[i][j]; 
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_419-甲板上的战舰" tabindex="-1"><a class="header-anchor" href="#_419-甲板上的战舰" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/battleships-in-a-board/" target="_blank" rel="noopener noreferrer">419. 甲板上的战舰<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    char[][] g;
    public int countBattleships(char[][] board) {
        g = board;
        int ans = 0;
        for (int i = 0; i &lt; g.length; i ++ ) {
            for (int j = 0; j &lt; g[0].length; j ++ ) {
                if (g[i][j] == &#39;X&#39;) {
                    ans ++ ;
                    dfs(i, j);
                }
            }
        }
        return ans;
    }
    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    public void dfs(int i, int j) {
        g[i][j] = &#39;.&#39;;
        for (int[] d : dirs) {
            int x = i + d[0], y = j + d[1];
            if (x &lt; 0 || x &gt;= g.length || y &lt; 0 || y &gt;= g[0].length) continue;
            if (g[x][y] != &#39;X&#39;) continue;
            dfs(x, y);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1038-从二叉搜索树到更大和树" tabindex="-1"><a class="header-anchor" href="#_1038-从二叉搜索树到更大和树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/" target="_blank" rel="noopener noreferrer">1038. 从二叉搜索树到更大和树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int t;
    public TreeNode bstToGst(TreeNode root) {
        dfs(root);
        return root;
    }
    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.right);
        t += root.val;
        root.val = t;
        dfs(root.left);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1026-节点与其祖先之间的最大差值" tabindex="-1"><a class="header-anchor" href="#_1026-节点与其祖先之间的最大差值" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/" target="_blank" rel="noopener noreferrer">1026. 节点与其祖先之间的最大差值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    public int maxAncestorDiff(TreeNode root) {
        dfs(root, root.val, root.val);
        return ans;
    }
    //记录当前节点所有父节点的最大值和最小值
    public void dfs(TreeNode root, int max, int min) {
        if (root == null) return;
        max = Math.max(root.val, max);
        min = Math.min(root.val, min);
        dfs(root.left, max, min);dfs(root.right, max, min);
        ans = Math.max(ans, max - min);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1080-根到叶路径上的不足节点" tabindex="-1"><a class="header-anchor" href="#_1080-根到叶路径上的不足节点" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/" target="_blank" rel="noopener noreferrer">1080. 根到叶路径上的不足节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sufficientSubset(TreeNode root, int limit) {
        TreeNode res = dfs(root, 0, limit);
        return res;
    }
    //如果该点删除那么他的左右子树也一定删除
    public TreeNode dfs(TreeNode root, int sum, int limit) {
        sum += root.val;
        if (root.left == null &amp;&amp; root.right == null) {
            if (sum &lt; limit) root = null;
        } else {
            if (root.left != null) 
                root.left = dfs(root.left, sum, limit);
            if (root.right != null) 
                root.right = dfs(root.right, sum, limit);
            if (root.left == null &amp;&amp; root.right == null) 
                root = null;
        }
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_652-寻找重复的子树" tabindex="-1"><a class="header-anchor" href="#_652-寻找重复的子树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-duplicate-subtrees/" target="_blank" rel="noopener noreferrer">652. 寻找重复的子树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List&lt;TreeNode&gt; ans = new ArrayList&lt;&gt;();
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    public List&lt;TreeNode&gt; findDuplicateSubtrees(TreeNode root) {
        dfs(root);
        return ans;
    }
    public String dfs(TreeNode root) {
        if (root == null) return &quot;&quot;;
        StringBuilder sb = new StringBuilder();
        sb.append(root.val).append(&quot;,&quot;);
        sb.append(dfs(root.left)).append(&quot;,&quot;);
        sb.append(dfs(root.right));
        String cur = sb.toString();
        map.put(cur, map.getOrDefault(cur, 0) + 1);
        if (map.get(cur) == 2) ans.add(root);
        return cur;
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_669-修剪二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_669-修剪二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">669. 修剪二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        TreeNode res = dfs(root, low, high);
        return res;
    }
    public TreeNode dfs(TreeNode root, int l, int r) {
        if (root == null) return root;
        //修建二叉树
        if (root.val &lt; l) return dfs(root.right, l, r);
        if (root.val &gt; r) return dfs(root.left, l, r);
        //处理正常的节点
        root.left = dfs(root.left, l, r);
        root.right = dfs(root.right, l, r);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_690-员工的重要性-1" tabindex="-1"><a class="header-anchor" href="#_690-员工的重要性-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/employee-importance/" target="_blank" rel="noopener noreferrer">690. 员工的重要性<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*
// Definition for Employee.
class Employee {
    public int id;
    public int importance;
    public List&lt;Integer&gt; subordinates;
};
*/

class Solution {
    Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;();
    public int getImportance(List&lt;Employee&gt; employees, int id) {
        for (Employee e : employees) map.put(e.id, e);
        int res = dfs(id);
        return res;
    }
    public int dfs(int id) {
        Employee e = map.get(id);
        int res = e.importance;
        for (int i : e.subordinates) res += dfs(i);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_814-二叉树剪枝" tabindex="-1"><a class="header-anchor" href="#_814-二叉树剪枝" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-pruning/" target="_blank" rel="noopener noreferrer">814. 二叉树剪枝<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public TreeNode pruneTree(TreeNode root) {
        if (!dfs(root)) return null;
        return root;
    }
    public boolean dfs(TreeNode root) {
        if (root == null) return false;
        if (!dfs(root.left)) root.left = null;
        if (!dfs(root.right))  root.right = null;
        return root.val == 1 || root.left != null || root.right != null;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_133-克隆图" tabindex="-1"><a class="header-anchor" href="#_133-克隆图" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/clone-graph/" target="_blank" rel="noopener noreferrer">133. 克隆图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    Map&lt;Node, Node&gt; hash = new HashMap&lt;&gt;();
    public void dfs(Node node) {
        hash.put(node, new Node(node.val));
        for (var x : node.neighbors) {
            if (!hash.containsKey(x)) {
                dfs(x);
            }
        }
    }
    public Node cloneGraph(Node node) {
        if (node == null) return null;
        //复制所有点
        dfs(node);
        for (var x : hash.keySet()) 
            for (var y : x.neighbors) 
                hash.get(x).neighbors.add(hash.get(y));
        
        return hash.get(node);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_655-输出二叉树" tabindex="-1"><a class="header-anchor" href="#_655-输出二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/print-binary-tree/" target="_blank" rel="noopener noreferrer">655. 输出二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    String[][] res;
    public int[] dfs(TreeNode root) {
        if (root == null) return new int[]{0, 0};
        int[] l = dfs(root.left), r = dfs(root.right);
        return new int[]{Math.max(l[0], r[0]) + 1, Math.max(l[1], r[1]) * 2 + 1};
    }
    public void print(TreeNode root, int h, int l, int r) {
        if (root == null) return;
        int mid = l + r &gt;&gt; 1;
        res[h][mid] = String.valueOf(root.val);
        print(root.left, h + 1, l, mid - 1);
        print(root.right, h + 1, mid + 1, r);
    }
    public List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) {
        int[] t = dfs(root);
        int h = t[0], w = t[1];
        res = new String[h][w];
        for (int i = 0; i &lt; h; i ++ ) 
            Arrays.fill(res[i], &quot;&quot;);
        print(root, 0, 0, w - 1);
        List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; h; i ++ )
            list.add(Arrays.asList(res[i]));
        return list;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_785-判断二分图-1" tabindex="-1"><a class="header-anchor" href="#_785-判断二分图-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/is-graph-bipartite/" target="_blank" rel="noopener noreferrer">785. 判断二分图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] st;
    int[][] g;
    public boolean isBipartite(int[][] _g) {
        g = _g;
        st = new int[g.length];
        for (int i = 0; i &lt; g.length; i ++ ) {
            if (st[i] == 0 &amp;&amp; !dfs(i, 1))
                return false;
        }
        return true;
    }
    public boolean dfs(int u, int colour) {
        st[u] = colour;
        for (int x : g[u]) {
            if (st[x] != 0) {
                if (st[x] == colour)
                    return false;
            } else if (!dfs(x, -colour)) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_491-递增子序列" tabindex="-1"><a class="header-anchor" href="#_491-递增子序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/increasing-subsequences/" target="_blank" rel="noopener noreferrer">491. 递增子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; res;
    List&lt;Integer&gt; path;
    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {
        res = new ArrayList&lt;&gt;();
        path = new ArrayList&lt;&gt;();
        dfs(nums, 0);
        return res;
    }
    
    public void dfs(int[] nums, int u) {
        if (path.size() &gt;= 2) res.add(new ArrayList&lt;&gt;(path));
        if (u == nums.length) return;
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i = u; i &lt; nums.length; i ++ ) {
            if (path.isEmpty() || nums[i] &gt;= path.get(path.size() - 1)) {
                //如果这个数已经被选过，那么所有选这个数的情况已经被枚举过了
                if (set.contains(nums[i])) continue;
                set.add(nums[i]);
                path.add(nums[i]);
                dfs(nums, i + 1);
                path.remove(path.size() - 1);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_865-具有所有最深节点的最小子树" tabindex="-1"><a class="header-anchor" href="#_865-具有所有最深节点的最小子树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank" rel="noopener noreferrer">865. 具有所有最深节点的最小子树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        return dfs(root).root;
    }
    public Pair dfs(TreeNode root) {
        if (root == null) return new Pair(null, 0);
        Pair l = dfs(root.left), r = dfs(root.right);
        if (l.depth == r.depth) return new Pair(root, l.depth + 1);
        if (l.depth &gt; r.depth) return new Pair(l.root, l.depth + 1);
        else return new Pair(r.root, r.depth + 1);
    }
    public class Pair {
        TreeNode root;
        int depth;
        public Pair(TreeNode root, int depth) {
            this.root = root;
            this.depth = depth;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_216-组合总和-iii" tabindex="-1"><a class="header-anchor" href="#_216-组合总和-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener noreferrer">216. 组合总和 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;List&lt;Integer&gt;&gt; res;
    List&lt;Integer&gt; path;
    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {
        res = new ArrayList&lt;&gt;();
        path = new ArrayList&lt;&gt;();
        dfs(1, n, k);
        return res;
    }
    public void dfs(int start, int n, int k) {
        if (n == 0) {
            if (k == 0)
                res.add(new ArrayList&lt;&gt;(path));
        } else {
            for (int i = start; i &lt;= 9; i ++ ) {
                if (n &gt;= i) {
                    path.add(i);
                    dfs(i + 1, n - i, k - 1);
                    path.remove(path.size() - 1);
                }
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_572-另一棵树的子树" tabindex="-1"><a class="header-anchor" href="#_572-另一棵树的子树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/subtree-of-another-tree/" target="_blank" rel="noopener noreferrer">572. 另一棵树的子树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean isSubtree(TreeNode p, TreeNode q) {
        if (p == null) return false;
        return dfs(p, q) || isSubtree(p.left, q) || isSubtree(p.right, q);
    }

    public boolean dfs(TreeNode p, TreeNode q) {
        if (p == null &amp;&amp; q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return dfs(p.left, q.left) &amp;&amp; dfs(p.right, q.right);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_37-解数独" tabindex="-1"><a class="header-anchor" href="#_37-解数独" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener noreferrer">37. 解数独<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    boolean[][] row, col, block;
    public boolean dfs(char[][] board, int i, int j) {
        while (board[i][j] != &#39;.&#39;) {
            if ( ++ j == 9) {
                i ++ ;
                j = 0;
            }
            if (i == 9) return true;
        }
        for (int k = 0; k &lt; 9; k ++ ) {
            int x = i / 3 * 3 + j / 3;
            if (!row[i][k] &amp;&amp; !col[j][k] &amp;&amp; !block[x][k]) {
                board[i][j] = (char)(k + &#39;1&#39;);
                row[i][k] = true;
                col[j][k] = true;
                block[x][k] = true;
                if (dfs(board, i, j)) return true;
                else {
                    board[i][j] = &#39;.&#39;;
                    row[i][k] = false;
                    col[j][k] = false;
                    block[x][k] = false;
                }
            }
        }
        return false;
    }
    public void solveSudoku(char[][] board) {
        col = new boolean[9][9];
        row = new boolean[9][9];
        block = new boolean[9][9];
        for (int i = 0; i &lt; 9; i ++ )
            for (int j = 0; j &lt; 9; j ++ ) 
                if (board[i][j] != &#39;.&#39;) {
                    int k = board[i][j] - &#39;1&#39;;
                    row[i][k] = true;
                    col[j][k] = true;
                    block[i / 3 * 3 + j / 3][k] = true;
                }
        
        dfs(board, 0, 0);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-寻找两个正序数组的中位数" tabindex="-1"><a class="header-anchor" href="#_4-寻找两个正序数组的中位数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener noreferrer">4. 寻找两个正序数组的中位数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public double findMedianSortedArrays(int[] a, int[] b) {
        int tot = a.length + b.length;
        if (tot % 2 == 0) {
            int left = find(a, 0, b, 0, tot / 2);
            int right = find(a, 0, b, 0, tot / 2 + 1);
            return (left + right) / 2.0;
        } else {
            return find(a, 0, b, 0, tot / 2 + 1);
        }
    }

    public int find(int[] a, int i, int[] b, int j, int k) {
        if (a.length - i &gt; b.length - j) return find(b, j, a, i, k);
        if (i == a.length) return b[j + k - 1];
        if (k == 1) return Math.min(a[i], b[j]);
        int si = Math.min(i + k / 2, a.length), sj = j + k / 2;
        if (a[si - 1] &gt; b[sj - 1])
            return find(a, i, b, sj, k - (sj - j));
        else 
            return find(a, si, b, j, k - (si - i));
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_886-可能的二分法" tabindex="-1"><a class="header-anchor" href="#_886-可能的二分法" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/possible-bipartition/" target="_blank" rel="noopener noreferrer">886. 可能的二分法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：染色法判断二分图</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int N = 2010, M =  2 * 10010;
    int[] h, e, ne, colour;
    int idx;

    public void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++ ;
    }

    public boolean dfs(int u, int cur) {
        colour[u] = cur;
        for (int i = h[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (colour[j] == cur) return false;
            if (colour[j] == 0 &amp;&amp; !dfs(j, 3 - cur)) return false;
        }
        return true;
    }

    public boolean possibleBipartition(int n, int[][] dislikes) {
        h = new int[N];
        e = new int[M];
        ne = new int[M];
        colour = new int[N];
        Arrays.fill(h, -1);
        for (int[] e : dislikes) {
            int a = e[0], b = e[1];
            add(a, b);
            add(b, a);
        }

        for (int i = 1; i &lt;= n; i ++ ) {
            if (colour[i] != 0) continue;
            if (!dfs(i, 1)) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_112-路径总和" tabindex="-1"><a class="header-anchor" href="#_112-路径总和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener noreferrer">112. 路径总和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        return dfs(root, targetSum);
    }
    public boolean dfs(TreeNode root, int target) {
        if (root == null) return false;
        target -= root.val;
        if (root.left == null &amp;&amp; root.right == null &amp;&amp; target == 0)
            return true;
        return dfs(root.left, target) || dfs(root.right, target);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_784-字母大小写全排列" tabindex="-1"><a class="header-anchor" href="#_784-字母大小写全排列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/letter-case-permutation/" target="_blank" rel="noopener noreferrer">784. 字母大小写全排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;String&gt; res = new ArrayList&lt;&gt;();
    public List&lt;String&gt; letterCasePermutation(String S) {
        dfs(new StringBuilder(S), 0);
        return res;
    }

    public void dfs(StringBuilder s, int u) {
        if (u == s.length()) {
            res.add(s.toString());
        } else {
            dfs(s, u + 1);
            if (Character.isLetter(s.charAt(u))) {
                s.setCharAt(u, (char)(s.charAt(u) ^ 32));
                dfs(s, u + 1);
                s.setCharAt(u, (char)(s.charAt(u) ^ 32));
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="并查集" tabindex="-1"><a class="header-anchor" href="#并查集" aria-hidden="true">#</a> 并查集</h2><h4 id="_547-省份数量" tabindex="-1"><a class="header-anchor" href="#_547-省份数量" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener noreferrer">547. 省份数量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }
    public void union(int a, int b) {
        p[find(a)] = find(b);
    }
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        p = new int[n];
        for (int i = 0; i &lt; n; i ++ ) p[i] = i;
        int res = n;
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; n; j ++ )
                if (isConnected[i][j] == 1 &amp;&amp; find(i) != find(j)) {
                    union(i, j);
                    res -- ;
                }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_128-最长连续序列" tabindex="-1"><a class="header-anchor" href="#_128-最长连续序列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener noreferrer">128. 最长连续序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, size;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }
    public void union(int a, int b) {
        size[find(b)] += size[find(a)];
        p[find(a)] = find(b);
    }
    public int longestConsecutive(int[] nums) {
        int n = nums.length;
        p = new int[n];
        size = new int[n];
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            p[i] = i;
            map.put(nums[i], i);
        }
        Arrays.fill(size, 1);
        for (int i = 0; i &lt; n; i ++ ) 
            if (map.containsKey(nums[i] + 1)) 
                if (find(map.get(nums[i])) != find(map.get(nums[i] + 1)))
                    union(map.get(nums[i]), map.get(nums[i] + 1));
            
        int res = 0;
        for (int x : size) 
            res = Math.max(res, x);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_684-冗余连接" tabindex="-1"><a class="header-anchor" href="#_684-冗余连接" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener noreferrer">684. 冗余连接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    } 
    public void union(int a, int b) {
        p[find(a)] = p[find(b)];
    }
    public int[] findRedundantConnection(int[][] edges) {
        int n = edges.length;
        p = new int[n + 1];
        for (int i = 0; i &lt;= n; i ++ ) p[i] = i;
        for (int[] e : edges) {
            int a = e[0], b = e[1];
            if (find(a) == find(b)) return e;
            else union(a, b);
        }
        return new int[]{};
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -&gt; List[int]:
        n = len(edges)
        p = [0] * (n + 1)
        def find(x):
            if x != p[x]: p[x] = find(p[x])
            return p[x]
        def union(a, b):
            p[find(a)] = find(b)
         
        for i in range(0, n + 1):
            p[i] = i
        for e in edges:
            a, b = e[0], e[1]
            if find(a) == find(b): return e
            else: union(a, b)
        return []
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1020-飞地的数量" tabindex="-1"><a class="header-anchor" href="#_1020-飞地的数量" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/number-of-enclaves/" target="_blank" rel="noopener noreferrer">1020. 飞地的数量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs&amp;并查集</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p;
    int[][] g;
    int[] dx = new int[]{-1, 0, 1, 0}, dy = new int[]{0, 1, 0, -1};
    int n, m;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]); 
        return p[x];
    }

    public void union(int a, int b) {
        p[find(a)] = find(b);
    }

    public int getIdx(int x, int y) {
        return x * m + y;
    }
    public int numEnclaves(int[][] _g) {
        g = _g;
        n = g.length;
        m = g[0].length;
        p = new int[500 * 500];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                p[getIdx(i, j)] = getIdx(i, j);
            }
        }
        int ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                if (i == 0 || j == 0 || i == n - 1 || j == m - 1) {
                    if (g[i][j] == 1 &amp;&amp; find(getIdx(i, j)) != 0) {
                        dfs(i, j);
                    }
                }
            }
        }

        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                if (g[i][j] == 1 &amp;&amp; find(getIdx(i, j)) != 0) ans ++ ;
            }
        }
        return ans;
    }

    public void dfs(int x, int y) {
        union(getIdx(x, y), 0);
        for (int i = 0; i &lt; 4; i ++ ) {
            int a = x + dx[i], b = y + dy[i];
            if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == 1 &amp;&amp; find(getIdx(a, b)) != 0) {
                dfs(a, b);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//dfs
class Solution {
    int[][] g;
    int n, m;
    public int numEnclaves(int[][] grid) {
        g = grid;
        n = g.length;
        m = g[0].length;
        for (int i = 0; i &lt; n; i ++ ) {
            if (g[i][0] == 1) dfs(i, 0); 
            if (g[i][m - 1] == 1) dfs(i, m - 1);
        }
        for (int i = 0; i &lt; m; i ++ ) {
            if (g[0][i] == 1) dfs(0, i);
            if (g[n - 1][i] == 1) dfs(n - 1, i);
        }
        int ans = 0;
        for (int i = 0; i &lt; n; i ++ ) 
            for (int j = 0; j &lt; m; j ++ ) 
                if (g[i][j] == 1) ans ++ ;
        return ans;
    }
    int[][] dirs = new int[][]{{-1, 0}, {0, 1},{1, 0}, {0, -1}};
    public void dfs(int i, int j) {
        g[i][j] = 0;
        for (int[] d : dirs) {
            int x = i + d[0], y = j + d[1];
            if (x &lt; 0 || x &gt;= n) continue;
            if (y &lt; 0 || y &gt;= m) continue;
            if (g[x][y] != 1) continue;
            dfs(x, y);
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6106-统计无向图中无法互相到达点对数" tabindex="-1"><a class="header-anchor" href="#_6106-统计无向图中无法互相到达点对数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/" target="_blank" rel="noopener noreferrer">6106. 统计无向图中无法互相到达点对数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, size;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]); 
        return p[x];
    }

    public void union(int a, int b) {
        size[find(b)] += size[find(a)];
        p[find(a)] = find(b);
    }
    public long countPairs(int n, int[][] edges) {
        p = new int[n];
        size = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            p[i] = i;
            size[i] = 1;
        }
        for (int[] e : edges) {
            if (find(e[0]) != find(e[1])) {
                union(e[0], e[1]);
            } 
        }
        long ans =  n * (n - 1l);
        //总数减去能互相到达的就是互相不能到达的
        for(int i = 0; i &lt; n; i++ ) if (find(i) == i) ans -= size[i] * (size[i] - 1l);
        return ans &gt;&gt; 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_952-按公因数计算最大组件大小" tabindex="-1"><a class="header-anchor" href="#_952-按公因数计算最大组件大小" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/largest-component-size-by-common-factor/" target="_blank" rel="noopener noreferrer">952. 按公因数计算最大组件大小<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, s;
    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]); 
        return p[x];
    }

    public void union(int a, int b) {
        s[find(b)] += s[find(a)];
        p[find(a)] = find(b);
    }
    public int largestComponentSize(int[] nums) {
        int n = nums.length;
        p = new int[n];
        s = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            p[i] = i;
            s[i] = 1;
        }
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            int x = nums[i];
            for (int j = 1; j * j &lt;= x; j ++ ) {
                if (x % j == 0) {
                    List&lt;Integer&gt; l1 = map.getOrDefault(j, new ArrayList&lt;&gt;());
                    List&lt;Integer&gt; l2 = map.getOrDefault(x / j, new ArrayList&lt;&gt;());
                    if (j &gt; 1) l1.add(i);
                    map.put(j, l1);
                    l2.add(i);
                    map.put(x / j, l2);
                }
            }
        }
        int res = 1;
        for (int k : map.keySet()) {
            List&lt;Integer&gt; list = map.get(k);
            for (int i = 1; i &lt; list.size(); i ++ ) {
                int a = list.get(0), b = list.get(i);
                if (find(a) != find(b))
                    union(a, b);
                res = Math.max(res, s[find(a)]);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_785-判断二分图-2" tabindex="-1"><a class="header-anchor" href="#_785-判断二分图-2" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/is-graph-bipartite/" target="_blank" rel="noopener noreferrer">785. 判断二分图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p;
    public int find(int x) {
        if (x != p[x]) x = find(p[x]);
        return p[x];
    }

    public void union(int a, int b) {
        p[find(a)] = find(b);
    }

    public boolean isBipartite(int[][] g) {
        p = new int[g.length];
        for (int i = 0; i &lt; g.length; i ++ ) p[i] = i;

        for (int i = 0; i &lt; g.length; i ++ ) {
            for (int x : g[i]) {
                if (find(x) == find(i)) return false;
                else union(g[i][0], x);
            }
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_827-最大人工岛" tabindex="-1"><a class="header-anchor" href="#_827-最大人工岛" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/making-a-large-island/" target="_blank" rel="noopener noreferrer">827. 最大人工岛<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, sz;
    int[][] dirs = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int n;
    public int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    public void union(int a, int b) {
        sz[find(b)] += sz[find(a)];
        p[find(a)] = find(b);
    }
    public int get(int x, int y) {
        return x * n + y;
    }
    public int largestIsland(int[][] g) {
        n = g.length;
        int res = 0;
        p = new int[n * n];
        sz = new int[n * n];
        for (int i = 0; i &lt; n * n; i ++ ) {
            p[i] = i;
            sz[i] = 1;
        }
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; n; j ++ )
                if (g[i][j] == 1) {
                    int a = get(i, j);
                    for (int[] d : dirs) {
                        int x = i + d[0], y = j + d[1];
                        int b = get(x, y);
                        if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; g[x][y] == 1)
                            if (find(a) != find(b))
                                union(a, b);
                    }
                    res = Math.max(res, sz[find(a)]);
                }
        for (int i = 0; i &lt; n; i ++ )
            for (int j = 0; j &lt; n; j ++ ) 
                if (g[i][j] == 0) {
                    var set = new HashSet&lt;Integer&gt;();
                    int tot = 1;
                    for (int[] d : dirs) {
                        int x = i + d[0], y = j + d[1];
                        int t = get(x, y);
                        if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) 
                            if (g[x][y] == 1)
                                if (!set.contains(find(t))) {
                            tot += sz[find(t)];
                            set.add(find(t));
                        }
                    }
                    res = Math.max(res, tot);
                }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_695-岛屿的最大面积-1" tabindex="-1"><a class="header-anchor" href="#_695-岛屿的最大面积-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/max-area-of-island/" target="_blank" rel="noopener noreferrer">695. 岛屿的最大面积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, sz;
    int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    int n, m;
    public int get(int x, int y) {
        return x * m + y;
    }
    public int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    public void union(int a, int b) {
        sz[find(b)] += sz[find(a)];
        p[find(a)] = find(b);
    }
    public int maxAreaOfIsland(int[][] g) {
        n = g.length;
        m = g.length;
        p = new int[n * m];
        sz = new int[n * m];
        for (int i = 0; i &lt; n * m; i ++ ) {
            p[i] = i;
            sz[i] = 1;
        }
        for (int i = 0; i &lt; n; i ++ ) 
            for (int j = 0; j &lt; m; j ++ )
                if (g[i][j] == 1) {
                    int a = get(i, j);
                    for (int[] d : dirs) {
                        int x = i + d[0], y = j + d[1];
                        int b = get(x, y);
                        if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt; 0 &amp;&amp; y &lt; m)
                            if (g[x][y] == 1)
                                if (find(a) != find(b))
                                    union(a, b);
                    }
                }
        int res = 0;
        for (int x : sz) res = Math.max(res, x);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_886-可能的二分法-1" tabindex="-1"><a class="header-anchor" href="#_886-可能的二分法-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/possible-bipartition/" target="_blank" rel="noopener noreferrer">886. 可能的二分法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p;
    List&lt;Integer&gt;[] g;

    public int find(int x) {
        if (x != p[x]) p[x] = find(p[x]);
        return p[x];
    }

    public void union(int a, int b) {
        p[find(a)] = find(b);
    }

    public boolean possibleBipartition(int n, int[][] dislikes) {
        p = new int[n + 1];
        g = new List[n + 1];
        Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;());
        for (int i = 0; i &lt;= n; i ++ ) p[i] = i;
        for (int[] e : dislikes) {
            g[e[0]].add(e[1]);
            g[e[1]].add(e[0]);
        }

        for (int i = 1; i &lt;= n; i ++ ) {
            for (int w : g[i]) {
                if (find(w) == find(i)) return false;
                else union(g[i].get(0), w);
            }
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序" aria-hidden="true">#</a> 拓扑排序</h2><h4 id="_207-课程表" tabindex="-1"><a class="header-anchor" href="#_207-课程表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener noreferrer">207. 课程表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean canFinish(int n, int[][] prerequisites) {
        //统计每个点入度
        int[] d = new int[n];
        List&lt;Integer&gt;[] g = new List[n];
        Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;());
        //每个点插入邻接表
        for (int[] e : prerequisites) {
            int b = e[0], a = e[1];
            g[a].add(b);
            d[b] ++ ;
        }
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 0) q.add(i);
        int cnt = 0;
        while (!q.isEmpty()) {
            int t = q.poll();
            cnt ++ ;
            //枚举当前点的所有后继节点
            for (int i : g[t]) {
                if (-- d[i] == 0) q.add(i);
            }
        }
        //如果不等于n说明不存在拓扑序
        return cnt == n;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        g = collections.defaultdict(list)
        d = [0] * numCourses
        for e in prerequisites:
            b, a = e[1], e[0]
            g[a].append(b)
            d[b] += 1
        q = collections.deque([x for x in range(numCourses) if d[x] == 0])
        visit = 0
        while q:
            visit += 1
            cur = q.popleft()
            for v in g[cur]:
                d[v] -= 1
                if d[v] == 0:
                    q.append(v)
        return visit == numCourses
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_210-课程表-ii" tabindex="-1"><a class="header-anchor" href="#_210-课程表-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/course-schedule-ii/" target="_blank" rel="noopener noreferrer">210. 课程表 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] findOrder(int n, int[][] pre) {
        int[] d = new int[n];//每个点的入度
        List&lt;Integer&gt;[] g = new List[n];
        for (int i = 0; i &lt; n; i ++ ) g[i] = new ArrayList&lt;&gt;();
        for (int[] p : pre) {
            int b = p[0], a = p[1];
            d[b] ++ ;
            g[a].add(b);
        }
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 0) q.add(i);
        int[] res = new int[n];
        int idx = 0;
        while (!q.isEmpty()) {
            int cur = q.poll();
            res[idx ++ ] = cur;
            for (int i : g[cur]) 
                if (-- d[i] == 0)
                    q.add(i);
        }
        return idx == n ? res : new int[0];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_802-找到最终的安全状态" tabindex="-1"><a class="header-anchor" href="#_802-找到最终的安全状态" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/find-eventual-safe-states/" target="_blank" rel="noopener noreferrer">802. 找到最终的安全状态<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; eventualSafeNodes(int[][] graph) {
        int n = graph.length;
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        int[] d = new int[n];
        List&lt;List&lt;Integer&gt;&gt; g = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) g.add(new ArrayList&lt;&gt;());
        //拓扑排序找的是入度为0的点，该题找的是出度为0
        //建立反向图
        for (int i = 0; i &lt; n; i ++ ) {
            for (int b : graph[i]) {
                int a = i;
                g.get(b).add(a);
                d[a] ++ ;
            }
        }
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 0) q.add(i);
        while (!q.isEmpty()) {
            int t = q.poll();
            for (int i : g.get(t)) {
                if (-- d[i] == 0) q.add(i);
            }
        }
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 0) ans.add(i);
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_310-最小高度树" tabindex="-1"><a class="header-anchor" href="#_310-最小高度树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-height-trees/" target="_blank" rel="noopener noreferrer">310. 最小高度树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) {
        if (n == 1) return List.of(0);
        List&lt;List&lt;Integer&gt;&gt; g = new ArrayList&lt;&gt;();
        int[] d = new int[n];
        boolean[] st = new boolean[n];
        for (int i = 0; i &lt; n; i ++ ) g.add(new ArrayList&lt;&gt;());
        for (int[] e : edges) {
            int b = e[0], a = e[1];
            g.get(a).add(b);
            g.get(b).add(a);
            d[a] ++ ;
            d[b] ++ ;
        }
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 1) q.add(i);
        int cnt = 0;
        while (cnt &lt; n - 2) {
            int m = q.size();
            cnt += m; 
            for (int i = 0; i &lt; m; i ++ ) {
                int t = q.poll();
                st[t] = true;
                for (int u : g.get(t)) {
                    if (st[u]) continue;
                    if (-- d[u] == 1) q.add(u);
                }
            }
        }
        while (!q.isEmpty()) ans.add(q.poll());
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1462-课程表-iv" tabindex="-1"><a class="header-anchor" href="#_1462-课程表-iv" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/course-schedule-iv/" target="_blank" rel="noopener noreferrer">1462. 课程表 IV<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Boolean&gt; checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {
        List&lt;Boolean&gt; ans = new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; g = new ArrayList&lt;&gt;();
        List&lt;Set&lt;Integer&gt;&gt; pre = new ArrayList&lt;&gt;();
        int[] d = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            g.add(new ArrayList&lt;&gt;());
            pre.add(new HashSet&lt;&gt;());
        }
        for (int[] e : prerequisites) {
            int a = e[0], b = e[1];
            g.get(a).add(b);
            d[b] ++ ;
        }
        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) if (d[i] == 0) q.add(i);
        while (!q.isEmpty()) {
            int t = q.poll();
            for (int u : g.get(t)) {
                pre.get(u).addAll(pre.get(t));
                pre.get(u).add(t);
                if (-- d[u] == 0) q.add(u);
            }
        }
        for (int[] querie : queries) {
            int b = querie[0], a = querie[1];
            ans.add(pre.get(a).contains(b));
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-ii-115-重建序列" tabindex="-1"><a class="header-anchor" href="#剑指-offer-ii-115-重建序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/ur2n8P/" target="_blank" rel="noopener noreferrer">剑指 Offer II 115. 重建序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean sequenceReconstruction(int[] nums, int[][] sequences) {
        int n = nums.length;
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        int[] d = new int[n + 1];//每个点的入度
        List&lt;Integer&gt;[] g = new List[n + 1];
        for (int i = 1; i &lt;= n; i ++ ) 
            g[i] = new ArrayList&lt;&gt;();
        for (int[] s : sequences) {
            for (int i = 0; i &lt; s.length - 1; i ++ ) {
                d[s[i + 1]] ++ ;
                g[s[i]].add(s[i + 1]);
            }
        }
        for (int i = 1; i &lt;= n; i ++ ) 
            if (d[i] == 0) q.add(i);
        int idx = 0;
        while (!q.isEmpty()) {
            if (q.size() &gt; 1) return false;
            int cur = q.poll();
            if (nums[idx ++ ] != cur) return false;
            for (int x : g[cur]) {
                d[x] -- ;
                if (d[x] == 0) q.add(x);
            }
        }
        return idx == n;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2360-图中的最长环" tabindex="-1"><a class="header-anchor" href="#_2360-图中的最长环" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-cycle-in-a-graph/" target="_blank" rel="noopener noreferrer">2360. 图中的最长环<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：拓扑排序找环</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestCycle(int[] p) {
        int n = p.length, res = -1;
        var st = new boolean[n];
        var q = new ArrayDeque&lt;Integer&gt;();//辅助队列
        var d = new int[n];//入度数组
        for (int x : p)
            if (x != -1)
                d[x] ++ ;
        for (int i = 0; i &lt; n; i ++ )
            if (d[i] == 0) {
                q.add(i);
                st[i] = true;
            }
        while (!q.isEmpty()) {
            int t = q.poll();
            int ne = p[t];
            if (ne != -1 &amp;&amp; -- d[ne] == 0) {
                q.add(ne);
                st[ne] = true;
            }
        }

        //剩下的就是环上的点，统计答案
        for (int i = 0; i &lt; n; i ++ ) {
            if (st[i]) continue;//访问过的就跳过
            int j = i, cur = 0;
            while (!st[j]) {
                cur ++ ;
                st[j] = true;
                j = p[j];
            }
            res = Math.max(res, cur);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="贪心" tabindex="-1"><a class="header-anchor" href="#贪心" aria-hidden="true">#</a> 贪心</h2><h4 id="_55-跳跃游戏" tabindex="-1"><a class="header-anchor" href="#_55-跳跃游戏" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener noreferrer">55. 跳跃游戏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        for (int i = 0, j = 0; i &lt; n; i ++ ) {
            if (j &lt; i) return false;
            j = Math.max(j, i + nums[i]);
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_45-跳跃游戏-ii" tabindex="-1"><a class="header-anchor" href="#_45-跳跃游戏-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener noreferrer">45. 跳跃游戏 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        //f[i]表示跳到点i的最小步数。
        int[] f = new int[n];
        for (int i = 1, j = 0; i &lt; n; i ++ ) {
        	//j + nums[j] 跳的距离不到i的时候就可以往后走
            while (j + nums[j] &lt; i) j ++ ;
            f[i] = f[j] + 1;
        }
        return f[n - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_406-根据身高重建队列" tabindex="-1"><a class="header-anchor" href="#_406-根据身高重建队列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener noreferrer">406. 根据身高重建队列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    /**
     * 解题思路：先排序再插入
     * 1.排序规则：按照先H高度降序，K个数升序排序
     * 2.遍历排序后的数组，根据K插入到K的位置上
     *
     * 核心思想：高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求
     * LinkedList:
     *      add(int index, E element) :在此列表中的指定位置插入指定的元素。
     * @param people
     * @return
     */
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);
        LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();
        for (int[] i : people) {
            list.add(i[1], i);
        }
        return list.toArray(new int[list.size()][2]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_134-加油站" tabindex="-1"><a class="header-anchor" href="#_134-加油站" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/gas-station/" target="_blank" rel="noopener noreferrer">134. 加油站<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
    	//rest表示走完后剩余的油量，g为当前油量， st为开始的起点
        int g = 0, st = 0, rest = 0;
        for (int i = 0; i &lt; gas.length; i ++ ) {
            g += gas[i] - cost[i];
            rest += gas[i] - cost[i];;
            if (g &lt; 0) {
                g = 0;
                st = i + 1;
            }
        }
        return rest &lt; 0 ? -1 : st;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2311-小于等于-k-的最长二进制子序列" tabindex="-1"><a class="header-anchor" href="#_2311-小于等于-k-的最长二进制子序列" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/" target="_blank" rel="noopener noreferrer">2311. 小于等于 K 的最长二进制子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestSubsequence(String s, int k) {
        int res = 0, n = s.length();
        long t = 0;
        for (int i = n - 1; i &gt;= 0; i -- ) {
            if (s.charAt(i) == &#39;0&#39;) res ++ ;
            else {     
            	//超过30后此时1 &lt;&lt; 30 大于1e9,之后不用统计1的个数
                if (res &lt;= 30 &amp;&amp; t + (1L &lt;&lt; res) &lt;= k) {
                    t += 1L &lt;&lt; res;
                    res ++ ;
                }
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6105-操作后的最大异或和" tabindex="-1"><a class="header-anchor" href="#_6105-操作后的最大异或和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-xor-after-operations/" target="_blank" rel="noopener noreferrer">6105. 操作后的最大异或和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumXOR(int[] nums) {
        int ans = 0;
        for (int x : nums) ans |= x;
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_871-最低加油次数" tabindex="-1"><a class="header-anchor" href="#_871-最低加油次数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops/" target="_blank" rel="noopener noreferrer">871. 最低加油次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    /*想象成不是只在加油站才能加油，而是只要现在需要油，并且之前有加油站
    还没有加油，那么此时就可以加油。这样一来，如果要使得加油次数最少，那么
    只要加油就加最多的油，为了保证时间效率，这里用堆来维护前面的未用过的加油站
    里的油量。需要加油而没有油时(也就是堆为空)，那么就不能够到达，此时返回-1。
    */
    public int minRefuelStops(int target, int startFuel, int[][] stations) {
        if(stations.length == 0) return startFuel &gt;= target ? 0 :-1;
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2 - o1);
        int sum = startFuel;
        int ans = 0;
        for (int i = 0; i &lt; stations.length; i ++ ) {
            while (sum &lt; stations[i][0]) {
                if (q.isEmpty()) return -1;
                else {
                    sum += q.poll();
                    ans ++ ;
                }
            }
            q.add(stations[i][1]);
        }
        while (sum &lt; target) {
            if (q.isEmpty()) return -1;
            else {
                sum += q.poll();
                ans ++ ;
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_556-下一个更大元素-iii" tabindex="-1"><a class="header-anchor" href="#_556-下一个更大元素-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/next-greater-element-iii/" target="_blank" rel="noopener noreferrer">556. 下一个更大元素 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/*1、从数组末尾往前找，找到 第一个 位置 k，使得 ss[k] &lt;= ss[k - 1]
  2、如果不存在这样的 k，则说明数组是不递增的，直接将数组逆转即可。
  3、如果存在这样的 j，则从末尾找到第一个位置 t &gt; k，使得 nums[t] &gt; nums[k - 1]。
  4、交换 nums[t] 与 nums[k - 1]，然后将数组从 j + 1 到末尾部分逆转(也可以直接sort排序k后面的部分)。
*/
class Solution {
    public int nextGreaterElement(int n) {
        String s = String.valueOf(n);
        char[] ss = s.toCharArray();
        int k = s.length() - 1;
        while (k &gt; 0 &amp;&amp; ss[k] &lt;= ss[k - 1]) k -- ;
        if (k == 0) return -1;
        int t = k;
        while (t + 1 &lt; s.length() &amp;&amp; ss[t + 1] &gt; ss[k - 1]) t ++ ;
        swap(ss, k - 1, t);
        reverse(ss, k, ss.length - 1);
        long ans = 0;
        for (char c : ss) ans = ans * 10 + (c - &#39;0&#39;);
        if (ans &gt; Integer.MAX_VALUE) return -1;
        return (int) ans;
    }
    public void swap(char[] ss, int l, int r) {
        char t = ss[l];
        ss[l] = ss[r];
        ss[r] = t;
    }
    public void reverse(char[] ss, int l, int r) {
        while (l &lt; r) {
            swap(ss, l, r);
            l ++ ;
            r -- ;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_31-下一个排列-1" tabindex="-1"><a class="header-anchor" href="#_31-下一个排列-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener noreferrer">31. 下一个排列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void nextPermutation(int[] nums) {
        int k = nums.length - 1;
        while (k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k -- ;
        if (k == 0) Arrays.sort(nums);
        else {
            int t = k;
            while (t + 1 &lt; nums.length &amp;&amp; nums[t + 1] &gt; nums[k - 1]) t ++ ;
            swap(nums, k - 1, t);
            reverse(nums, k, nums.length - 1);
        }
    }
    public void swap(int[] nums, int l, int r) {
        int t = nums[l];
        nums[l] = nums[r];
        nums[r] = t;
    }
    public void reverse(int[] nums, int l, int r) {
        while (l &lt; r) {
            swap(nums, l, r);
            l ++ ;
            r -- ;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1217-玩筹码" tabindex="-1"><a class="header-anchor" href="#_1217-玩筹码" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/" target="_blank" rel="noopener noreferrer">1217. 玩筹码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    //相当于先把奇数放一起，再把偶数放一起，把少的个数移到多的个数上去
    public int minCostToMoveChips(int[] position) {
        int odd = 0, even = 0;
        for (int p : position) {
            if (p % 2 == 0) odd ++ ;
            else even ++ ;
        }
        return Math.min(odd, even);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6118-最小差值平方和" tabindex="-1"><a class="header-anchor" href="#_6118-最小差值平方和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-sum-of-squared-difference/" target="_blank" rel="noopener noreferrer">6118. 最小差值平方和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//多路归并贪心
class Solution {
    public long minSumSquareDiff(int[] a, int[] b, int k1, int k2) {
        int n = a.length, m = k1 + k2;
        for (int i = 0; i &lt; n; i ++ ) a[i] = Math.abs(a[i] - b[i]);

        //二分求出切割线
        int l = 0, r = (int)1e5;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            long sum = 0;
            for (int x : a) if (x &gt; mid) sum += x - mid;
            if (sum &lt;= m) r = mid;
            else l = mid + 1;
        }

        //求出剩余的操作数
        int sum = 0;
        for (int x : a) if (x &gt; r) sum += x - r;
        m -= sum;
        
        //计算答案
        long ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            //如果比分割线阈值大
            if (a[i] &gt;= r) {
                //在操作数剩余情况下可以进一步切割
                if (r &gt; 0 &amp;&amp; m &gt; 0) {
                    ans += (long)(r - 1) * (r - 1);
                    m -- ;
                }
                else ans += (long)r * r; 
            } else {
                ans += (long)a[i] * a[i];
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_757-设置交集大小至少为2" tabindex="-1"><a class="header-anchor" href="#_757-设置交集大小至少为2" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/set-intersection-size-at-least-two/" target="_blank" rel="noopener noreferrer">757. 设置交集大小至少为2<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int intersectionSizeTwo(int[][] intervals) {
        //将数组按interval[1]升序列，interval[0]降序排列
    	//这是因为后续的线段的右端点大于当前线段右端点，如果
    	//选择一个当前线段前面位置上的点能被后面的线段利用，
    	//当前线段的右端点也一定能被后面的线段利用，即不会得到更坏的结果
        Arrays.sort(intervals, (a, b) -&gt; {
            return a[1] != b[1] ? a[1] - b[1] : b[0] - a[0];
        });
        int cnt = 0;
        int v1 = -1, v2 = -1;
        //基于上述思想，我们也知道我们集合S中的点也是按照升序加入进来的，
        //接下来我们考虑已经加入的点集合S共cnt个点中最后两个点S[cnt - 1],S[cnt]和新线段interval的关系
        for (int[] interval : intervals) {
            //如果A[0] &gt; S[cnt],说明当前已经选择的点必然不能不被A利用，所以我们要将A中最后两个点加入集合S中
            if (interval[0] &gt; v2) {
                v1 = interval[1] - 1;
                v2 = interval[1];
                cnt += 2;
            } else if (interval[0] &gt; v1) {
            //如果A[0] &lt;= S[cnt - 1]，那么说明S[cnt - 1],S[cnt]都在线段A中，我们无需加入额外的点。
			//否则的话S[cnt - 1] &lt; A[0] &lt;= S[cnt]，这时候
			//S[cnt]在线段A中，我们只需要将A中最后一个端点加入进来就可以了
                v1 = v2;
                v2 = interval[1];
                cnt ++ ;
            }
        }
        return cnt;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1675-数组的最小偏移量" tabindex="-1"><a class="header-anchor" href="#_1675-数组的最小偏移量" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimize-deviation-in-array/" target="_blank" rel="noopener noreferrer">1675. 数组的最小偏移量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumDeviation(int[] nums) {
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        for (int x : nums) {
            if (x % 2 == 1) x *= 2;
            set.add(x);
        }
        int res = set.last() - set.first();
        while (set.last() % 2 == 0) {
            int x = set.last();
            set.remove(x);
            set.add(x / 2);
            res = Math.min(res, set.last() - set.first());
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumDeviation(int[] nums) {
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);
        int min = Integer.MAX_VALUE;
        Set&lt;Integer&gt; set = new HashSet();
        for (int x : nums) {
            if (x % 2 != 0) x *= 2;
            set.add(x);
            min = Math.min(min, x);
        }
        for (int x : set) q.add(x);
        int max = q.peek();
        int res = max - min;
        while (!q.isEmpty() &amp;&amp; q.peek() % 2 == 0) {
            int x = q.poll();
            x /= 2;
            min = Math.min(min, x);
            q.add(x);
            if (!q.isEmpty()) max = q.peek();
            res = Math.min(res, max - min);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6174-任务调度器-ii" tabindex="-1"><a class="header-anchor" href="#_6174-任务调度器-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/task-scheduler-ii/" target="_blank" rel="noopener noreferrer">6174. 任务调度器 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long taskSchedulerII(int[] q, int space) {
        int n = q.length;
        long res = 0;
        Map&lt;Integer, Long&gt; map = new HashMap&lt;&gt;();
        for (int x : q) {
            res ++ ;
            if (!map.containsKey(x))
                map.put(x, res);
            else {
                if (res - map.get(x) &lt;= space) 
                    res = map.get(x) + space + 1;
                map.put(x, res);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6144-将数组排序的最少替换次数" tabindex="-1"><a class="header-anchor" href="#_6144-将数组排序的最少替换次数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/" target="_blank" rel="noopener noreferrer">6144. 将数组排序的最少替换次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minimumReplacement(int[] nums) {
        long res = 0;
        int n = nums.length, last = nums[n - 1];
        for (int i = n - 2; i &gt;= 0; i -- ) {
            if (nums[i] &gt; last) {
            	//拆的次数
                int x = (nums[i] + last - 1) / last;
                res += x - 1;
                //拆出来的最小数，nums[i]/(拆的次数)向下取整
                last = nums[i] / x;
            } else {
                last = nums[i];
            }
        }
        return res;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_179-最大数" tabindex="-1"><a class="header-anchor" href="#_179-最大数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/largest-number/" target="_blank" rel="noopener noreferrer">179. 最大数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：排序贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] arr = new String[n];
        StringBuilder res = new StringBuilder();
        for (int i = 0; i &lt; n; i ++ )
            arr[i] = String.valueOf(nums[i]);
        Arrays.sort(arr, (o1, o2) -&gt; (o2 + o1).compareTo(o1 + o2));
        for (String x : arr) 
            res.append(x);
        if (res.charAt(0) == &#39;0&#39;) return &quot;0&quot;;
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_316-去除重复字母" tabindex="-1"><a class="header-anchor" href="#_316-去除重复字母" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/remove-duplicate-letters/" target="_blank" rel="noopener noreferrer">316. 去除重复字母<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String removeDuplicateLetters(String s) {
        StringBuilder res = new StringBuilder();
        boolean[] st = new boolean[128];
        int[] last = new int[128];
        for (int i = 0; i &lt; s.length(); i ++ ) last[s.charAt(i)] = i;
        for (int i = 0; i &lt; s.length(); i ++ ) {
            char x = s.charAt(i);
            if (st[x]) continue;
            while (res.length() &gt; 0 &amp;&amp; res.charAt(res.length() - 1) &gt; x &amp;&amp; last[res.charAt(res.length() - 1)] &gt; i) {
                st[res.charAt(res.length() - 1)] = false;
                res.deleteCharAt(res.length() - 1);
            }
            res.append(x);
            st[x] = true;
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_435-无重叠区间" tabindex="-1"><a class="header-anchor" href="#_435-无重叠区间" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/non-overlapping-intervals/" target="_blank" rel="noopener noreferrer">435. 无重叠区间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：排序&amp;贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -&gt; a[1] - b[1]);
        int res = 0;
        for (int i = 1, pre = intervals[0][1]; i &lt; intervals.length; i ++ ) {
            int l = intervals[i][0], r = intervals[i][1];
            if (l &lt; pre) {
                res ++ ;
            } else pre = r;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_330-按要求补齐数组" tabindex="-1"><a class="header-anchor" href="#_330-按要求补齐数组" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/patching-array/" target="_blank" rel="noopener noreferrer">330. 按要求补齐数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minPatches(int[] nums, int n) {
        int res = 0;
        //记录可以遍历到的最大数
        long s = 0;
        int pos = 0;
        //遍历目标数
        for (long i = 1; i &lt;= n; ) {
            if (pos &gt;= nums.length || i &lt; nums[pos]) {
                res ++ ;
                s += i;
            } else {
                s += nums[pos];
                pos ++ ;
            }
            i = s + 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_321-拼接最大数" tabindex="-1"><a class="header-anchor" href="#_321-拼接最大数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/create-maximum-number/" target="_blank" rel="noopener noreferrer">321. 拼接最大数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int n = nums1.length, m = nums2.length;
        int[] res = new int[k];
        for (int s = Math.max(0, k - m); s &lt;= Math.min(n, k);  s ++ ) {
            int[] a = select(nums1, s);
            int[] b = select(nums2, k - s);
            int[] c = merge(a, b);
            if (greater(c, 0, res, 0)) res = c;
        }
        return res;
    }

    public int[] merge(int[] a, int[] b) {
        int i = 0, j = 0, k = 0;
        int[] res = new int[a.length + b.length];
        while (i &lt; a.length &amp;&amp; j &lt; b.length) {
            if (greater(a, i, b, j)) res[k ++ ] = a[i ++ ];
            else res[k ++ ] = b[j ++ ];
            //System.out.println(res[k - 1]);
        }
        while (i &lt; a.length) res[k ++ ] = a[i ++ ];
        while (j &lt; b.length) res[k ++ ] = b[j ++ ];
        return res;
    }

    public int[] select(int[] arr, int k) {
        int[] stack = new int[k];
        int n = arr.length;
        int tt = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            int x = arr[i];
            //当前选择的数+后面能选的数大于k才去删除
            while (tt &gt; 0 &amp;&amp; stack[tt - 1] &lt; x &amp;&amp; tt + n - i &gt; k) tt -- ;
            if (tt &lt; k) stack[tt ++ ] = x; 
        }
        return stack;
    }
	//数组的比较方法
    public boolean greater(int[] a, int i, int[] b, int j) {
        int n = a.length, m = b.length;
        while (i &lt; n &amp;&amp; j &lt; m &amp;&amp; a[i] == b[j]) {
            i ++ ;
            j ++ ;
        }
        if (j == m || (i &lt; n &amp;&amp; a[i] &gt; b[j])) return true;
        return false;
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_452-用最少数量的箭引爆气球" tabindex="-1"><a class="header-anchor" href="#_452-用最少数量的箭引爆气球" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener noreferrer">452. 用最少数量的箭引爆气球<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：排序贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findMinArrowShots(int[][] p) {
        Arrays.sort(p, (a, b) -&gt; {
            return a[1] &lt; b[1] ? -1 : 1;
        });
        int res = 1, last = p[0][1];
        for (int i = 1; i &lt; p.length; i ++ ) {
            if (last &lt; p[i][0]) {
                res ++ ;
                last = p[i][1];
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_632-最小区间" tabindex="-1"><a class="header-anchor" href="#_632-最小区间" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener noreferrer">632. 最小区间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;优先队列</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] smallestRange(List&lt;List&lt;Integer&gt;&gt; nums) {
        int[] res = new int[]{(int)-1e5, (int)1e5};
        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(a[0], b[0]));
        int max_r = 0;
        for (int i = 0; i &lt; nums.size(); i ++ ) {
            q.add(new int[]{nums.get(i).get(0), i, 0}); 
            max_r = Math.max(max_r, nums.get(i).get(0));
        }
        
        while (!q.isEmpty()) {
            int[] t = q.poll();
            int l = t[0], r = max_r;
            if (res[1] - res[0] &gt; r - l) res = new int[]{l, r};
            int i = t[1], j = t[2] + 1;
            if (j &lt; nums.get(i).size()) {
                int x = nums.get(i).get(j);
                q.add(new int[]{x, i, j});
                max_r = Math.max(max_r, x);
            } else break;
        }
        
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_738-单调递增的数字" tabindex="-1"><a class="header-anchor" href="#_738-单调递增的数字" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/monotone-increasing-digits/" target="_blank" rel="noopener noreferrer">738. 单调递增的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    /*
    * 从右往左扫，若当前位比前一位小，将该位及其后边设为9，前一位减一
     */
    public int monotoneIncreasingDigits(int n) {
        char[] s = String.valueOf(n).toCharArray();
        int j = s.length;
        for (int i = s.length - 1; i &gt; 0; i -- ) {
            if (s[i] &lt; s[i - 1]) {
                j = i;
                s[i - 1] -- ;
            }
        } 
        for (int i = j; i &lt; s.length; i ++ ) s[i] = &#39;9&#39;;
        return Integer.parseInt(new String(s));
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_646-最长数对链" tabindex="-1"><a class="header-anchor" href="#_646-最长数对链" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener noreferrer">646. 最长数对链<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findLongestChain(int[][] p) {
        Arrays.sort(p, (a, b) -&gt; a[1] - b[1]);
        int res = 1, b = p[0][1];
        for (int i = 0; i &lt; p.length; i ++ ) 
            if (p[i][0] &gt; b) {
                res ++ ;
                b = p[i][1];
            }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1386-安排电影院座位" tabindex="-1"><a class="header-anchor" href="#_1386-安排电影院座位" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/cinema-seat-allocation/" target="_blank" rel="noopener noreferrer">1386. 安排电影院座位<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;位运算&amp;哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxNumberOfFamilies(int n, int[][] rs) {
        n &lt;&lt;= 1;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; rs.length; i ++ ) 
            map.put(rs[i][0], map.getOrDefault(rs[i][0], 0) | (1 &lt;&lt; rs[i][1] - 1));
        for (int state : map.values()) {
            if ((state &amp; 510) == 0) continue;
            else if ((state &amp; 30) == 0||(state &amp; 120) == 0||(state &amp; 480) == 0) n -- ;
            else n -= 2;
        }
        return n;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_857-雇佣-k-名工人的最低成本" tabindex="-1"><a class="header-anchor" href="#_857-雇佣-k-名工人的最低成本" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/" target="_blank" rel="noopener noreferrer">857. 雇佣 K 名工人的最低成本<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public double mincostToHireWorkers(int[] qs, int[] ws, int k) {
        int n = qs.length;
        List&lt;Pair&lt;Double, Integer&gt;&gt; ds = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ )
            ds.add(new Pair&lt;&gt;(ws[i] * 1.0 / qs[i], i));
        Collections.sort(ds, (a, b) -&gt; {
            if (a.getKey() == b.getKey()) return 0;
            else return a.getKey() &gt; b.getKey() ? 1 : -1;
        });
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);
        double res = 1e18;
        for (int i = 0, tot = 0; i &lt; n; i ++ ) {
            int cur = qs[ds.get(i).getValue()];
            tot += cur;
            q.add(cur);
            if (q.size() &gt; k) tot -= q.poll();
            if (q.size() == k) res = Math.min(res, ds.get(i).getKey() * tot);
        } 
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2182-构造限制重复的字符串" tabindex="-1"><a class="header-anchor" href="#_2182-构造限制重复的字符串" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-string-with-repeat-limit/" target="_blank" rel="noopener noreferrer">2182. 构造限制重复的字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String repeatLimitedString(String s, int repeatLimit) {
        var map = new int[26];
        for (char c : s.toCharArray()) map[c - &#39;a&#39;] ++ ;
        var res = new StringBuilder();
        for (int i = 25; i &gt;= 0; i -- ) {
            while (map[i] &gt; 0) {
                int min = Math.min(map[i], repeatLimit);
                map[i] -= min;
                while (min -- &gt; 0) res.append((char)(i + &#39;a&#39;));
                if (map[i] == 0) break;
                int k = i - 1;
                while (k &gt;= 0 &amp;&amp; map[k] == 0) k -- ;
                if (k &lt; 0) break;
                else {
                    map[k] -- ;
                    res.append((char)(k + &#39;a&#39;));
                }
            }
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="位运算" tabindex="-1"><a class="header-anchor" href="#位运算" aria-hidden="true">#</a> 位运算</h2><h4 id="剑指-offer-56-i-数组中数字出现的次数" tabindex="-1"><a class="header-anchor" href="#剑指-offer-56-i-数组中数字出现的次数" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 56 - I. 数组中数字出现的次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] singleNumbers(int[] nums) {
        int t = 0;
        int n = nums.length;
        for (int i : nums) t ^= i;
        //得到最低为的1，从而进行分组
        int flag = t &amp; (-t);
        int res = 0;
        for (int i : nums) if ((flag &amp; i) != 0) res ^= i;
        //利用自反得到另一个答案
        return new int[]{res, t ^ res};
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剑指-offer-65-不用加减乘除做加法" tabindex="-1"><a class="header-anchor" href="#剑指-offer-65-不用加减乘除做加法" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener noreferrer">剑指 Offer 65. 不用加减乘除做加法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int add(int a, int b) {
        /*
        1、我们发现按位加法（不进位）分四种情况 1 + 1 = 0, 0 + 0 = 0,1 + 0 = 1,
            0 + 1 = 1 刚好与位运算的异或运算结果相同。
        2、进位值1 + 1 = 1,0 + 0 = 0,1 + 0 = 1,0 + 1 = 1 刚好与我们位运算的与运算结果相同。
        进位值需要向前进一位，与位运算左移运算符结果相同。
        3、再接着用代替后的运算方式继续运算 1000 + 01110
        第一位0 ^ 0 = 0, 第二位 0 ^ 1 = 1,第三位 0 ^ 1 = 1,第四位 1 ^ 1 = 0，第五位 0 ^ 0 = 0，结果为 00110
        进位（1）0（个位不需进位），进位（2）0 与 0 = 0,进位（3）0 与 1 = 0,进位（4）0 与 1 = 0,进位（5）
        1 与 1 = 1,结果为 10000
        继续计算 00110 + 10000（省略计算过程）
        得到 10110 与 00000 结果位 10110 （22）
         */
        while (b != 0) {
            var c = a ^ b;
            b = (a &amp; b) &lt;&lt; 1;
            a = c;
        }
        return a;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_231-2-的幂" tabindex="-1"><a class="header-anchor" href="#_231-2-的幂" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/power-of-two/" target="_blank" rel="noopener noreferrer">231. 2 的幂<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//lowbit运算
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n &gt; 0 &amp;&amp; (n &amp; -n) == n;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_136-只出现一次的数字" tabindex="-1"><a class="header-anchor" href="#_136-只出现一次的数字" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/single-number/" target="_blank" rel="noopener noreferrer">136. 只出现一次的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：位运算</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int singleNumber(int[] nums) {
        for (int i = 1; i &lt; nums.length; i ++ ) 
            nums[0] ^= nums[i];
        return nums[0];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_491-递增子序列-1" tabindex="-1"><a class="header-anchor" href="#_491-递增子序列-1" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/increasing-subsequences/" target="_blank" rel="noopener noreferrer">491. 递增子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二进制枚举&amp;哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {
        int n = nums.length;
        Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
        out:for (int k = 0; k &lt;= 1 &lt;&lt; n; k ++ ) {
            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();
            for (int i = 0, pre = -101; i &lt; n; i ++ ) {
                if ((k &gt;&gt; i &amp; 1) != 0) {
                    if (nums[i] &lt; pre) continue out;
                    else {
                        pre = nums[i];
                        temp.add(nums[i]);
                    }
                }
            }
            if (temp.size() &gt;= 2) set.add(new ArrayList&lt;&gt;(temp));
        }
        return new ArrayList&lt;&gt;(set);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_201-数字范围按位与" tabindex="-1"><a class="header-anchor" href="#_201-数字范围按位与" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener noreferrer">201. 数字范围按位与<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int rangeBitwiseAnd(int n, int m) {
        var res = 0;
        for (int i = 30; i &gt;= 0; i -- ) {
            if ((n &gt;&gt; i &amp; 1) != (m &gt;&gt; i &amp; 1)) break;
            if ((n &gt;&gt; i &amp; 1) == 1) res += 1 &lt;&lt; i;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_137-只出现一次的数字-ii" tabindex="-1"><a class="header-anchor" href="#_137-只出现一次的数字-ii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/single-number-ii/" target="_blank" rel="noopener noreferrer">137. 只出现一次的数字 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int singleNumber(int[] nums) {
        var res = 0;
        for (var i = 0; i &lt; 32; i ++ ) {
            var counter = 0;
            for (var x : nums)
                counter += (x &gt;&gt; i) &amp; 1;
            res += (counter % 3) &lt;&lt; i;
        }
        return res;   
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        res = 0
        for i in range(32):
            counter = sum((x &gt;&gt; i &amp; 1) for x in nums)
            if counter % 3:
                # 这里需要对最高位特殊判断
                if i == 31:
                    res -= 1 &lt;&lt; i
                else:
                    res += 1 &lt;&lt; i
        return res
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_260-只出现一次的数字-iii" tabindex="-1"><a class="header-anchor" href="#_260-只出现一次的数字-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/single-number-iii/" target="_blank" rel="noopener noreferrer">260. 只出现一次的数字 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] singleNumber(int[] nums) {
        var xor = 0;
        for (int x : nums)
            xor ^= x;
        var k = xor &amp; -xor;
        int num1 = 0, num2 = 0;
        for (int x : nums) {
            if ((x &amp; k) == 0)
                num1 ^= x;
            else 
                num2 ^= x;
        }
        return new int[]{num1, num2};
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; List[int]:
        xor = 0
        for x in nums:
            xor ^= x
        k = xor &amp; -xor
        a, b = 0, 0
        for x in nums:
            if x &amp; k: a ^= x
            else: b ^= x
        return [a, b]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="每日一题系列" tabindex="-1"><a class="header-anchor" href="#每日一题系列" aria-hidden="true">#</a> 每日一题系列</h2><h4 id="_500-键盘行" tabindex="-1"><a class="header-anchor" href="#_500-键盘行" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener noreferrer">500. 键盘行<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.1</p><h4 id="_575-分糖果" tabindex="-1"><a class="header-anchor" href="#_575-分糖果" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/distribute-candies/" target="_blank" rel="noopener noreferrer">575. 分糖果<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.8</p><h4 id="_299-猜数字游戏-1" tabindex="-1"><a class="header-anchor" href="#_299-猜数字游戏-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener noreferrer">299. 猜数字游戏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.13</p><h4 id="_520-检测大写字母-1" tabindex="-1"><a class="header-anchor" href="#_520-检测大写字母-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener noreferrer">520. 检测大写字母<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.15</p><h4 id="_319-灯泡开关-1" tabindex="-1"><a class="header-anchor" href="#_319-灯泡开关-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/bulb-switcher/" target="_blank" rel="noopener noreferrer">319. 灯泡开关<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>11.29</p><h4 id="_786-第-k-个最小的素数分数" tabindex="-1"><a class="header-anchor" href="#_786-第-k-个最小的素数分数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/" target="_blank" rel="noopener noreferrer">786. 第 K 个最小的素数分数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_400-第-n-位数字" tabindex="-1"><a class="header-anchor" href="#_400-第-n-位数字" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/nth-digit/" target="_blank" rel="noopener noreferrer">400. 第 N 位数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1005-k-次取反后最大化的数组和" tabindex="-1"><a class="header-anchor" href="#_1005-k-次取反后最大化的数组和" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener noreferrer">1005. K 次取反后最大化的数组和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_383-赎金信" tabindex="-1"><a class="header-anchor" href="#_383-赎金信" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener noreferrer">383. 赎金信<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_372-超级次方" tabindex="-1"><a class="header-anchor" href="#_372-超级次方" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/super-pow/" target="_blank" rel="noopener noreferrer">372. 超级次方<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1816-截断句子-1" tabindex="-1"><a class="header-anchor" href="#_1816-截断句子-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/truncate-sentence/" target="_blank" rel="noopener noreferrer">1816. 截断句子<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1034-边界着色-1" tabindex="-1"><a class="header-anchor" href="#_1034-边界着色-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/coloring-a-border/" target="_blank" rel="noopener noreferrer">1034. 边界着色<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>dfs + flood fill</p><h4 id="_748-最短补全词-1" tabindex="-1"><a class="header-anchor" href="#_748-最短补全词-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/shortest-completing-word/" target="_blank" rel="noopener noreferrer">748. 最短补全词<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_911-在线选举" tabindex="-1"><a class="header-anchor" href="#_911-在线选举" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/online-election/" target="_blank" rel="noopener noreferrer">911. 在线选举<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_807-保持城市天际线" tabindex="-1"><a class="header-anchor" href="#_807-保持城市天际线" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/" target="_blank" rel="noopener noreferrer">807. 保持城市天际线<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_630-课程表-iii" tabindex="-1"><a class="header-anchor" href="#_630-课程表-iii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/course-schedule-iii/" target="_blank" rel="noopener noreferrer">630. 课程表 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1518-换酒问题" tabindex="-1"><a class="header-anchor" href="#_1518-换酒问题" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/water-bottles/" target="_blank" rel="noopener noreferrer">1518. 换酒问题<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_997-找到小镇的法官" tabindex="-1"><a class="header-anchor" href="#_997-找到小镇的法官" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-the-town-judge/" target="_blank" rel="noopener noreferrer">997. 找到小镇的法官<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1705-吃苹果的最大数目" tabindex="-1"><a class="header-anchor" href="#_1705-吃苹果的最大数目" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/" target="_blank" rel="noopener noreferrer">1705. 吃苹果的最大数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_825-适龄的朋友" tabindex="-1"><a class="header-anchor" href="#_825-适龄的朋友" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/" target="_blank" rel="noopener noreferrer">825. 适龄的朋友<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>排序 + 双指针</p><h4 id="_1995-统计特殊四元组-1" tabindex="-1"><a class="header-anchor" href="#_1995-统计特殊四元组-1" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/count-special-quadruplets/" target="_blank" rel="noopener noreferrer">1995. 统计特殊四元组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>哈希</p><h4 id="_846-一手顺子" tabindex="-1"><a class="header-anchor" href="#_846-一手顺子" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/hand-of-straights/" target="_blank" rel="noopener noreferrer">846. 一手顺子<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>堆 + 哈希计数</p><h4 id="_507-完美数" tabindex="-1"><a class="header-anchor" href="#_507-完美数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/perfect-number/" target="_blank" rel="noopener noreferrer">507. 完美数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>缩小枚举范围</p><h4 id="_2022-将一维数组转变成二维数组" tabindex="-1"><a class="header-anchor" href="#_2022-将一维数组转变成二维数组" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/" target="_blank" rel="noopener noreferrer">2022. 将一维数组转变成二维数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1185-一周中的第几天" tabindex="-1"><a class="header-anchor" href="#_1185-一周中的第几天" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/day-of-the-week/" target="_blank" rel="noopener noreferrer">1185. 一周中的第几天<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_89-格雷编码" tabindex="-1"><a class="header-anchor" href="#_89-格雷编码" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/gray-code/" target="_blank" rel="noopener noreferrer">89. 格雷编码<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1614-括号的最大嵌套深度" tabindex="-1"><a class="header-anchor" href="#_1614-括号的最大嵌套深度" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/" target="_blank" rel="noopener noreferrer">1614. 括号的最大嵌套深度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1576-替换所有的问号" tabindex="-1"><a class="header-anchor" href="#_1576-替换所有的问号" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/" target="_blank" rel="noopener noreferrer">1576. 替换所有的问号<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1629-按键持续时间最长的键" tabindex="-1"><a class="header-anchor" href="#_1629-按键持续时间最长的键" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/slowest-key/" target="_blank" rel="noopener noreferrer">1629. 按键持续时间最长的键<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_334-递增的三元子序列" tabindex="-1"><a class="header-anchor" href="#_334-递增的三元子序列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener noreferrer">334. 递增的三元子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_747-至少是其他数字两倍的最大数" tabindex="-1"><a class="header-anchor" href="#_747-至少是其他数字两倍的最大数" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener noreferrer">747. 至少是其他数字两倍的最大数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_373-查找和最小的k对数字" tabindex="-1"><a class="header-anchor" href="#_373-查找和最小的k对数字" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener noreferrer">373. 查找和最小的K对数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_382-链表随机节点" tabindex="-1"><a class="header-anchor" href="#_382-链表随机节点" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/linked-list-random-node/" target="_blank" rel="noopener noreferrer">382. 链表随机节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_219-存在重复元素-ii" tabindex="-1"><a class="header-anchor" href="#_219-存在重复元素-ii" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener noreferrer">219. 存在重复元素 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p>滑动窗口 + 哈希表</p><h4 id="_2029-石子游戏-ix" tabindex="-1"><a class="header-anchor" href="#_2029-石子游戏-ix" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/stone-game-ix/" target="_blank" rel="noopener noreferrer">2029. 石子游戏 IX<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1332-删除回文子序列" tabindex="-1"><a class="header-anchor" href="#_1332-删除回文子序列" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/" target="_blank" rel="noopener noreferrer">1332. 删除回文子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_2034-股票价格波动" tabindex="-1"><a class="header-anchor" href="#_2034-股票价格波动" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/stock-price-fluctuation/" target="_blank" rel="noopener noreferrer">2034. 股票价格波动<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_1763-最长的美好子字符串" tabindex="-1"><a class="header-anchor" href="#_1763-最长的美好子字符串" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/longest-nice-substring/" target="_blank" rel="noopener noreferrer">1763. 最长的美好子字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code> public String longestNiceSubstring(String s) {
        int n = s.length();
        String ans = &quot;&quot;;
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                if (j - i + 1 &gt; ans.length() &amp;&amp; check(s.substring(i, j + 1))) ans = s.substring(i, j + 1);
            }
        }
        return ans;
    }
    boolean check(String s) {
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();
        for (char c : s.toCharArray()) set.add(c);
        for (char c : s.toCharArray()) {
            char a = Character.toLowerCase(c), b = Character.toUpperCase(c);
            if (!set.contains(a) || !set.contains(b)) return false;
        }
        return true;
    }

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2000-反转单词前缀" tabindex="-1"><a class="header-anchor" href="#_2000-反转单词前缀" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/reverse-prefix-of-word/" target="_blank" rel="noopener noreferrer">2000. 反转单词前缀<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><h4 id="_479-最大回文数乘积" tabindex="-1"><a class="header-anchor" href="#_479-最大回文数乘积" aria-hidden="true">#</a> <a href="https://leetcode-cn.com/problems/largest-palindrome-product/" target="_blank" rel="noopener noreferrer">479. 最大回文数乘积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int largestPalindrome(int n) {
        if (n == 1) return 9;
        int max = (int)Math.pow(10, n) - 1;
        for (int i = max; i &gt;= 0; i -- ) {
            String s = String.valueOf(i);
            int m = s.length();
            //枚举回文串前半部分
            for (int j = m - 1; j &gt;= 0; j -- ) s += String.valueOf(s.charAt(j));
            long num = Long.parseLong(s);
            //检查回文串是否能够分解
            for (long j = max; j * j &gt;= num; j -- ) 
                if (num % j == 0) return (int)(num % 1337);
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int largestPalindrome(int n) {
        if (n == 1) return 9;
        int max = (int)Math.pow(10,n) - 1;
        for (int i = max; i &gt;= 0; i -- ) {
            long num = i, t = i;
            while (t != 0) {
                num = num * 10 + t % 10;
                t /= 10;
            }
            for (long j = max; j * j &gt;= num; j --) {
                if (num % j == 0) return (int)(num % 1337);
            }
        }
        return -1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/q1061709994/blog/edit/main/demo/src/posts/article1.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/10/30 10:56:49</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1061709994@qq.com">huan</span><!--]--><!--]--></div></footer><nav class="page-nav"><!----><a href="/blog/posts/article2.html" class="nav-link next" aria-label="周赛总结"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">周赛总结<span class="icon iconfont icon-article"></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">主题: VuePress Theme Hope</div><div class="copyright">Copyright © 2022 huan</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.c628af9c.js" defer></script>
  </body>
</html>
