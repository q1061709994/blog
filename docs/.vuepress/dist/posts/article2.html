<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.49" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://gitee.com/paramhh/blog/blog/posts/article2.html"><meta property="og:site_name" content="Huan"><meta property="og:title" content="周赛总结"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-09T16:26:35.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="huan"><meta property="article:tag" content="数据结构与算法"><meta property="article:published_time" content="2022-01-02T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-09T16:26:35.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="icon" type="image/x-icon" href="/blog/favicon.ico"><title>周赛总结 | Huan</title><meta name="description" content="a blog project">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.4f94a94d.css">
    <link rel="modulepreload" href="/blog/assets/app.a2846b5d.js"><link rel="modulepreload" href="/blog/assets/article2.html.554fc140.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/blog/assets/article2.html.70c0192b.js"><link rel="prefetch" href="/blog/assets/index.html.9c447e23.js"><link rel="prefetch" href="/blog/assets/slide.html.33f7fd47.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.478e68da.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.5845817b.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.bee47095.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.0a189fcb.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.bc1d9285.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.9a32eb23.js"><link rel="prefetch" href="/blog/assets/index.html.2ec11399.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.5d0e8758.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.3ae7ccdc.js"><link rel="prefetch" href="/blog/assets/Database.html.f7d02564.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.c414cb5f.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.7125b5b0.js"><link rel="prefetch" href="/blog/assets/disable.html.4cbf4800.js"><link rel="prefetch" href="/blog/assets/encrypt.html.1cf0d70f.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.004b5c85.js"><link rel="prefetch" href="/blog/assets/markdown.html.0e42ccb8.js"><link rel="prefetch" href="/blog/assets/network.html.0ef818e7.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.4a386fdc.js"><link rel="prefetch" href="/blog/assets/page.html.84b9b987.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.53933768.js"><link rel="prefetch" href="/blog/assets/index.html.3ed5b432.js"><link rel="prefetch" href="/blog/assets/article1.html.b4d72772.js"><link rel="prefetch" href="/blog/assets/article10.html.f8ebffab.js"><link rel="prefetch" href="/blog/assets/article11.html.54fdb992.js"><link rel="prefetch" href="/blog/assets/article12.html.f2bac685.js"><link rel="prefetch" href="/blog/assets/article3.html.9563175d.js"><link rel="prefetch" href="/blog/assets/article9.html.437e5876.js"><link rel="prefetch" href="/blog/assets/index.html.9b03be0d.js"><link rel="prefetch" href="/blog/assets/article3.html.60041713.js"><link rel="prefetch" href="/blog/assets/article4.html.86610346.js"><link rel="prefetch" href="/blog/assets/article5.html.499731b4.js"><link rel="prefetch" href="/blog/assets/article6.html.a37396bc.js"><link rel="prefetch" href="/blog/assets/article7.html.29f87944.js"><link rel="prefetch" href="/blog/assets/article8.html.b3b1820a.js"><link rel="prefetch" href="/blog/assets/716-717.html.75c61e43.js"><link rel="prefetch" href="/blog/assets/718-719.html.1da615d5.js"><link rel="prefetch" href="/blog/assets/720-721.html.0f69e48b.js"><link rel="prefetch" href="/blog/assets/722-723.html.3683dfb8.js"><link rel="prefetch" href="/blog/assets/724-725.html.1d9738cd.js"><link rel="prefetch" href="/blog/assets/726-727.html.c6f9232d.js"><link rel="prefetch" href="/blog/assets/728-729.html.4dcf8beb.js"><link rel="prefetch" href="/blog/assets/730-731.html.dccf298e.js"><link rel="prefetch" href="/blog/assets/801-805.html.7e042aef.js"><link rel="prefetch" href="/blog/assets/806-809.html.2b557dbd.js"><link rel="prefetch" href="/blog/assets/810-811.html.521de7f2.js"><link rel="prefetch" href="/blog/assets/812-813.html.79692757.js"><link rel="prefetch" href="/blog/assets/815-816.html.76ef2d02.js"><link rel="prefetch" href="/blog/assets/404.html.6b76a52b.js"><link rel="prefetch" href="/blog/assets/index.html.61027943.js"><link rel="prefetch" href="/blog/assets/index.html.64d8fa7e.js"><link rel="prefetch" href="/blog/assets/index.html.68c7cd78.js"><link rel="prefetch" href="/blog/assets/index.html.334e6a42.js"><link rel="prefetch" href="/blog/assets/index.html.2e5d7cc1.js"><link rel="prefetch" href="/blog/assets/index.html.87113aca.js"><link rel="prefetch" href="/blog/assets/index.html.b747de19.js"><link rel="prefetch" href="/blog/assets/index.html.198eaeb4.js"><link rel="prefetch" href="/blog/assets/index.html.8e6f9714.js"><link rel="prefetch" href="/blog/assets/index.html.31a9eea9.js"><link rel="prefetch" href="/blog/assets/index.html.7b3325a4.js"><link rel="prefetch" href="/blog/assets/index.html.aed333c1.js"><link rel="prefetch" href="/blog/assets/index.html.b3a1c5f9.js"><link rel="prefetch" href="/blog/assets/index.html.ad2cf7b1.js"><link rel="prefetch" href="/blog/assets/index.html.fd98db91.js"><link rel="prefetch" href="/blog/assets/index.html.fd421134.js"><link rel="prefetch" href="/blog/assets/index.html.372ab14b.js"><link rel="prefetch" href="/blog/assets/index.html.1cd62bbe.js"><link rel="prefetch" href="/blog/assets/index.html.403213ae.js"><link rel="prefetch" href="/blog/assets/index.html.d5abe138.js"><link rel="prefetch" href="/blog/assets/index.html.1aa31a66.js"><link rel="prefetch" href="/blog/assets/index.html.30cd30d7.js"><link rel="prefetch" href="/blog/assets/index.html.09b2e4b9.js"><link rel="prefetch" href="/blog/assets/index.html.da70a225.js"><link rel="prefetch" href="/blog/assets/index.html.7b639299.js"><link rel="prefetch" href="/blog/assets/slide.html.a53dd3a7.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.41c06d21.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.d1843e56.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.aa8f1ac3.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.7f2cb3d8.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.91bc278f.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.8956682e.js"><link rel="prefetch" href="/blog/assets/index.html.350d6758.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.ef773c76.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.af9773aa.js"><link rel="prefetch" href="/blog/assets/Database.html.d546ff29.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.2b8261b9.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.c78d28fb.js"><link rel="prefetch" href="/blog/assets/disable.html.39eb2780.js"><link rel="prefetch" href="/blog/assets/encrypt.html.315b54b9.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.e1572bb7.js"><link rel="prefetch" href="/blog/assets/markdown.html.539ea751.js"><link rel="prefetch" href="/blog/assets/network.html.82496b38.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.a0a36c5f.js"><link rel="prefetch" href="/blog/assets/page.html.3de13c27.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.5ec60a28.js"><link rel="prefetch" href="/blog/assets/index.html.2625667d.js"><link rel="prefetch" href="/blog/assets/article1.html.40d6fe14.js"><link rel="prefetch" href="/blog/assets/article10.html.87e8104b.js"><link rel="prefetch" href="/blog/assets/article11.html.666cd199.js"><link rel="prefetch" href="/blog/assets/article12.html.71cc33e1.js"><link rel="prefetch" href="/blog/assets/article3.html.2f4d729f.js"><link rel="prefetch" href="/blog/assets/article9.html.1a61c88d.js"><link rel="prefetch" href="/blog/assets/index.html.17af8375.js"><link rel="prefetch" href="/blog/assets/article3.html.0f236b00.js"><link rel="prefetch" href="/blog/assets/article4.html.ac19e42a.js"><link rel="prefetch" href="/blog/assets/article5.html.e4fee839.js"><link rel="prefetch" href="/blog/assets/article6.html.3f251dac.js"><link rel="prefetch" href="/blog/assets/article7.html.4eabf377.js"><link rel="prefetch" href="/blog/assets/article8.html.9941884c.js"><link rel="prefetch" href="/blog/assets/716-717.html.9269b67d.js"><link rel="prefetch" href="/blog/assets/718-719.html.fe0b6744.js"><link rel="prefetch" href="/blog/assets/720-721.html.af1f1b92.js"><link rel="prefetch" href="/blog/assets/722-723.html.e3ae716f.js"><link rel="prefetch" href="/blog/assets/724-725.html.288a06ca.js"><link rel="prefetch" href="/blog/assets/726-727.html.d57eff9c.js"><link rel="prefetch" href="/blog/assets/728-729.html.993ad69a.js"><link rel="prefetch" href="/blog/assets/730-731.html.27b85ad4.js"><link rel="prefetch" href="/blog/assets/801-805.html.2033d48e.js"><link rel="prefetch" href="/blog/assets/806-809.html.317a6373.js"><link rel="prefetch" href="/blog/assets/810-811.html.74b6bb6f.js"><link rel="prefetch" href="/blog/assets/812-813.html.3707716b.js"><link rel="prefetch" href="/blog/assets/815-816.html.dada21b6.js"><link rel="prefetch" href="/blog/assets/404.html.3b531494.js"><link rel="prefetch" href="/blog/assets/index.html.9795d051.js"><link rel="prefetch" href="/blog/assets/index.html.3f874820.js"><link rel="prefetch" href="/blog/assets/index.html.a867d5c6.js"><link rel="prefetch" href="/blog/assets/index.html.f82054f9.js"><link rel="prefetch" href="/blog/assets/index.html.ad17c083.js"><link rel="prefetch" href="/blog/assets/index.html.4096866c.js"><link rel="prefetch" href="/blog/assets/index.html.500d6379.js"><link rel="prefetch" href="/blog/assets/index.html.3ccf3594.js"><link rel="prefetch" href="/blog/assets/index.html.8542250b.js"><link rel="prefetch" href="/blog/assets/index.html.3db62235.js"><link rel="prefetch" href="/blog/assets/index.html.91eea6cd.js"><link rel="prefetch" href="/blog/assets/index.html.19faed32.js"><link rel="prefetch" href="/blog/assets/index.html.ae892a2a.js"><link rel="prefetch" href="/blog/assets/index.html.42ebab3b.js"><link rel="prefetch" href="/blog/assets/index.html.20085d81.js"><link rel="prefetch" href="/blog/assets/index.html.3a641003.js"><link rel="prefetch" href="/blog/assets/index.html.621a9ff7.js"><link rel="prefetch" href="/blog/assets/index.html.ae9240e8.js"><link rel="prefetch" href="/blog/assets/index.html.e913aa48.js"><link rel="prefetch" href="/blog/assets/index.html.1a1e4010.js"><link rel="prefetch" href="/blog/assets/index.html.1cf0720c.js"><link rel="prefetch" href="/blog/assets/index.html.e09d4efc.js"><link rel="prefetch" href="/blog/assets/index.html.c0d9d84d.js"><link rel="prefetch" href="/blog/assets/index.html.3c3c3596.js"><link rel="prefetch" href="/blog/assets/404.ae3f675f.js"><link rel="prefetch" href="/blog/assets/Layout.f6d5d68b.js"><link rel="prefetch" href="/blog/assets/Slide.4e46a672.js"><link rel="prefetch" href="/blog/assets/Blog.f219f1f3.js"><link rel="prefetch" href="/blog/assets/auto.esm.2565cd3a.js"><link rel="prefetch" href="/blog/assets/index.d8a59108.js"><link rel="prefetch" href="/blog/assets/index.1842ee54.js"><link rel="prefetch" href="/blog/assets/mermaid.esm.min.ee1e0284.js"><link rel="prefetch" href="/blog/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/blog/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/blog/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/blog/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/blog/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/blog/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/blog/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/blog/assets/photoswipe.esm.218074cd.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/blog/" class="brand"><img class="logo" src="/blog/logo.svg" alt="Huan"><!----><span class="site-name hide-in-pad">Huan</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/blog/guide/" class="nav-link" aria-label="基础"><span class="icon iconfont icon-creative"></span>基础<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/posts/" class="nav-link active" aria-label="算法"><span class="icon iconfont icon-edit"></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/tem" class="nav-link" aria-label="关于作者"><span class="icon iconfont icon-note"></span>关于作者<!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://gitee.com/paramhh/blog" target="_blank" rel="noopener noreferrer" aria-label="Gitee"><svg xmlns="http://www.w3.org/2000/svg" class="icon gitee-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="gitee icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm242.97-533.34H482.39a23.7 23.7 0 0 0-23.7 23.7l-.03 59.28c0 13.08 10.59 23.7 23.7 23.7h165.96a23.7 23.7 0 0 1 23.7 23.7v11.85a71.1 71.1 0 0 1-71.1 71.1H375.71a23.7 23.7 0 0 1-23.7-23.7V423.11a71.1 71.1 0 0 1 71.1-71.1h331.8a23.7 23.7 0 0 0 23.7-23.7l.06-59.25a23.73 23.73 0 0 0-23.7-23.73H423.11a177.78 177.78 0 0 0-177.78 177.75v331.83c0 13.08 10.62 23.7 23.7 23.7h349.62a159.99 159.99 0 0 0 159.99-159.99V482.33a23.7 23.7 0 0 0-23.7-23.7z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blog/posts/article1.html" class="nav-link sidebar-link sidebar-page" aria-label="刷题笔记"><span class="icon iconfont icon-article"></span>刷题笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/posts/article2.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="周赛总结"><span class="icon iconfont icon-article"></span>周赛总结<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_82场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="82场双周赛"><!---->82场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_301场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="301场周赛"><!---->301场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_302场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="302场周赛"><!---->302场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_83场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="83场双周赛"><!---->83场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_303场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="303场周赛"><!---->303场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_304场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="304场周赛"><!---->304场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="84场双周赛"><!---->84场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_305场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="305场周赛"><!---->305场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_306场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="306场周赛"><!---->306场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="84场双周赛"><!---->84场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_307场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="307场周赛"><!---->307场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_308场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="308场周赛"><!---->308场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_86场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="86场双周赛"><!---->86场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_309场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="309场周赛"><!---->309场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_310场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="310场周赛"><!---->310场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_87场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="87场双周赛"><!---->87场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_311场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="311场周赛"><!---->311场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_312场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="312场周赛"><!---->312场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_88场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="88场双周赛"><!---->88场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_313场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="313场周赛"><!---->313场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_314场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="314场周赛"><!---->314场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/blog/posts/article3.html" class="nav-link sidebar-link sidebar-page" aria-label="算法模板"><span class="icon iconfont icon-article"></span>算法模板<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">暑期集训</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">文章</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-article"></span>周赛总结</h1><div class="page-info"><span class="author-info" aria-label="作者" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="author-item">huan</span></span><span property="author" content="huan"></span></span><!----><span class="date-info" aria-label="写作日期" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年1月2日</span><meta property="datePublished" content="2022-01-02T00:00:00.000Z"></span><span class="category-info" aria-label="分类" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">算法笔记</li><meta property="articleSection" content="算法笔记"></ul></span><span aria-label="标签" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">数据结构与算法</li></ul><meta property="keywords" content="数据结构与算法"></span><span class="words-info" aria-label="字数" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 8457 字</span><meta property="wordCount" content="8457"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_82场双周赛" class="router-link-active router-link-exact-active toc-link level2">82场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_301场周赛" class="router-link-active router-link-exact-active toc-link level2">301场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_302场周赛" class="router-link-active router-link-exact-active toc-link level2">302场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_83场双周赛" class="router-link-active router-link-exact-active toc-link level2">83场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_303场周赛" class="router-link-active router-link-exact-active toc-link level2">303场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_304场周赛" class="router-link-active router-link-exact-active toc-link level2">304场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛" class="router-link-active router-link-exact-active toc-link level2">84场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_305场周赛" class="router-link-active router-link-exact-active toc-link level2">305场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_306场周赛" class="router-link-active router-link-exact-active toc-link level2">306场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛-1" class="router-link-active router-link-exact-active toc-link level2">84场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_307场周赛" class="router-link-active router-link-exact-active toc-link level2">307场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_308场周赛" class="router-link-active router-link-exact-active toc-link level2">308场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_86场双周赛" class="router-link-active router-link-exact-active toc-link level2">86场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_309场周赛" class="router-link-active router-link-exact-active toc-link level2">309场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_310场周赛" class="router-link-active router-link-exact-active toc-link level2">310场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_87场双周赛" class="router-link-active router-link-exact-active toc-link level2">87场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_311场周赛" class="router-link-active router-link-exact-active toc-link level2">311场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_312场周赛" class="router-link-active router-link-exact-active toc-link level2">312场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_88场双周赛" class="router-link-active router-link-exact-active toc-link level2">88场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_313场周赛" class="router-link-active router-link-exact-active toc-link level2">313场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_314场周赛" class="router-link-active router-link-exact-active toc-link level2">314场周赛</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="_82场双周赛" tabindex="-1"><a class="header-anchor" href="#_82场双周赛" aria-hidden="true">#</a> 82场双周赛</h2><h4 id="problem-a-计算布尔二叉树的值" tabindex="-1"><a class="header-anchor" href="#problem-a-计算布尔二叉树的值" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/evaluate-boolean-binary-tree/" target="_blank" rel="noopener noreferrer">计算布尔二叉树的值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递归&amp;模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean evaluateTree(TreeNode root) {
        boolean ans = dfs(root);
        return ans;
    }
    public boolean dfs(TreeNode root) {
        if (root.left == null &amp;&amp; root.right == null) return root.val == 1 ? true : false;
        else {
            boolean l = dfs(root.left), r = dfs(root.right);
            if (root.val == 2) return l || r;
            else return l &amp;&amp; r;
        }
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-坐上公交的最晚时间" tabindex="-1"><a class="header-anchor" href="#problem-b-坐上公交的最晚时间" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/the-latest-time-to-catch-a-bus/" target="_blank" rel="noopener noreferrer">坐上公交的最晚时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;双指针</strong></p><p><strong>由于求的是最晚到达公交站的时间，根据贪心容易得到，这个时间要么是某个公交的发车时间，要么比某个乘客早到 11 单位时间。因此我们通过 two pointers 的方式模拟上车过程，并枚举所有可能的答案：</strong></p><p><strong>1、当一个乘客在 t 时刻到达时，我们尝试抢先在它之前上车。只要不存在 (t - 1)(t−1) 时刻到达的乘客即可；</strong><strong>2、当公交发车时，若当前公交没有坐满，且不存在发车时到达的乘客，我们可以在这个时刻上车。</strong></p><p><strong>在所有可以上车的时刻中取最大值即可。复杂度 O(<em>n</em>log<em>n</em>)。</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        int n = buses.length, m = passengers.length;
        Arrays.sort(buses);
        Arrays.sort(passengers);
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (int x : passengers) s.add(x);
        int ans = 0;
        //双指针模拟上车 i 表示车， j 表示乘客
        for(int i = 0, j = 0; i &lt; buses.length; i ++) {
            int cur = 0;
            while(cur &lt; capacity &amp;&amp; j &lt; passengers.length &amp;&amp; passengers[j] &lt;= buses[i]) {  
                // 如果车 i 还有位置
                if (!s.contains(passengers[j] - 1) &amp;&amp; passengers[j] - 1 &lt;= buses[i]) {  
                    // 如果可以在某乘客前上车(passengers[j] - 1)
                    ans = Math.max(ans, passengers[j] - 1);
                }
                j ++ ;
                cur ++ ;
            }
            // 是否可以卡点上车(车来了再上车)
            if (cur &lt; capacity &amp;&amp; !s.contains(buses[i])){
                ans = Math.max(ans, buses[i]);
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最小差值平方和" tabindex="-1"><a class="header-anchor" href="#problem-c-最小差值平方和" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/minimum-sum-of-squared-difference/" target="_blank" rel="noopener noreferrer">最小差值平方和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二分&amp;贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minSumSquareDiff(int[] a, int[] b, int k1, int k2) {
        int n = a.length, m = k1 + k2;
        for (int i = 0; i &lt; n; i ++ ) a[i] = Math.abs(a[i] - b[i]);

        //二分求出切割线
        int l = 0, r = (int)1e5;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            long sum = 0;
            for (int x : a) if (x &gt; mid) sum += x - mid;
            if (sum &lt;= m) r = mid;
            else l = mid + 1;
        }

        //求出剩余的操作数
        int sum = 0;
        for (int x : a) if (x &gt; r) sum += x - r;
        m -= sum;
        
        //计算答案
        long ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            //如果比分割线阈值大
            if (a[i] &gt;= r) {
                //在操作数剩余情况下可以进一步切割
                if (r &gt; 0 &amp;&amp; m &gt; 0) {
                    ans += (long)(r - 1) * (r - 1);
                    m -- ;
                }
                else ans += (long)r * r; 
            } else {
                ans += (long)a[i] * a[i];
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-元素值大于变化阈值的子数组" tabindex="-1"><a class="header-anchor" href="#problem-d-元素值大于变化阈值的子数组" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/subarray-with-elements-greater-than-varying-threshold/" target="_blank" rel="noopener noreferrer">元素值大于变化阈值的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举 &amp; 并查集 &amp; 双指针</strong></p><h2 id="_301场周赛" tabindex="-1"><a class="header-anchor" href="#_301场周赛" aria-hidden="true">#</a> 301场周赛</h2><h4 id="problem-a-装满杯子需要的最短总时长" tabindex="-1"><a class="header-anchor" href="#problem-a-装满杯子需要的最短总时长" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/minimum-amount-of-time-to-fill-cups/" target="_blank" rel="noopener noreferrer">装满杯子需要的最短总时长<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;优先队列 || 排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int fillCups(int[] amount) {
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);
        for (int x : amount) if (x != 0) q.add(x);
        int ans = 0;
        while (!q.isEmpty()) {
            if (q.size() == 1) {
                ans += q.poll();
                break;
            }
            int a = q.poll(), b = q.poll();
            a --; b -- ;
            if (a != 0) q.add(a);
            if (b != 0) q.add(b);
            ans ++ ;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-无限集中的最小数字" tabindex="-1"><a class="header-anchor" href="#problem-b-无限集中的最小数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/smallest-number-in-infinite-set/" target="_blank" rel="noopener noreferrer">无限集中的最小数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟&amp;优先队列</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class SmallestInfiniteSet {
    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();
    public SmallestInfiniteSet() {
        for (int i = 1; i &lt;= 1000; i ++ ) q.add(i);
    }
    
    public int popSmallest() {
        return q.poll();
    }
    
    public void addBack(int num) {
        if (!q.contains(num)) {
            q.add(num);
        }
    }
}

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet obj = new SmallestInfiniteSet();
 * int param_1 = obj.popSmallest();
 * obj.addBack(num);
 */

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-移动片段得到字符串" tabindex="-1"><a class="header-anchor" href="#problem-c-移动片段得到字符串" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/move-pieces-to-obtain-a-string/" target="_blank" rel="noopener noreferrer">移动片段得到字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：双指针</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean canChange(String start, String target) {
        int n = start.length();
        char[] s = start.toCharArray(), t = target.toCharArray();
        int j = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            if (s[i] == &#39;_&#39;) continue;
            while (j &lt; n &amp;&amp; t[j] == &#39;_&#39;) j ++ ;
            if (j == n) return false;
            if (s[i] != t[j]) return false;
            if (t[j] == &#39;L&#39; &amp;&amp; j &gt; i) return false;  
            if (t[j] == &#39;R&#39; &amp;&amp; j &lt; i) return false;
            j ++ ;
        }
        for (int i = j; i &lt; n; i ++ ) 
            if (t[i] != &#39;_&#39;) 
                return false;
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-统计理想数组的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-统计理想数组的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/count-the-number-of-ideal-arrays/" target="_blank" rel="noopener noreferrer">统计理想数组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学 &amp; 递推</strong></p><h2 id="_302场周赛" tabindex="-1"><a class="header-anchor" href="#_302场周赛" aria-hidden="true">#</a> 302场周赛</h2><h4 id="problem-a-数组能形成多少数对" tabindex="-1"><a class="header-anchor" href="#problem-a-数组能形成多少数对" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/maximum-number-of-pairs-in-array/" target="_blank" rel="noopener noreferrer">数组能形成多少数对<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] numberOfPairs(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);
        int[] res = new int[2];
        for (int k : map.keySet()) {
            res[0] += map.get(k) / 2;
            res[1] += map.get(k) % 2;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-数位和相等数对的最大和" tabindex="-1"><a class="header-anchor" href="#problem-b-数位和相等数对的最大和" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/" target="_blank" rel="noopener noreferrer">数位和相等数对的最大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumSum(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        int res = -1;
        for (int x : nums) {
            int s = 0, y = x;
            while (y != 0) {
                s += y % 10;
                y /= 10;
            }
            if (map.containsKey(s)) {
                res = Math.max(res, x + map.get(s));
                map.put(s, Math.max(map.get(s), x));
            } else {
                map.put(s, x);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-裁剪数字后查询第-k-小的数字" tabindex="-1"><a class="header-anchor" href="#problem-c-裁剪数字后查询第-k-小的数字" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/query-kth-smallest-trimmed-number/" target="_blank" rel="noopener noreferrer">裁剪数字后查询第 K 小的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：字符串排序&amp;第二关键字排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] smallestTrimmedNumbers(String[] a, int[][] b) {
        int n = a.length, m = a[0].length();
        int[] ans = new int[b.length];
        for (int i = 0; i &lt; b.length; i ++ ) {
            int k = b[i][0], trim = b[i][1];
            String[][] ss = new String[n][2];
            for (int j = 0; j &lt; n; j ++ ) {
                ss[j][0] = a[j].substring(m - trim);
                ss[j][1] = String.valueOf(j);
            }
            Arrays.sort(ss, (o1, o2) -&gt; {
                int x = o1[0].compareTo(o2[0]);
                return x == 0 ? Integer.parseInt(o1[1]) -  Integer.parseInt(o2[1]): x;
            });
            ans[i] = Integer.parseInt(ss[k - 1][1]);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-使数组可以被整除的最少删除次数" tabindex="-1"><a class="header-anchor" href="#problem-d-使数组可以被整除的最少删除次数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-array-divisible/" target="_blank" rel="noopener noreferrer">使数组可以被整除的最少删除次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
    public int minOperations(int[] a, int[] b) {
        int res = 0;
        Arrays.sort(a);
        int d = 0;
        for (var x: b) d = gcd(d, x);
        for (int i = 0; i &lt; a.length; i ++ ) {
            if (d % a[i] == 0) break;
            res ++ ;
        }
        if (res == a.length) res = -1;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_83场双周赛" tabindex="-1"><a class="header-anchor" href="#_83场双周赛" aria-hidden="true">#</a> 83场双周赛</h2><h4 id="problem-a-最好的扑克手牌" tabindex="-1"><a class="header-anchor" href="#problem-a-最好的扑克手牌" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/best-poker-hand/" target="_blank" rel="noopener noreferrer">最好的扑克手牌<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String bestHand(int[] ranks, char[] suits) {
        // 记录花色种类的 set
        Set&lt;Character&gt; st = new HashSet();
        // 记录每个数字出现几次
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : ranks) map.put(x, map.getOrDefault(x, 0) + 1);
        for (char c : suits) st.add(c);
        // 只有一种花色
        if (st.size() == 1) return &quot;Flush&quot;;
        int mx = 0;
        for (int x : map.keySet()) mx = Math.max(mx, map.get(x));
        // 判断出现最多的数字出现了几次
        if (mx &gt;= 3) return &quot;Three of a Kind&quot;;
        else if (mx == 2) return &quot;Pair&quot;;
        else return &quot;High Card&quot;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-全-0-子数组的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-全-0-子数组的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/number-of-zero-filled-subarrays/" target="_blank" rel="noopener noreferrer">全 0 子数组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long res = 0;
        int n = nums.length;
        for (int i = 0; i &lt; n; i ++ ) {
            if (nums[i] != 0) continue;
            if (nums[i] == 0) res ++ ;
            int j = i;
            while (j + 1 &lt; n &amp;&amp; nums[j + 1] == 0) {
                j ++ ;
                res += j - i + 1;
            }
            i = j;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-设计数字容器系统" tabindex="-1"><a class="header-anchor" href="#problem-c-设计数字容器系统" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/design-a-number-container-system/" target="_blank" rel="noopener noreferrer">设计数字容器系统<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class NumberContainers {
    Map&lt;Integer, Integer&gt; m1 = new HashMap&lt;&gt;();
    Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; m2 = new HashMap&lt;&gt;();
    public NumberContainers() {
        
    }
    
    public void change(int index, int number) {
        if (m1.containsKey(index)) {
            int t = m1.get(index);
            TreeSet&lt;Integer&gt; S = m2.get(t);
            S.remove(index);
            if (S.size() &gt; 0) m2.put(t, S);
            else m2.remove(t);
        }
        m1.put(index, number);
        TreeSet&lt;Integer&gt; q = m2.getOrDefault(number, new TreeSet&lt;Integer&gt;());
        q.add(index);
        m2.put(number, q);
    }
    
    public int find(int number) {
        if (m2.containsKey(number)) return m2.get(number).first();
        else return -1;
    }
}

/**
 * Your NumberContainers object will be instantiated and called as such:
 * NumberContainers obj = new NumberContainers();
 * obj.change(index,number);
 * int param_2 = obj.find(number);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-不可能得到的最短骰子序列" tabindex="-1"><a class="header-anchor" href="#problem-d-不可能得到的最短骰子序列" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/shortest-impossible-sequence-of-rolls/" target="_blank" rel="noopener noreferrer">不可能得到的最短骰子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><h2 id="_303场周赛" tabindex="-1"><a class="header-anchor" href="#_303场周赛" aria-hidden="true">#</a> 303场周赛</h2><h4 id="problem-a-第一个出现两次的字母" tabindex="-1"><a class="header-anchor" href="#problem-a-第一个出现两次的字母" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/first-letter-to-appear-twice/" target="_blank" rel="noopener noreferrer">第一个出现两次的字母<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public char repeatedCharacter(String s) {
        int[] map = new int[128];
        for (char x : s.toCharArray()) {
            if (map[x] == 1) return x;
            map[x] ++ ;
        }
        return &#39;a&#39;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-相等行列对" tabindex="-1"><a class="header-anchor" href="#problem-b-相等行列对" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/equal-row-and-column-pairs/" target="_blank" rel="noopener noreferrer">相等行列对<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int equalPairs(int[][] g) {
        int n = g.length, m = g[0].length;
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                int t = 0;
                while (t &lt; n &amp;&amp; g[i][t] == g[t][j]) t ++ ;
                if (t == n) res ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-设计食物评分系统" tabindex="-1"><a class="header-anchor" href="#problem-c-设计食物评分系统" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/design-a-food-rating-system/" target="_blank" rel="noopener noreferrer">设计食物评分系统<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class FoodRatings {
    Map&lt;String, TreeSet&lt;Pair&lt;Integer, String&gt;&gt;&gt; hash = new HashMap&lt;&gt;();
    Map&lt;String, String&gt; c = new HashMap&lt;&gt;();
    Map&lt;String, Integer&gt; r = new HashMap&lt;&gt;();
    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        for (int i = 0; i &lt; foods.length; i ++ ) {
            c.put(foods[i], cuisines[i]);
            r.put(foods[i], ratings[i]);
            TreeSet&lt;Pair&lt;Integer, String&gt;&gt; S = hash.getOrDefault(cuisines[i], new TreeSet&lt;&gt;((o1, o2) -&gt; {
                return o1.getKey().equals(o2.getKey()) ? o1.getValue().compareTo(o2.getValue()) : o1.getKey() - o2.getKey();
            }));
            S.add(new Pair&lt;&gt;(-ratings[i], foods[i]));
            hash.put(cuisines[i], S);
        }
    }
    
    public void changeRating(String food, int newRating) {
        String cuisine = c.get(food);
        hash.get(cuisine).remove(new Pair(-r.get(food), food));
        r.put(food, newRating);
        TreeSet&lt;Pair&lt;Integer, String&gt;&gt; S = hash.get(cuisine);
        S.add(new Pair(-newRating, food));
        hash.put(cuisine, S);
    }
    
    public String highestRated(String cuisine) {
        return hash.get(cuisine).first().getValue();
    }
}

/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);
 * obj.changeRating(food,newRating);
 * String param_2 = obj.highestRated(cuisine);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-优质数对的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-优质数对的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/number-of-excellent-pairs/" target="_blank" rel="noopener noreferrer">优质数对的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><p>第i位在两个数里出现几次那么它对答案的贡献就是几</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countExcellentPairs(int[] nums, int k) {
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        for (int x : nums) set.add(x);
        int[] cnt = new int[30];
        for (int x : set) {
            int t = 0;
            while (x != 0) {
                t += x &amp; 1;
                x &gt;&gt;= 1;
            }
            cnt[t] ++ ;
        }
        long res = 0;
        for (int i = 0; i &lt; 30; i ++ ) {
            for (int j = 0; j &lt; 30; j ++ ) {
                if (i + j &gt;= k) 
                    res += cnt[i] * cnt[j];
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_304场周赛" tabindex="-1"><a class="header-anchor" href="#_304场周赛" aria-hidden="true">#</a> 304场周赛</h2><h4 id="problem-a-使数组中所有元素都等于零" tabindex="-1"><a class="header-anchor" href="#problem-a-使数组中所有元素都等于零" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/make-array-zero-by-subtracting-equal-amounts/" target="_blank" rel="noopener noreferrer">使数组中所有元素都等于零<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumOperations(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int x : nums) 
            if (x &gt; 0) 
                set.add(x);
        return set.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-分组的最大数量" tabindex="-1"><a class="header-anchor" href="#problem-b-分组的最大数量" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/maximum-number-of-groups-entering-a-competition/" target="_blank" rel="noopener noreferrer">分组的最大数量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumGroups(int[] g) {
        int res = 0, cnt = 1, n = g.length;
        while (cnt &lt;= n) {
            res ++ ;
            n -= cnt;
            cnt ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-找到离给定两个节点最近的节点" tabindex="-1"><a class="header-anchor" href="#problem-c-找到离给定两个节点最近的节点" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/find-closest-node-to-given-two-nodes/" target="_blank" rel="noopener noreferrer">找到离给定两个节点最近的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int closestMeetingNode(int[] p, int x, int y) {
        int n = p.length;
        int[] d1 = new int[n], d2 = new int[n];
        Arrays.fill(d1, -1); Arrays.fill(d2, -1);
        d1[x] = 0; d2[y] = 0;
        //两次dfs求距离
        while (p[x] != -1) {
            if (d1[p[x]] != -1) break;
            d1[p[x]] = d1[x] + 1;
            x = p[x];
        }
        while (p[y] != -1) {
            if (d2[p[y]] != -1) break;
            d2[p[y]] = d2[y] + 1;
            y = p[y];
        }
        int max = -1, res = -1;
        for (int i = 0; i &lt; n; i ++ ) {
            int a = d1[i], b = d2[i];
            if (a != -1 &amp;&amp; b != -1) {
                if (max == -1 || max &gt; Math.max(a, b)) {
                    max = Math.max(a, b);
                    res = i;
                }
            }
        }  
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-图中的最长环" tabindex="-1"><a class="header-anchor" href="#problem-d-图中的最长环" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/longest-cycle-in-a-graph/" target="_blank" rel="noopener noreferrer">图中的最长环<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, in_stk;
    boolean[] st;
    int n, res = -1;
    public int longestCycle(int[] _p) {
        n = _p.length;
        p = _p;
        st = new boolean[n];
        in_stk = new int[n];
        for (int i = 0; i &lt; n; i ++ ) 
            if (!st[i])
                dfs(i, 1);
        return res;
    }
    //u：当前搜到的点的下标
    //depth：当前点的深度
    public void dfs(int u, int depth) {
        st[u] = true;
        in_stk[u] = depth;
        int j = p[u];
        if (j != -1) {
            if (!st[j]) 
                dfs(j, depth + 1);
            else if (in_stk[j] &gt; 0)
                // 当in_stk[j]大于0说明搜到了环，并且in_stk[j]为环的起点的深度
                res = Math.max(res, depth + 1 - in_stk[j]);
        }
        in_stk[u] = 0;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_84场双周赛" tabindex="-1"><a class="header-anchor" href="#_84场双周赛" aria-hidden="true">#</a> 84场双周赛</h2><h4 id="problem-a-合并相似的物品" tabindex="-1"><a class="header-anchor" href="#problem-a-合并相似的物品" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/merge-similar-items/" target="_blank" rel="noopener noreferrer">合并相似的物品<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; mergeSimilarItems(int[][] a, int[][] b) {
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
        for (int[] x : a) {
            map.put(x[0], map.getOrDefault(x[0], 0) + x[1]);
        }
        for (int[] x : b) {
            map.put(x[0], map.getOrDefault(x[0], 0) + x[1]);
        }
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for (int k : map.keySet()) {
            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();
            t.add(k);
            t.add(map.get(k));
            res.add(t);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-统计坏数对的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-统计坏数对的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/count-number-of-bad-pairs/" target="_blank" rel="noopener noreferrer">统计坏数对的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countBadPairs(int[] nums) {
        long n = nums.length;
        for (int i = 0; i &lt; n; i ++ ) nums[i] -= i;
        long res = n * (n - 1l) / 2;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);
        for (int k : map.keySet()) {
            int v = map.get(k);
            if (v == 1) continue;
            else {
                res -= v * (v - 1l) / 2;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-任务调度器-ii" tabindex="-1"><a class="header-anchor" href="#problem-c-任务调度器-ii" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/task-scheduler-ii/" target="_blank" rel="noopener noreferrer">任务调度器 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟&amp;贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long taskSchedulerII(int[] q, int space) {
        int n = q.length;
        long res = 0;
        Map&lt;Integer, Long&gt; map = new HashMap&lt;&gt;();
        for (int x : q) {
            res ++ ;
            if (!map.containsKey(x))
                map.put(x, res);
            else {
                if (res - map.get(x) &lt;= space) 
                    res = map.get(x) + space + 1;
                map.put(x, res);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-将数组排序的最少替换次数" tabindex="-1"><a class="header-anchor" href="#problem-d-将数组排序的最少替换次数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/minimum-replacements-to-sort-the-array/" target="_blank" rel="noopener noreferrer">将数组排序的最少替换次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minimumReplacement(int[] nums) {
        long res = 0;
        int n = nums.length, last = nums[n - 1];
        for (int i = n - 2; i &gt;= 0; i -- ) {
            if (nums[i] &gt; last) {
            	//拆的次数
                int x = (nums[i] + last - 1) / last;
                res += x - 1;
                //拆出来的最小数，nums[i]/(拆的次数)向下取整
                last = nums[i] / x;
            } else {
                last = nums[i];
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_305场周赛" tabindex="-1"><a class="header-anchor" href="#_305场周赛" aria-hidden="true">#</a> 305场周赛</h2><h4 id="problem-a-算术三元组的数目" tabindex="-1"><a class="header-anchor" href="#problem-a-算术三元组的数目" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/" target="_blank" rel="noopener noreferrer">算术三元组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int n = nums.length;
        int res = 0;
        for (int i = 0; i &lt; n - 2; i ++ ) 
            for (int j = i + 1; j &lt; n - 1; j ++ )
                for (int k = j + 1; k &lt; n; k ++ ) {
                    if ((nums[j] - nums[i] == diff) &amp;&amp; (nums[k] - nums[j] == diff)) 
                        res ++ ;
                }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-受限条件下可到达节点的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-受限条件下可到达节点的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/" target="_blank" rel="noopener noreferrer"> 受限条件下可到达节点的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;Integer&gt;[] g;
    boolean[] r;
    int res = 0;
    public void dfs(int i, int j) {
        res ++ ;
        for (int x : g[j]) 
            if (x != i &amp;&amp; !r[x]) 
                dfs(j, x);
    }
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        g = new List[n];
        for (int i = 0; i &lt; n; i ++ ) g[i] = new ArrayList&lt;&gt;();
        r = new boolean[n];
        //标记受限节点
        for (int x : restricted) r[x] = true;
        //建图
        for (int[] x : edges) {
            int a = x[0], b = x[1];
            g[a].add(b);
            g[b].add(a);
        }
        dfs(0, 0);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：bfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        List&lt;Integer&gt;[] g = new List[n];
        boolean[] r;
        int res = 1;
        for (int i = 0; i &lt; n; i ++ ) g[i] = new ArrayList&lt;&gt;();
        r = new boolean[n];
        for (int x : restricted) r[x] = true;
        //建图
        for (int[] x : edges) {
            int a = x[0], b = x[1];
            g[a].add(b);
            g[b].add(a);
        }
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(0);
        r[0] = true;
        while (!q.isEmpty()) {
            int cur = q.poll();
            for (int x : g[cur]) {
                if (!r[x]) {
                    res ++ ;
                    r[x] = true;
                    q.add(x);
                }
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-检查数组是否存在有效划分" tabindex="-1"><a class="header-anchor" href="#problem-c-检查数组是否存在有效划分" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/" target="_blank" rel="noopener noreferrer">检查数组是否存在有效划分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean validPartition(int[] nums) {
        var n = nums.length;
        //设 f(i) 表示以 i 结尾的数组是否存在有效划分。i 的有效下标从 1 开始
        var f = new boolean[n + 1];
        f[0] = true;
        for (int i = 2; i &lt;= n; i ++ ) {
            if (nums[i - 1] == nums[i - 2]) 
                f[i] = f[i - 2];
            
            if (i &gt;= 3 &amp;&amp; nums[i - 1] == nums[i - 2] &amp;&amp; nums[i - 1] == nums[i - 3])
                f[i] = f[i] || f[i - 3];
            
            if (i &gt;= 3 &amp;&amp; nums[i - 1] == nums[i - 2] + 1 &amp;&amp; nums[i - 2] == nums[i - 3] + 1)
                f[i] = f[i] || f[i - 3];
        }
        return f[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-最长理想子序列" tabindex="-1"><a class="header-anchor" href="#problem-d-最长理想子序列" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/longest-ideal-subsequence/" target="_blank" rel="noopener noreferrer">最长理想子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestIdealString(String s, int k) {
        //记 f[d] 表示以字符 d 为结尾的最长理想子序列。
        var f = new int[26];
        var n = s.length();
        for (var c : s.toCharArray()) {
            var x = c - &#39;a&#39;;
            var t = 0;
            //满足Math.abs(x - y) &lt;= k就能将字符x接在以y结尾的子序列后边
            for (int y = 0; y &lt; 26; y ++ ) 
                if (Math.abs(x - y) &lt;= k)
                    t = Math.max(t, f[y] + 1);
            f[x] = Math.max(f[x], t);
        }
        return Arrays.stream(f).max().getAsInt();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_306场周赛" tabindex="-1"><a class="header-anchor" href="#_306场周赛" aria-hidden="true">#</a> 306场周赛</h2><h4 id="problem-a-矩阵中的局部最大值" tabindex="-1"><a class="header-anchor" href="#problem-a-矩阵中的局部最大值" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/" target="_blank" rel="noopener noreferrer">矩阵中的局部最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] largestLocal(int[][] g) {
        int n = g.length, m = g[0].length;
        int[][] res = new int[n - 2][m - 2];
        for (int i = 0; i &lt; n - 2; i ++ ) 
            for (int j = 0; j &lt; m - 2; j ++ )
                for (int x = 0; x &lt; 3; x ++ )
                    for (int y = 0; y &lt; 3; y ++ ) 
                        res[i][j] = Math.max(res[i][j], g[i + x][j + y]);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-边积分最高的节点" tabindex="-1"><a class="header-anchor" href="#problem-b-边积分最高的节点" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/node-with-highest-edge-score/" target="_blank" rel="noopener noreferrer">边积分最高的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int edgeScore(int[] edges) {
        int n = edges.length;
        long[] f = new long[n];
        for (int i = 0; i &lt; n; i ++ ) {
            f[edges[i]] += i;
        }
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) 
            if (f[i] &gt; f[res]) 
                res = i;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-根据模式串构造最小数字" tabindex="-1"><a class="header-anchor" href="#problem-c-根据模式串构造最小数字" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/" target="_blank" rel="noopener noreferrer">根据模式串构造最小数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String smallestNumber(String pattern) {
        int n = pattern.length();
        int[] num = new int[n + 1];
        for (int i = 0; i &lt;= n; i ++ ) 
            num[i] = i + 1;
        for (int i = 0; i &lt; n; i ++ ) {
            if (pattern.charAt(i) == &#39;D&#39;) {
                int j = i;
                while (j &lt; n &amp;&amp; pattern.charAt(j) == &#39;D&#39;) j ++ ;
                reverse(num, i, j);
                i = j - 1;
            }
        }
        StringBuilder res = new StringBuilder();
        for (int x : num) res.append(x);
        return res.toString();
    }
    public void reverse(int[] nums, int i, int j) {
        while (i &lt; j) {
            var x = nums[i];
            nums[i] = nums[j];
            nums[j] = x;
            i ++ ;
            j -- ;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：暴力</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    boolean[] st;
    String p;
    public String smallestNumber(String _p) {
        p = _p;
        int n = p.length();
        int[] nums = new int[n + 1];
        for (int i = 0; i &lt; n + 1; i ++ ) 
            nums[i] = i + 1;

        while (!check(nums)) {
            nextPermutation(nums);
        }
        var res = &quot;&quot;;
        for (var x : nums) res += x;
        return res;
    }
    public void nextPermutation(int[] nums) {
        int k = nums.length - 1;
        while (k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k -- ;
        if (k == 0) Arrays.sort(nums);
        else {
            int t = k;
            while (t + 1 &lt; nums.length &amp;&amp; nums[t + 1] &gt; nums[k - 1]) t ++ ;
            swap(nums, k - 1, t);
            reverse(nums, k, nums.length - 1);
        }
    }

    public void swap(int[] nums, int l, int r) {
        int t = nums[l];
        nums[l] = nums[r];
        nums[r] = t;
    }

    public void reverse(int[] nums, int l, int r) {
        while (l &lt; r) {
            swap(nums, l, r);
            l ++ ;
            r -- ;
        }
    }
    public boolean check(int[] nums) {
        for (int i = 0; i &lt; p.length(); i ++ ) {
            char c = p.charAt(i);
            if (c == &#39;I&#39; &amp;&amp; nums[i] &gt;= nums[i + 1])
                return false; 
            if (c == &#39;D&#39; &amp;&amp; nums[i] &lt;= nums[i + 1])
                return false; 
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-统计特殊整数" tabindex="-1"><a class="header-anchor" href="#problem-d-统计特殊整数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/count-special-integers/" target="_blank" rel="noopener noreferrer">统计特殊整数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数位dp</strong></p><h2 id="_84场双周赛-1" tabindex="-1"><a class="header-anchor" href="#_84场双周赛-1" aria-hidden="true">#</a> 84场双周赛</h2><h4 id="problem-a-得到-k-个黑块的最少涂色次数" tabindex="-1"><a class="header-anchor" href="#problem-a-得到-k-个黑块的最少涂色次数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/" target="_blank" rel="noopener noreferrer">得到 K 个黑块的最少涂色次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：滑动窗口</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumRecolors(String s, int k) {
        int res = 100;
        for (int i = 0, j = 0, cnt = 0; i &lt; s.length(); i ++ ) {
            if (s.charAt(i) == &#39;W&#39;) cnt ++ ;
            if (i - j + 1 &gt; k) {
                if (s.charAt(j) == &#39;W&#39;) cnt -- ;
                j ++ ;
            }
            if (i &gt;= k - 1) res = Math.min(cnt, res);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-二进制字符串重新安排顺序需要的时间" tabindex="-1"><a class="header-anchor" href="#problem-b-二进制字符串重新安排顺序需要的时间" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/" target="_blank" rel="noopener noreferrer">二进制字符串重新安排顺序需要的时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int secondsToRemoveOccurrences(String s) {
        int res = 0;
        while (s.contains(&quot;01&quot;)) {
           res ++ ;
           s = s.replaceAll(&quot;01&quot;, &quot;10&quot;);
        }  
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-字母移位-ii" tabindex="-1"><a class="header-anchor" href="#problem-c-字母移位-ii" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/shifting-letters-ii/" target="_blank" rel="noopener noreferrer">字母移位 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：差分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        char[] c = s.toCharArray();
        int n = s.length();
        int[] t = new int[n + 1];
        for (int[] p : shifts) {
            int a = p[0], b = p[1], w = p[2];
            if (w == 0) w = -1;
            t[a] += w;
            t[b + 1] -= w;
        }
        for (int i = 0, cur = 0; i &lt; n; i ++ ) {
            cur += t[i];
            cur %= 26;
            int p = c[i] - &#39;a&#39;;
            p += cur;
            p = (p + 26) % 26;
            c[i] = (char) (p + &#39;a&#39;);
        }
        return new String(c);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-删除操作后的最大子段和" tabindex="-1"><a class="header-anchor" href="#problem-d-删除操作后的最大子段和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/" target="_blank" rel="noopener noreferrer">删除操作后的最大子段和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><h2 id="_307场周赛" tabindex="-1"><a class="header-anchor" href="#_307场周赛" aria-hidden="true">#</a> 307场周赛</h2><h4 id="problem-a-赢得比赛需要的最少训练时长" tabindex="-1"><a class="header-anchor" href="#problem-a-赢得比赛需要的最少训练时长" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/" target="_blank" rel="noopener noreferrer">赢得比赛需要的最少训练时长<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minNumberOfHours(int a, int b, int[] c, int[] d) {
        int n = c.length;
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            if (a &gt; c[i]) a -= c[i];
            else {
                int x = c[i] + 1 - a;
                a += x - c[i];
                res += x;
            }

            if (b &gt; d[i]) b += d[i];
            else {
                int x = d[i] + 1 - b;
                b += x + d[i];
                res += x;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最大回文数字" tabindex="-1"><a class="header-anchor" href="#problem-b-最大回文数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/largest-palindromic-number/" target="_blank" rel="noopener noreferrer">最大回文数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String largestPalindromic(String s) {
        int[] map = new int[10];
        for (char x : s.toCharArray()) {
            int t = x - &#39;0&#39;;
            map[t] ++ ;
        }
        int a = 0;
        //找出可能要追加的数
        for (int i = 1; i &lt; 10; i ++ )
            if (map[i] % 2 == 1)
                a = i;
        StringBuilder sb = new StringBuilder();
        //拼凑答案的前半部分
        for (int i = 9; i &gt;= 0; i -- ) {
            int t = map[i] / 2;
            if (i == 0 &amp;&amp; sb.length() == 0) break;
            for (int j = 0; j &lt; t; j ++ )
                sb.append(i);
        }

        StringBuilder x = new StringBuilder(sb).reverse();
        //如果可以的话，中间追加一位
        if (map[a] != 0) sb.append(a);
        return sb.toString() + x.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-感染二叉树需要的总时间" tabindex="-1"><a class="header-anchor" href="#problem-c-感染二叉树需要的总时间" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/" target="_blank" rel="noopener noreferrer">感染二叉树需要的总时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs + bfs</strong></p><p>链式前向星建图</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int N = 100010;
    int[] h, e, ne;
    //记录该点是否进入过队列
    boolean[] st;
    int idx;
    public void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++ ;
    }
    //dfs建图
    public void dfs(TreeNode root) {
        if (root.left != null) {
            add(root.val, root.left.val);
            add(root.left.val, root.val);
            dfs(root.left);
        }
        if (root.right != null) {
            add(root.val, root.right.val);
            add(root.right.val, root.val);
            dfs(root.right);
        }
    }
    public int amountOfTime(TreeNode root, int start) {
        h = new int[N];
        e = new int[N * 2];
        ne = new int[N * 2];
        st = new boolean[N];
        idx = 0;
        Arrays.fill(h, -1);
        dfs(root);
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(start);
        int res = 0;
        while (!q.isEmpty()) {
            int count = q.size();
            while (count -- &gt; 0) {
                var t = q.poll();
                st[t] = true;           
                for (int i = h[t]; i != -1; i = ne[i]) {
                    int j = e[i];
                    if (st[j]) continue;
                    else q.add(j);
                }
            }
            res ++ ;
        }
        return res - 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs + bfs</strong></p><p>Map建图</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int N = 100010;
    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();
    boolean[] st;
    public void dfs(TreeNode root) {
        if (root == null) return;
        LinkedList&lt;Integer&gt; list = g.getOrDefault(root.val, new LinkedList&lt;&gt;());
        if (root.left != null) {
            list.add(root.left.val);
            LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();
            temp.add(root.val);
            g.put(root.left.val, temp);
        }
        if (root.right != null) {
            list.add(root.right.val);
            LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();
            temp.add(root.val);
            g.put(root.right.val, temp);
        }
        g.put(root.val, list);
        dfs(root.left);
        dfs(root.right);
    }
    public int amountOfTime(TreeNode root, int start) {
        dfs(root);
        st = new boolean[N];
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(start);
        int res = -1;
        while (!q.isEmpty()) {
            int count = q.size();
            while (count -- &gt; 0) {
                int x = q.poll();
                st[x] = true;
                List&lt;Integer&gt; list = g.get(x);
                if (list != null) {
                    for (int a : list) 
                    if (!st[a])
                        q.add(a);
                }
            }
            res ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-找出数组的第-k-大和" tabindex="-1"><a class="header-anchor" href="#problem-d-找出数组的第-k-大和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/" target="_blank" rel="noopener noreferrer">找出数组的第 K 大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：多路归并</strong></p><h2 id="_308场周赛" tabindex="-1"><a class="header-anchor" href="#_308场周赛" aria-hidden="true">#</a> 308场周赛</h2><h4 id="problem-a-和有限的最长子序列" tabindex="-1"><a class="header-anchor" href="#problem-a-和有限的最长子序列" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/" target="_blank" rel="noopener noreferrer">和有限的最长子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：前缀和 &amp;二分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] answerQueries(int[] nums, int[] q) {
        Arrays.sort(nums);
        int n = nums.length, m = q.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; i ++ )
            s[i + 1] = s[i] + nums[i];
        for (int i = 0; i &lt; m; i ++ ) {
            int k = q[i];
            int l = 0, r = n;
            while (l &lt; r) {
                int mid = l + r + 1 &gt;&gt; 1;
                if (s[mid] &lt;= k) l = mid;
                else r = mid - 1;
            }
            q[i] = l;
        }
        return q;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-从字符串中移除星号" tabindex="-1"><a class="header-anchor" href="#problem-b-从字符串中移除星号" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/removing-stars-from-a-string/" target="_blank" rel="noopener noreferrer">从字符串中移除星号<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String removeStars(String s) {
        StringBuilder sb = new StringBuilder();
        for (char x : s.toCharArray()) {
            if (x == &#39;*&#39;) sb.deleteCharAt(sb.length() - 1);
            else sb.append(x);
        }
        return sb.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-收集垃圾的最少总时间" tabindex="-1"><a class="header-anchor" href="#problem-c-收集垃圾的最少总时间" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/" target="_blank" rel="noopener noreferrer">收集垃圾的最少总时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int garbageCollection(String[] g, int[] t) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int a = 0, b = 0, c = 0;
        for (int i = 0; i &lt; g.length; i ++) {
            for (char x : g[i].toCharArray()) {
                if (x == &#39;M&#39;) a ++ ;
                else if (x == &#39;P&#39;) b ++ ;
                else c ++ ;
                map.put(x, i);
            }
        }
        int res = a + b + c;
        int[] s = new int[t.length + 1];
        for (int i = 0; i &lt; t.length; i ++ ) 
            s[i + 1] = s[i] + t[i];
        for (char x : map.keySet()) res += s[map.get(x)];
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-给定条件下构造矩阵" tabindex="-1"><a class="header-anchor" href="#problem-d-给定条件下构造矩阵" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/" target="_blank" rel="noopener noreferrer">给定条件下构造矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：拓扑排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] topoSort(int k, int[][] edges) {
        List&lt;Integer&gt;[] g = new List[k];
        Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;());
        int[] d = new int[k];
        for (var e : edges) {
            int a = e[0] - 1, b = e[1] - 1;
            g[a].add(b);
            d[b] ++ ;
        }
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; k; i ++ )
            if (d[i] == 0)
                q.add(i);
        while (!q.isEmpty()) {
            int t = q.poll();
            res.add(t);
            for (int x : g[t])
                if (-- d[x] == 0)
                    q.add(x);
        }
        return res.stream().mapToInt(x -&gt; x).toArray();
    }
    public int[][] buildMatrix(int k, int[][] row, int[][] col) {
        int[] x = topoSort(k, row), y = topoSort(k, col);
        if (x.length &lt; k || y.length &lt; k) return new int[][]{};
        int[][] res = new int[k][k];
        for (int i = 0; i &lt; k; i ++ )
            for (int j = 0; j &lt; k; j ++ )
                if (x[i] == y[j]) res[i][j] = x[i] + 1;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_86场双周赛" tabindex="-1"><a class="header-anchor" href="#_86场双周赛" aria-hidden="true">#</a> 86场双周赛</h2><h4 id="problem-a-和相等的子数组" tabindex="-1"><a class="header-anchor" href="#problem-a-和相等的子数组" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/find-subarrays-with-equal-sum/" target="_blank" rel="noopener noreferrer">和相等的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean findSubarrays(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        int n = nums.length;
        for (int i = 0; i &lt; n - 1; i ++ ) {
            int x = nums[i] + nums[i + 1];
            if (set.contains(x)) return true;
            set.add(x);
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-严格回文的数字" tabindex="-1"><a class="header-anchor" href="#problem-b-严格回文的数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/strictly-palindromic-number/" target="_blank" rel="noopener noreferrer">严格回文的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean f(String s) {
        for (int i = 0, j = s.length() - 1; i &lt; j; i ++ , j -- ) 
            if (i &lt; j &amp;&amp; s.charAt(i) != s.charAt(j)) 
                return false;
        
        return true;
    }
    
    public boolean isStrictlyPalindromic(int n) {
        for (int i = 2; i &lt;= n - 2; i ++ ) {
            StringBuilder sb = new StringBuilder();
            int t = n;
            while (t != 0) {
                sb.append(t % i);
                t /= i;
            }
            if (!f(sb.reverse().toString())) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean isStrictlyPalindromic(int n) {
    	return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-被列覆盖的最多行数" tabindex="-1"><a class="header-anchor" href="#problem-c-被列覆盖的最多行数" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/" target="_blank" rel="noopener noreferrer">被列覆盖的最多行数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二进制枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumRows(int[][] g, int cols) {
        int m = g.length, n = g[0].length;
        int res = 0;
        for (int k = 0; k &lt; (1 &lt;&lt; n); k ++ ) {
            if (Integer.bitCount(k) != cols) continue;
            int t = 0;
            out:for (int i = 0; i &lt; m; i ++ ) {
                    for (int j = 0; j &lt; n; j ++ )
                        if ((k &gt;&gt; j &amp; 1) == 0 &amp;&amp; g[i][j] == 1)
                            continue out;
                t ++ ;
            }
            res = Math.max(res, t);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs</strong>、</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[][] g;
    int res = 0;
    int n, m;
    public int maximumRows(int[][] mat, int cols) {
        n = mat.length;
        m = mat[0].length;
        g = mat;
        dfs(0, cols,new HashSet&lt;Integer&gt;());
        return res;
    }
    public void dfs(int u, int k, Set&lt;Integer&gt; set) {
        if (set.size() == k) {
            int t = 0;
            out:for (int i = 0; i &lt; n; i ++ ) {
                for (int j = 0; j &lt; m; j ++ )
                    if (g[i][j] == 1 &amp;&amp; !set.contains(j))
                        continue out;
                t ++ ;
            }
            res = Math.max(res, t);
        } else {
            for (int i = u; i &lt; m; i ++ ) {
                set.add(i);
                dfs(i + 1, k, set);
                set.remove(i);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-预算内的最多机器人数目" tabindex="-1"><a class="header-anchor" href="#problem-d-预算内的最多机器人数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/" target="_blank" rel="noopener noreferrer">预算内的最多机器人数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：双指针&amp;单调队列</strong></p><h2 id="_309场周赛" tabindex="-1"><a class="header-anchor" href="#_309场周赛" aria-hidden="true">#</a> 309场周赛</h2><h4 id="problem-a-检查相同字母间的距离" tabindex="-1"><a class="header-anchor" href="#problem-a-检查相同字母间的距离" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/check-distances-between-same-letters/" target="_blank" rel="noopener noreferrer">检查相同字母间的距离<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean checkDistances(String s, int[] d) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i ++ ) {
            char x = s.charAt(i);
            if (!map.containsKey(x - &#39;a&#39;)) map.put(x - &#39;a&#39;, new ArrayList&lt;&gt;());
            map.get(x - &#39;a&#39;).add(i);
        }
        for (int k : map.keySet()) {
            if (map.get(k).get(1) - map.get(k).get(0) == d[k] + 1) continue;
            else return false;
        }
        return true;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean checkDistances(String s, int[] distance) {
        int[] a = new int[26];
        Arrays.fill(a, -1);
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int x = s.charAt(i) - &#39;a&#39;;
            if (a[x] == -1) a[x] = i;
            else if (i - a[x] != distance[x] + 1) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-恰好移动-k-步到达某一位置的方法数目" tabindex="-1"><a class="header-anchor" href="#problem-b-恰好移动-k-步到达某一位置的方法数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/" target="_blank" rel="noopener noreferrer">恰好移动 k 步到达某一位置的方法数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数论</strong></p><p>动态规划求组合数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private int mod = (int)1e9 + 7;
    public int numberOfWays(int startPos, int endPos, int k) {
        int d = Math.abs(endPos - startPos);
        if (d &gt; k || (d + k) % 2 == 1) return 0;
        int[][] f = new int[k + 1][k + 1];
        for (int i = 0; i &lt;= k; i ++ ) {
            f[i][0] = 1;
            for (int j = 1; j &lt;= i; j ++ )
                f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;
        }
        return f[k][(d + k) / 2];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逆元求组合数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private int mod = (int)1e9 + 7;
    
    public int qmi(int m, int k, int p) {
        long res = 1l % p, t = m * 1l;
        while (k != 0) {
            if ((k &amp; 1) != 0) res = res * t % p;
            t = t * t % p;
            k &gt;&gt;= 1;
        }
        return (int)res;
    }

    public int numberOfWays(int startPos, int endPos, int k) {
        int m = Math.abs(endPos - startPos);
        if ((m - k) % 2 != 0 || k &lt; m) return 0;
        int r = (k + m) / 2;
        long res = 1;
        for (int i = k; i &gt; k - r; i -- ) 
            res = res * i % mod;
        for (int i = 1; i &lt;= r; i ++ ) {
            res = res * qmi(i, mod - 2, mod) % mod;
        }
        return (int)res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最长优雅子数组" tabindex="-1"><a class="header-anchor" href="#problem-c-最长优雅子数组" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/longest-nice-subarray/" target="_blank" rel="noopener noreferrer">最长优雅子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：位运算&amp;滑动窗口&amp;状态压缩</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestNiceSubarray(int[] nums) {
        int n = nums.length;
        int res = 0;
        int s = 0;
        for (int i = 0, j = 0; i &lt; n; i ++ ) {
            while ((s &amp; nums[i]) &gt; 0) 
                s ^= nums[j ++ ];
            s ^= nums[i];
            res = Math.max(res, i - j + 1);    
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-会议室-iii" tabindex="-1"><a class="header-anchor" href="#problem-d-会议室-iii" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/meeting-rooms-iii/" target="_blank" rel="noopener noreferrer">会议室 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><h2 id="_310场周赛" tabindex="-1"><a class="header-anchor" href="#_310场周赛" aria-hidden="true">#</a> 310场周赛</h2><h4 id="problem-a-出现最频繁的偶数元素" tabindex="-1"><a class="header-anchor" href="#problem-a-出现最频繁的偶数元素" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/most-frequent-even-element/" target="_blank" rel="noopener noreferrer">出现最频繁的偶数元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int mostFrequentEven(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) {
            if (x % 2 == 0) 
                map.put(x, map.getOrDefault(x, 0) + 1);
        }
        int res = -1;
        for (int k : map.keySet()) {
            int v = map.get(k);
            if (res == -1 || map.get(res) &lt; v || (map.get(res) == v &amp;&amp; res &gt; k))
                    res = k;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-子字符串的最优划分" tabindex="-1"><a class="header-anchor" href="#problem-b-子字符串的最优划分" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/optimal-partition-of-string/" target="_blank" rel="noopener noreferrer">子字符串的最优划分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int partitionString(String s) {
        int[] map = new int[26];
        int res = 0;
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int x = s.charAt(i) - &#39;a&#39;;
            map[x] ++ ;
            if (map[x] &gt; 1) {
                res ++ ;
                i -- ;
                map = new int[26];
            }   
        }
        return res + 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-将区间分为最少组数" tabindex="-1"><a class="header-anchor" href="#problem-c-将区间分为最少组数" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/" target="_blank" rel="noopener noreferrer">将区间分为最少组数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minGroups(int[][] g) {
        int n = g.length;
        Arrays.sort(g, (a, b) -&gt; a[0] - b[0]);
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();

        for (int i = 0; i &lt; n; i ++ ) {
            int[] r = g[i];
            //需要创建新组
            if (q.isEmpty() || q.peek() &gt;= r[0]) q.add(r[1]);
            else {
                //将该段放入更新当前组最大值
                int t = q.poll();
                q.add(r[1]);
            }
        }
        return q.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-最长递增子序列-ii" tabindex="-1"><a class="header-anchor" href="#problem-d-最长递增子序列-ii" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/" target="_blank" rel="noopener noreferrer">最长递增子序列 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线段树</strong></p><h2 id="_87场双周赛" tabindex="-1"><a class="header-anchor" href="#_87场双周赛" aria-hidden="true">#</a> 87场双周赛</h2><h4 id="problem-a-统计共同度过的日子数" tabindex="-1"><a class="header-anchor" href="#problem-a-统计共同度过的日子数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/count-days-spent-together/" target="_blank" rel="noopener noreferrer">统计共同度过的日子数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] t = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    public int get(String s) {
        String[] ss = s.split(&quot;-&quot;);
        int a = Integer.parseInt(ss[0]), b = Integer.parseInt(ss[1]);
        int res = 0;
        for (int i = 0; i &lt; a; i ++ ) res += t[i];
        return res + b;
    }
    public int countDaysTogether(String s1, String s2, String s3, String s4) {
        int a = get(s1), b = get(s2), c = get(s3), d = get(s4);
        int res = Math.min(b, d) - Math.max(a, c) + 1;
        return Math.max(0, res);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-运动员和训练师的最大匹配数" tabindex="-1"><a class="header-anchor" href="#problem-b-运动员和训练师的最大匹配数" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/" target="_blank" rel="noopener noreferrer">运动员和训练师的最大匹配数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int matchPlayersAndTrainers(int[] a, int[] b) {
        Arrays.sort(a);
        Arrays.sort(b);
        int res = 0;
        for (int i = 0, j = 0; i &lt; a.length; i ++ ) {
            while (j &lt; b.length &amp;&amp; b[j] &lt; a[i]) j ++ ;
            if (j == b.length) break;
            if (a[i] &lt;= b[j]) {
                j ++ ;
                res ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-按位或最大的最小子数组长度" tabindex="-1"><a class="header-anchor" href="#problem-c-按位或最大的最小子数组长度" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/" target="_blank" rel="noopener noreferrer">按位或最大的最小子数组长度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] p = new int[30];
        int[] res = new int[n];
        Arrays.fill(p, n);
        for (int i = n - 1; i &gt;= 0; i -- ) {
            int t = i;
            for (int j = 0; j &lt; 30; j ++ )
                if ((nums[i] &gt;&gt; j &amp; 1) == 1) p[j] = i;
                else if (p[j] != n) t = Math.max(p[j], t);
            res[i] = t - i + 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-完成所有交易的初始最少钱数" tabindex="-1"><a class="header-anchor" href="#problem-d-完成所有交易的初始最少钱数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/minimum-money-required-before-transactions/" target="_blank" rel="noopener noreferrer">完成所有交易的初始最少钱数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minimumMoney(int[][] transactions) {
        long sum = 0;
        for (int[] p : transactions) {
            int a = p[0], b = p[1];
            if (a &gt; b) sum += a - b;
        }
        long res = 0;
        for (int[] p : transactions) {
            int a = p[0], b = p[1];
            long s = sum;
            if (a &gt; b) s -= a - b;
            res = Math.max(res, s + a);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_311场周赛" tabindex="-1"><a class="header-anchor" href="#_311场周赛" aria-hidden="true">#</a> 311场周赛</h2><h4 id="problem-a-最小偶倍数" tabindex="-1"><a class="header-anchor" href="#problem-a-最小偶倍数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/smallest-even-multiple/" target="_blank" rel="noopener noreferrer">最小偶倍数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int smallestEvenMultiple(int n) {
        if (n % 2 == 0) return n;
        else return n * 2;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最长的字母序连续子字符串的长度" tabindex="-1"><a class="header-anchor" href="#problem-b-最长的字母序连续子字符串的长度" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/" target="_blank" rel="noopener noreferrer">最长的字母序连续子字符串的长度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestContinuousSubstring(String s) {
        char[] ss = s.toCharArray();
        int res = 0;
        for (int i = 0; i &lt; ss.length; i ++ ) {
            int j = i + 1;
            while (j &lt; ss.length &amp;&amp; ss[j] == ss[j - 1] + 1) j ++ ;
            res = Math.max(res, j - i);
            i = j - 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-反转二叉树的奇数层" tabindex="-1"><a class="header-anchor" href="#problem-c-反转二叉树的奇数层" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/" target="_blank" rel="noopener noreferrer">反转二叉树的奇数层<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：bfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void reverse(List&lt;TreeNode&gt; list) {
        int l = 0, r = list.size() - 1;
        while (l &lt; r) {
            TreeNode a = list.get(l), b = list.get(r);
            int t = a.val;
            a.val = b.val;
            b.val = t;
            l ++ ;
            r -- ;
        }
    } 
    public TreeNode reverseOddLevels(TreeNode root) {
        var q = new ArrayDeque&lt;TreeNode&gt;();
        q.add(root);
        int depth = -1;
        while (!q.isEmpty()) {
            int cur = q.size();
            var list = new ArrayList&lt;TreeNode&gt;();
            while (cur -- &gt; 0) {
                TreeNode node = q.poll();
                list.add(node);
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            depth ++ ;
            if (depth % 2 == 1) 
                reverse(list);
        }
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void swap(TreeNode a, TreeNode b) {
        int t = a.val;
        a.val = b.val;
        b.val = t;
    }

    public void dfs(TreeNode a, TreeNode b, int d) {
        if (a == null) return;
        if (d % 2 == 1) swap(a, b);
        dfs(a.left, b.right, d + 1);
        dfs(a.right, b.left, d + 1); 
    }

    public TreeNode reverseOddLevels(TreeNode root) {
        dfs(root.left, root.right, 1);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-字符串的前缀分数和" tabindex="-1"><a class="header-anchor" href="#problem-d-字符串的前缀分数和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/" target="_blank" rel="noopener noreferrer">字符串的前缀分数和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：字典树</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    
    public class TrieNode {
        TrieNode[] child;
        int cnt;
        TrieNode() {
            child = new TrieNode[27];
            cnt = 1;
        }
    }
    
    TrieNode root = new TrieNode();
    
    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] == null) {
                p.child[c - &#39;a&#39;] = new TrieNode();
            } else {
                p.child[c - &#39;a&#39;].cnt ++ ;
            }
            p = p.child[c - &#39;a&#39;];
        }
    }

    public int search(String word) {
        TrieNode p = root;
        int res = 0;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] != null) {
                p = p.child[c - &#39;a&#39;];
                res += p.cnt;
            }
        }
        return res;
    }

    public int[] sumPrefixScores(String[] words) {
        int n = words.length;
        for (String x : words) {
            insert(x);
        }
        int[] res = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            String word = words[i];
            res[i] = search(word);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_312场周赛" tabindex="-1"><a class="header-anchor" href="#_312场周赛" aria-hidden="true">#</a> 312场周赛</h2><h4 id="problem-a-按身高排序" tabindex="-1"><a class="header-anchor" href="#problem-a-按身高排序" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/sort-the-people/" target="_blank" rel="noopener noreferrer">按身高排序<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String[] sortPeople(String[] names, int[] h) {
        var map = new HashMap&lt;Integer, String&gt;();
        for (int i = 0; i &lt; names.length; i ++ )
            map.put(h[i], names[i]);
        Arrays.sort(h);
        var list = new ArrayList&lt;String&gt;();
        for (int i = h.length - 1; i &gt;= 0; i -- )
            list.add(map.get(h[i]));
        return list.toArray(new String[h.length]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-按位与最大的最长子数组" tabindex="-1"><a class="header-anchor" href="#problem-b-按位与最大的最长子数组" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/" target="_blank" rel="noopener noreferrer">按位与最大的最长子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestSubarray(int[] nums) {
        int mx = 0, n = nums.length;
        for (int x : nums)
            mx = Math.max(mx, x);
        int res = 0, cur = 0;
        for (int i = 0; i &lt; n; i ++ )
            if (nums[i] == mx) {
                int j = i + 1;
                while (j &lt; n &amp;&amp; nums[j] == mx) j ++ ;
                res = Math.max(res, j - i);
                i = j;
            } 
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-找到所有好下标" tabindex="-1"><a class="header-anchor" href="#problem-c-找到所有好下标" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/find-all-good-indices/" target="_blank" rel="noopener noreferrer">找到所有好下标<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; goodIndices(int[] nums, int k) {
        var n = nums.length;
        int[] f = new int[n], g = new int[n];
        Arrays.fill(f, 1); Arrays.fill(g, 1);
        for (int i = 1; i &lt; n; i ++ )
            if (nums[i] &lt;= nums[i - 1])
                f[i] = f[i - 1] + 1;
        for (int i = n - 1; i &gt; 0; i -- )
            if (nums[i] &gt;= nums[i - 1])
                g[i - 1] = g[i] + 1;
        var res = new ArrayList&lt;Integer&gt;();
        for (int i = k; i &lt; n - k; i ++ )
            if (f[i - 1] &gt;= k &amp;&amp; g[i + 1] &gt;= k)
                res.add(i);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-好路径的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-好路径的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/number-of-good-paths/" target="_blank" rel="noopener noreferrer">好路径的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：并查集</strong></p><h2 id="_88场双周赛" tabindex="-1"><a class="header-anchor" href="#_88场双周赛" aria-hidden="true">#</a> 88场双周赛</h2><h4 id="problem-a-删除字符使频率相同" tabindex="-1"><a class="header-anchor" href="#problem-a-删除字符使频率相同" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/remove-letter-to-equalize-frequency/" target="_blank" rel="noopener noreferrer">删除字符使频率相同<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean equalFrequency(String s) {
        int[] map = new int[26];
        for (char x : s.toCharArray()) map[x - &#39;a&#39;] ++ ;
        for (int i = 0; i &lt; 26; i ++ )
            if (map[i] &gt; 0) {
                map[i] -- ;
                int t = 0;
                boolean res = true;
                for (int j = 0; j &lt; 26; j ++ ) 
                    if (map[j] &gt; 0) {
                        if (t == 0) t = map[j];
                        else if (map[j] != t) res = false;
                    }
                map[i] ++ ;
                if (res) return res;
            }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最长上传前缀" tabindex="-1"><a class="header-anchor" href="#problem-b-最长上传前缀" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/longest-uploaded-prefix/" target="_blank" rel="noopener noreferrer">最长上传前缀<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class LUPrefix {
    boolean[] st;
    int n, now = 0;
    public LUPrefix(int _n) {
        n = _n;
        st = new boolean[n + 1];
    }
    
    public void upload(int x) {
        st[x] = true;
        while (now &lt; n &amp;&amp; st[now + 1]) now ++ ;
    }
    
    public int longest() {
        return now;
    }
}

/**
 * Your LUPrefix object will be instantiated and called as such:
 * LUPrefix obj = new LUPrefix(n);
 * obj.upload(video);
 * int param_2 = obj.longest();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-所有数对的异或和" tabindex="-1"><a class="header-anchor" href="#problem-c-所有数对的异或和" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/bitwise-xor-of-all-pairings/" target="_blank" rel="noopener noreferrer">所有数对的异或和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int xorAllNums(int[] a, int[] b) {
        int n = a.length, m = b.length;
        int res = 0;
        if (n % 2 == 1) 
            for (int x : b) 
                res ^= x;        
        if (m % 2 == 1) 
            for (int x : a) 
                res ^= x;    
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-满足不等式的数对数目" tabindex="-1"><a class="header-anchor" href="#problem-d-满足不等式的数对数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/" target="_blank" rel="noopener noreferrer">满足不等式的数对数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：树状数组</strong></p><h2 id="_313场周赛" tabindex="-1"><a class="header-anchor" href="#_313场周赛" aria-hidden="true">#</a> 313场周赛</h2><h4 id="problem-a-公因子的数目" tabindex="-1"><a class="header-anchor" href="#problem-a-公因子的数目" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/number-of-common-factors/" target="_blank" rel="noopener noreferrer">公因子的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int commonFactors(int a, int b) {
        int res = 0;
        for (int i = 1; i &lt;= Math.min(a, b); i ++ ) {
            if (a % i == 0 &amp;&amp; b % i == 0)
                res ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-沙漏的最大总和" tabindex="-1"><a class="header-anchor" href="#problem-b-沙漏的最大总和" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/" target="_blank" rel="noopener noreferrer">沙漏的最大总和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：前缀和</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxSum(int[][] g) {
        int n = g.length, m = g[0].length;
        int[][] s = new int[n + 1][m + 1];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + g[i][j];
            }
        }
        int res = 0;
        for (int i = 2; i &lt; n; i ++ )
            for (int j = 2; j &lt; m; j ++ )
                res = Math.max(res, s[i + 1][j + 1] - s[i + 1][j - 2] - s[i - 2][j + 1] + s[i - 2][j - 2] - g[i - 1][j] - g[i - 1][j - 2]);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最小-xor" tabindex="-1"><a class="header-anchor" href="#problem-c-最小-xor" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimize-xor/" target="_blank" rel="noopener noreferrer">最小 XOR<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimizeXor(int a, int b) {
        int n = Integer.bitCount(b);
        int res = 0;
        for (int i = 32 - 1; i &gt;= 0 &amp;&amp; n != 0; i -- ) 
            if ((a &gt;&gt; i &amp; 1) == 1) {
                res += 1 &lt;&lt; i;
                n -- ;
            }
        for (int i = 0; i &lt; 32 &amp;&amp; n != 0; i ++ )
            if ((res &gt;&gt; i &amp; 1) == 0) {
                res += 1 &lt;&lt; i;
                n -- ;
            }
        
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-对字母串可执行的最大删除数" tabindex="-1"><a class="header-anchor" href="#problem-d-对字母串可执行的最大删除数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/" target="_blank" rel="noopener noreferrer">对字母串可执行的最大删除数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp&amp;字符串哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int P = 131, n;
    long[] h, p;
    public long get(int l, int r) {
        return h[r] - h[l - 1] * p[r - l + 1];
    }
    public int deleteString(String s) {
        n = s.length();
        h = new long[n + 1];
        p = new long[n + 1];
        p[0] = 1;
        for (int i = 1; i &lt;= n; i ++ ) {
            p[i] = p[i - 1] * P;
            h[i] = h[i - 1] * P + s.charAt(i - 1);
        }
        //表示将[i, n]这个后缀所需最大操作数
        int[] f = new int[n + 1];
        Arrays.fill(f, 1);
        for (int i = n; i &gt; 0; i -- ) 
            for (int j = 1; j &lt;= (n - i + 1) / 2; j ++ )
                if (get(i, i + j - 1) == get(i + j, i + j * 2 - 1))
                    f[i] = Math.max(f[i], f[i + j] + 1);
        
        return f[1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_314场周赛" tabindex="-1"><a class="header-anchor" href="#_314场周赛" aria-hidden="true">#</a> 314场周赛</h2><h4 id="problem-a-处理用时最长的那个任务的员工" tabindex="-1"><a class="header-anchor" href="#problem-a-处理用时最长的那个任务的员工" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/" target="_blank" rel="noopener noreferrer">处理用时最长的那个任务的员工<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int hardestWorker(int n, int[][] logs) {
        var list = new ArrayList&lt;int[]&gt;();
        int pre = 0;
        for (int[] p : logs) {
            int a = p[0], b = p[1];
            list.add(new int[]{a, b - pre});
            pre = b;
        }
        list.sort((a, b) -&gt; {
            return a[1] == b[1] ? a[0] - b[0] : b[1] - a[1];
        });
        return list.get(0)[0];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-找出前缀异或的原始数组" tabindex="-1"><a class="header-anchor" href="#problem-b-找出前缀异或的原始数组" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/" target="_blank" rel="noopener noreferrer">找出前缀异或的原始数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：位运算</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] findArray(int[] p) {
        int n = p.length;
        int[] res = new int[n];
        res[0] = p[0];
        for (int i = 1; i &lt; n; i ++ ) {
            res[i] = p[i] ^ p[i - 1];
        }
        return res;
    }   
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-使用机器人打印字典序最小的字符串" tabindex="-1"><a class="header-anchor" href="#problem-c-使用机器人打印字典序最小的字符串" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/" target="_blank" rel="noopener noreferrer">使用机器人打印字典序最小的字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String robotWithString(String s) {
        var map = new int[26];
        var res = new StringBuilder();
        var stk = new ArrayDeque&lt;Character&gt;();
        var min = 0;
        for (char c : s.toCharArray()) map[c - &#39;a&#39;] ++ ;
        for (char c : s.toCharArray()) {
            -- map[c - &#39;a&#39;];
            while (min &lt; 26 &amp;&amp; map[min] == 0) min ++ ;
            stk.push(c);
            while (!stk.isEmpty() &amp;&amp; stk.peek() - &#39;a&#39; &lt;= min)
                res.append(stk.pop());
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-矩阵中和能被-k-整除的路径" tabindex="-1"><a class="header-anchor" href="#problem-d-矩阵中和能被-k-整除的路径" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/" target="_blank" rel="noopener noreferrer">矩阵中和能被 K 整除的路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：动态规划</strong></p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://gitee.com/paramhh/blog/edit/main/demo/src/posts/article2.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/10/10 00:26:35</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1061709994@qq.com">huan</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/blog/posts/article1.html" class="nav-link prev" aria-label="刷题笔记"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="icon iconfont icon-article"></span>刷题笔记</div></a><a href="/blog/posts/article3.html" class="nav-link next" aria-label="算法模板"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">算法模板<span class="icon iconfont icon-article"></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">主题: VuePress Theme Hope</div><div class="copyright">Copyright © 2022 huan</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.a2846b5d.js" defer></script>
  </body>
</html>
