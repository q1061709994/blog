<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.49" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://github.com/q1061709994/blog/blog/posts/article2.html"><meta property="og:site_name" content="Huan"><meta property="og:title" content="周赛总结"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-30T02:56:49.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="huan"><meta property="article:tag" content="数据结构与算法"><meta property="article:published_time" content="2022-01-02T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-30T02:56:49.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><link rel="icon" type="image/x-icon" href="/blog/favicon.ico"><title>周赛总结 | Huan</title><meta name="description" content="a blog project">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/blog/assets/style.4f94a94d.css">
    <link rel="modulepreload" href="/blog/assets/app.c628af9c.js"><link rel="modulepreload" href="/blog/assets/article2.html.7eb2757c.js"><link rel="modulepreload" href="/blog/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/blog/assets/article2.html.c9a4b6fa.js"><link rel="prefetch" href="/blog/assets/index.html.f19f41a4.js"><link rel="prefetch" href="/blog/assets/slide.html.3aaec561.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.c0666770.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.b17ce4bc.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.a21f6e7c.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.addf404c.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.87bc2c3e.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.cb546c6e.js"><link rel="prefetch" href="/blog/assets/index.html.d8bb1f63.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.060544bf.js"><link rel="prefetch" href="/blog/assets/article1.html.7e531b1e.js"><link rel="prefetch" href="/blog/assets/article10.html.c5b90527.js"><link rel="prefetch" href="/blog/assets/article11.html.2f80a0ac.js"><link rel="prefetch" href="/blog/assets/article12.html.d1755287.js"><link rel="prefetch" href="/blog/assets/article3.html.c3b12665.js"><link rel="prefetch" href="/blog/assets/article9.html.5972bafc.js"><link rel="prefetch" href="/blog/assets/index.html.bb24b589.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.50e04080.js"><link rel="prefetch" href="/blog/assets/Database.html.647c9082.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.4d478bbb.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.81b6ad1c.js"><link rel="prefetch" href="/blog/assets/disable.html.8423cfb1.js"><link rel="prefetch" href="/blog/assets/encrypt.html.b4588a12.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.a8e96087.js"><link rel="prefetch" href="/blog/assets/markdown.html.e5e200b9.js"><link rel="prefetch" href="/blog/assets/network.html.83ef10c0.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.aef72a2b.js"><link rel="prefetch" href="/blog/assets/page.html.5e8e43ec.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.e04386e3.js"><link rel="prefetch" href="/blog/assets/index.html.c72101b9.js"><link rel="prefetch" href="/blog/assets/article3.html.94707ec0.js"><link rel="prefetch" href="/blog/assets/article4.html.566c6880.js"><link rel="prefetch" href="/blog/assets/article5.html.baf3eb3b.js"><link rel="prefetch" href="/blog/assets/article6.html.ef17c94c.js"><link rel="prefetch" href="/blog/assets/article7.html.bdc9e74f.js"><link rel="prefetch" href="/blog/assets/article8.html.1179c480.js"><link rel="prefetch" href="/blog/assets/716-717.html.a5ca6819.js"><link rel="prefetch" href="/blog/assets/718-719.html.2b6b0c35.js"><link rel="prefetch" href="/blog/assets/720-721.html.37e47418.js"><link rel="prefetch" href="/blog/assets/722-723.html.04256455.js"><link rel="prefetch" href="/blog/assets/724-725.html.876c3e1f.js"><link rel="prefetch" href="/blog/assets/726-727.html.a2197340.js"><link rel="prefetch" href="/blog/assets/728-729.html.6bd1bdba.js"><link rel="prefetch" href="/blog/assets/730-731.html.5480bde6.js"><link rel="prefetch" href="/blog/assets/801-805.html.167ba2bc.js"><link rel="prefetch" href="/blog/assets/806-809.html.598ab85e.js"><link rel="prefetch" href="/blog/assets/810-811.html.7dfd03bb.js"><link rel="prefetch" href="/blog/assets/812-813.html.83728dbf.js"><link rel="prefetch" href="/blog/assets/815-816.html.4624d874.js"><link rel="prefetch" href="/blog/assets/404.html.598608ea.js"><link rel="prefetch" href="/blog/assets/index.html.f9873869.js"><link rel="prefetch" href="/blog/assets/index.html.29e7af3b.js"><link rel="prefetch" href="/blog/assets/index.html.c16d2cab.js"><link rel="prefetch" href="/blog/assets/index.html.4002ce24.js"><link rel="prefetch" href="/blog/assets/index.html.56b7de82.js"><link rel="prefetch" href="/blog/assets/index.html.3d141104.js"><link rel="prefetch" href="/blog/assets/index.html.78fbd65d.js"><link rel="prefetch" href="/blog/assets/index.html.48c256bb.js"><link rel="prefetch" href="/blog/assets/index.html.f2e19447.js"><link rel="prefetch" href="/blog/assets/index.html.70e02a00.js"><link rel="prefetch" href="/blog/assets/index.html.3fd218c9.js"><link rel="prefetch" href="/blog/assets/index.html.beb1e369.js"><link rel="prefetch" href="/blog/assets/index.html.97e1466d.js"><link rel="prefetch" href="/blog/assets/index.html.669e7212.js"><link rel="prefetch" href="/blog/assets/index.html.5813e0a0.js"><link rel="prefetch" href="/blog/assets/index.html.ab2fc4e7.js"><link rel="prefetch" href="/blog/assets/index.html.19513c78.js"><link rel="prefetch" href="/blog/assets/index.html.3a68a554.js"><link rel="prefetch" href="/blog/assets/index.html.c2eda9f4.js"><link rel="prefetch" href="/blog/assets/index.html.7f7f1beb.js"><link rel="prefetch" href="/blog/assets/index.html.98e0c7fb.js"><link rel="prefetch" href="/blog/assets/index.html.16bcb0f4.js"><link rel="prefetch" href="/blog/assets/index.html.a1444922.js"><link rel="prefetch" href="/blog/assets/index.html.487a5bce.js"><link rel="prefetch" href="/blog/assets/index.html.229c50fb.js"><link rel="prefetch" href="/blog/assets/slide.html.a03c9ea7.js"><link rel="prefetch" href="/blog/assets/dog-that-copies-other-people-essay.html.aebf1207.js"><link rel="prefetch" href="/blog/assets/feelings-after-one-month-of-induction-training.html.978fffeb.js"><link rel="prefetch" href="/blog/assets/feelings-of-half-a-year-from-graduation-to-entry.html.ce46bd0a.js"><link rel="prefetch" href="/blog/assets/internet-addiction-teenager.html.2d391c36.js"><link rel="prefetch" href="/blog/assets/javaguide-100k-star.html.57b3a0a2.js"><link rel="prefetch" href="/blog/assets/my-article-was-stolen-and-made-into-video-and-it-became-popular.html.31f4e2a8.js"><link rel="prefetch" href="/blog/assets/index.html.0058d24e.js"><link rel="prefetch" href="/blog/assets/zhishixingqiu-two-years.html.a428b839.js"><link rel="prefetch" href="/blog/assets/article1.html.9c16dfa3.js"><link rel="prefetch" href="/blog/assets/article10.html.1b250c1b.js"><link rel="prefetch" href="/blog/assets/article11.html.ce1c65ec.js"><link rel="prefetch" href="/blog/assets/article12.html.7cf4c57d.js"><link rel="prefetch" href="/blog/assets/article3.html.44f83ca8.js"><link rel="prefetch" href="/blog/assets/article9.html.dc2dff96.js"><link rel="prefetch" href="/blog/assets/index.html.0908d3c0.js"><link rel="prefetch" href="/blog/assets/Computer Network.html.76b7f62f.js"><link rel="prefetch" href="/blog/assets/Database.html.87ef128c.js"><link rel="prefetch" href="/blog/assets/Deep_into_OperatingSystem.html.c41e987a.js"><link rel="prefetch" href="/blog/assets/Design Pattern.html.6cf4966f.js"><link rel="prefetch" href="/blog/assets/disable.html.a60a654c.js"><link rel="prefetch" href="/blog/assets/encrypt.html.88459654.js"><link rel="prefetch" href="/blog/assets/Git-ComdLine-REST.html.eb8df484.js"><link rel="prefetch" href="/blog/assets/markdown.html.bc150ae3.js"><link rel="prefetch" href="/blog/assets/network.html.8bd75bde.js"><link rel="prefetch" href="/blog/assets/Operating Systems.html.3333fe3b.js"><link rel="prefetch" href="/blog/assets/page.html.94401bc1.js"><link rel="prefetch" href="/blog/assets/Python Handbook.html.954c2479.js"><link rel="prefetch" href="/blog/assets/index.html.294a8b34.js"><link rel="prefetch" href="/blog/assets/article3.html.b4fea1b8.js"><link rel="prefetch" href="/blog/assets/article4.html.09cea009.js"><link rel="prefetch" href="/blog/assets/article5.html.8f760304.js"><link rel="prefetch" href="/blog/assets/article6.html.b9b6b9f2.js"><link rel="prefetch" href="/blog/assets/article7.html.2f04adbf.js"><link rel="prefetch" href="/blog/assets/article8.html.f58df5b8.js"><link rel="prefetch" href="/blog/assets/716-717.html.9dc458d0.js"><link rel="prefetch" href="/blog/assets/718-719.html.685d4858.js"><link rel="prefetch" href="/blog/assets/720-721.html.3f5dad59.js"><link rel="prefetch" href="/blog/assets/722-723.html.b175bf50.js"><link rel="prefetch" href="/blog/assets/724-725.html.f33e6dea.js"><link rel="prefetch" href="/blog/assets/726-727.html.4685a289.js"><link rel="prefetch" href="/blog/assets/728-729.html.1466f979.js"><link rel="prefetch" href="/blog/assets/730-731.html.2d9e0697.js"><link rel="prefetch" href="/blog/assets/801-805.html.35c4c451.js"><link rel="prefetch" href="/blog/assets/806-809.html.c9efad55.js"><link rel="prefetch" href="/blog/assets/810-811.html.efff9f79.js"><link rel="prefetch" href="/blog/assets/812-813.html.55dcfcfb.js"><link rel="prefetch" href="/blog/assets/815-816.html.4211f4ec.js"><link rel="prefetch" href="/blog/assets/404.html.7dc7d5d9.js"><link rel="prefetch" href="/blog/assets/index.html.31008c7e.js"><link rel="prefetch" href="/blog/assets/index.html.11b8f0ee.js"><link rel="prefetch" href="/blog/assets/index.html.842c4e75.js"><link rel="prefetch" href="/blog/assets/index.html.8bf684d2.js"><link rel="prefetch" href="/blog/assets/index.html.e6a9a492.js"><link rel="prefetch" href="/blog/assets/index.html.829ccfc4.js"><link rel="prefetch" href="/blog/assets/index.html.f90e11ab.js"><link rel="prefetch" href="/blog/assets/index.html.6410c090.js"><link rel="prefetch" href="/blog/assets/index.html.f26b28fe.js"><link rel="prefetch" href="/blog/assets/index.html.de7fb811.js"><link rel="prefetch" href="/blog/assets/index.html.17c49be7.js"><link rel="prefetch" href="/blog/assets/index.html.7f6821a5.js"><link rel="prefetch" href="/blog/assets/index.html.1e4b1b7b.js"><link rel="prefetch" href="/blog/assets/index.html.7ca14074.js"><link rel="prefetch" href="/blog/assets/index.html.d0f574db.js"><link rel="prefetch" href="/blog/assets/index.html.ceb720f7.js"><link rel="prefetch" href="/blog/assets/index.html.af575ecc.js"><link rel="prefetch" href="/blog/assets/index.html.8fa72650.js"><link rel="prefetch" href="/blog/assets/index.html.c549acf2.js"><link rel="prefetch" href="/blog/assets/index.html.c96fb014.js"><link rel="prefetch" href="/blog/assets/index.html.3df16dd9.js"><link rel="prefetch" href="/blog/assets/index.html.769c69bf.js"><link rel="prefetch" href="/blog/assets/index.html.2ed929e0.js"><link rel="prefetch" href="/blog/assets/index.html.faabca17.js"><link rel="prefetch" href="/blog/assets/404.10cc9a97.js"><link rel="prefetch" href="/blog/assets/Layout.76da7024.js"><link rel="prefetch" href="/blog/assets/Slide.db40c871.js"><link rel="prefetch" href="/blog/assets/Blog.2808f186.js"><link rel="prefetch" href="/blog/assets/auto.esm.2565cd3a.js"><link rel="prefetch" href="/blog/assets/index.d8a59108.js"><link rel="prefetch" href="/blog/assets/index.1842ee54.js"><link rel="prefetch" href="/blog/assets/mermaid.esm.min.ee1e0284.js"><link rel="prefetch" href="/blog/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/blog/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/blog/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/blog/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/blog/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/blog/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/blog/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/blog/assets/photoswipe.esm.218074cd.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/blog/" class="brand"><img class="logo" src="/blog/logo.svg" alt="Huan"><!----><span class="site-name hide-in-pad">Huan</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/blog/guide/" class="nav-link" aria-label="基础"><span class="icon iconfont icon-creative"></span>基础<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/posts/" class="nav-link active" aria-label="算法"><span class="icon iconfont icon-edit"></span>算法<!----></a></div><div class="nav-item hide-in-mobile"><a href="/blog/tem" class="nav-link" aria-label="关于作者"><span class="icon iconfont icon-note"></span>关于作者<!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://github.com/q1061709994/blog" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/blog/posts/article1.html" class="nav-link sidebar-link sidebar-page" aria-label="刷题笔记"><span class="icon iconfont icon-article"></span>刷题笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/blog/posts/article2.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="周赛总结"><span class="icon iconfont icon-article"></span>周赛总结<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_82场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="82场双周赛"><!---->82场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_301场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="301场周赛"><!---->301场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_302场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="302场周赛"><!---->302场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_83场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="83场双周赛"><!---->83场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_303场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="303场周赛"><!---->303场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_304场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="304场周赛"><!---->304场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="84场双周赛"><!---->84场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_305场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="305场周赛"><!---->305场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_306场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="306场周赛"><!---->306场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛-1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="84场双周赛"><!---->84场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_307场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="307场周赛"><!---->307场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_308场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="308场周赛"><!---->308场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_86场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="86场双周赛"><!---->86场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_309场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="309场周赛"><!---->309场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_310场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="310场周赛"><!---->310场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_87场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="87场双周赛"><!---->87场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_311场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="311场周赛"><!---->311场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_312场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="312场周赛"><!---->312场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_88场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="88场双周赛"><!---->88场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_313场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="313场周赛"><!---->313场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_314场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="314场周赛"><!---->314场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_89场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="89场双周赛"><!---->89场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_315场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="315场周赛"><!---->315场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_316场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="316场周赛"><!---->316场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_90场双周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="90场双周赛"><!---->90场双周赛<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/blog/posts/article2.html#_317场周赛" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="317场周赛"><!---->317场周赛<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li><li><!--[--><a href="/blog/posts/article3.html" class="nav-link sidebar-link sidebar-page" aria-label="算法模板"><span class="icon iconfont icon-article"></span>算法模板<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">暑期集训</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-note"></span><span class="title">文章</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="icon iconfont icon-article"></span>周赛总结</h1><div class="page-info"><span class="author-info" aria-label="作者" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="author-item">huan</span></span><span property="author" content="huan"></span></span><!----><span class="date-info" aria-label="写作日期" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年1月2日</span><meta property="datePublished" content="2022-01-02T00:00:00.000Z"></span><span class="category-info" aria-label="分类" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><ul class="categories-wrapper"><li class="category clickable" role="navigation">算法笔记</li><meta property="articleSection" content="算法笔记"></ul></span><span aria-label="标签" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><ul class="tags-wrapper"><li class="tag clickable" role="navigation">数据结构与算法</li></ul><meta property="keywords" content="数据结构与算法"></span><span class="words-info" aria-label="字数" localizeddate="2022年1月2日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 10412 字</span><meta property="wordCount" content="10412"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_82场双周赛" class="router-link-active router-link-exact-active toc-link level2">82场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_301场周赛" class="router-link-active router-link-exact-active toc-link level2">301场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_302场周赛" class="router-link-active router-link-exact-active toc-link level2">302场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_83场双周赛" class="router-link-active router-link-exact-active toc-link level2">83场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_303场周赛" class="router-link-active router-link-exact-active toc-link level2">303场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_304场周赛" class="router-link-active router-link-exact-active toc-link level2">304场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛" class="router-link-active router-link-exact-active toc-link level2">84场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_305场周赛" class="router-link-active router-link-exact-active toc-link level2">305场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_306场周赛" class="router-link-active router-link-exact-active toc-link level2">306场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_84场双周赛-1" class="router-link-active router-link-exact-active toc-link level2">84场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_307场周赛" class="router-link-active router-link-exact-active toc-link level2">307场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_308场周赛" class="router-link-active router-link-exact-active toc-link level2">308场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_86场双周赛" class="router-link-active router-link-exact-active toc-link level2">86场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_309场周赛" class="router-link-active router-link-exact-active toc-link level2">309场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_310场周赛" class="router-link-active router-link-exact-active toc-link level2">310场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_87场双周赛" class="router-link-active router-link-exact-active toc-link level2">87场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_311场周赛" class="router-link-active router-link-exact-active toc-link level2">311场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_312场周赛" class="router-link-active router-link-exact-active toc-link level2">312场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_88场双周赛" class="router-link-active router-link-exact-active toc-link level2">88场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_313场周赛" class="router-link-active router-link-exact-active toc-link level2">313场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_314场周赛" class="router-link-active router-link-exact-active toc-link level2">314场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_89场双周赛" class="router-link-active router-link-exact-active toc-link level2">89场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_315场周赛" class="router-link-active router-link-exact-active toc-link level2">315场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_316场周赛" class="router-link-active router-link-exact-active toc-link level2">316场周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_90场双周赛" class="router-link-active router-link-exact-active toc-link level2">90场双周赛</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/blog/posts/article2.html#_317场周赛" class="router-link-active router-link-exact-active toc-link level2">317场周赛</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="_82场双周赛" tabindex="-1"><a class="header-anchor" href="#_82场双周赛" aria-hidden="true">#</a> 82场双周赛</h2><h4 id="problem-a-计算布尔二叉树的值" tabindex="-1"><a class="header-anchor" href="#problem-a-计算布尔二叉树的值" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/evaluate-boolean-binary-tree/" target="_blank" rel="noopener noreferrer">计算布尔二叉树的值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：递归&amp;模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean evaluateTree(TreeNode root) {
        boolean ans = dfs(root);
        return ans;
    }
    public boolean dfs(TreeNode root) {
        if (root.left == null &amp;&amp; root.right == null) return root.val == 1 ? true : false;
        else {
            boolean l = dfs(root.left), r = dfs(root.right);
            if (root.val == 2) return l || r;
            else return l &amp;&amp; r;
        }
    } 
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-坐上公交的最晚时间" tabindex="-1"><a class="header-anchor" href="#problem-b-坐上公交的最晚时间" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/the-latest-time-to-catch-a-bus/" target="_blank" rel="noopener noreferrer">坐上公交的最晚时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;双指针</strong></p><p><strong>由于求的是最晚到达公交站的时间，根据贪心容易得到，这个时间要么是某个公交的发车时间，要么比某个乘客早到 11 单位时间。因此我们通过 two pointers 的方式模拟上车过程，并枚举所有可能的答案：</strong></p><p><strong>1、当一个乘客在 t 时刻到达时，我们尝试抢先在它之前上车。只要不存在 (t - 1)(t−1) 时刻到达的乘客即可；</strong><strong>2、当公交发车时，若当前公交没有坐满，且不存在发车时到达的乘客，我们可以在这个时刻上车。</strong></p><p><strong>在所有可以上车的时刻中取最大值即可。复杂度 O(<em>n</em>log<em>n</em>)。</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        int n = buses.length, m = passengers.length;
        Arrays.sort(buses);
        Arrays.sort(passengers);
        Set&lt;Integer&gt; s = new HashSet&lt;&gt;();
        for (int x : passengers) s.add(x);
        int ans = 0;
        //双指针模拟上车 i 表示车， j 表示乘客
        for(int i = 0, j = 0; i &lt; buses.length; i ++) {
            int cur = 0;
            while(cur &lt; capacity &amp;&amp; j &lt; passengers.length &amp;&amp; passengers[j] &lt;= buses[i]) {  
                // 如果车 i 还有位置
                if (!s.contains(passengers[j] - 1) &amp;&amp; passengers[j] - 1 &lt;= buses[i]) {  
                    // 如果可以在某乘客前上车(passengers[j] - 1)
                    ans = Math.max(ans, passengers[j] - 1);
                }
                j ++ ;
                cur ++ ;
            }
            // 是否可以卡点上车(车来了再上车)
            if (cur &lt; capacity &amp;&amp; !s.contains(buses[i])){
                ans = Math.max(ans, buses[i]);
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最小差值平方和" tabindex="-1"><a class="header-anchor" href="#problem-c-最小差值平方和" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/minimum-sum-of-squared-difference/" target="_blank" rel="noopener noreferrer">最小差值平方和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二分&amp;贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minSumSquareDiff(int[] a, int[] b, int k1, int k2) {
        int n = a.length, m = k1 + k2;
        for (int i = 0; i &lt; n; i ++ ) a[i] = Math.abs(a[i] - b[i]);

        //二分求出切割线
        int l = 0, r = (int)1e5;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            long sum = 0;
            for (int x : a) if (x &gt; mid) sum += x - mid;
            if (sum &lt;= m) r = mid;
            else l = mid + 1;
        }

        //求出剩余的操作数
        int sum = 0;
        for (int x : a) if (x &gt; r) sum += x - r;
        m -= sum;
        
        //计算答案
        long ans = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            //如果比分割线阈值大
            if (a[i] &gt;= r) {
                //在操作数剩余情况下可以进一步切割
                if (r &gt; 0 &amp;&amp; m &gt; 0) {
                    ans += (long)(r - 1) * (r - 1);
                    m -- ;
                }
                else ans += (long)r * r; 
            } else {
                ans += (long)a[i] * a[i];
            }
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-元素值大于变化阈值的子数组" tabindex="-1"><a class="header-anchor" href="#problem-d-元素值大于变化阈值的子数组" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/subarray-with-elements-greater-than-varying-threshold/" target="_blank" rel="noopener noreferrer">元素值大于变化阈值的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举 &amp; 并查集 &amp; 双指针</strong></p><h2 id="_301场周赛" tabindex="-1"><a class="header-anchor" href="#_301场周赛" aria-hidden="true">#</a> 301场周赛</h2><h4 id="problem-a-装满杯子需要的最短总时长" tabindex="-1"><a class="header-anchor" href="#problem-a-装满杯子需要的最短总时长" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/minimum-amount-of-time-to-fill-cups/" target="_blank" rel="noopener noreferrer">装满杯子需要的最短总时长<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;优先队列 || 排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int fillCups(int[] amount) {
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a);
        for (int x : amount) if (x != 0) q.add(x);
        int ans = 0;
        while (!q.isEmpty()) {
            if (q.size() == 1) {
                ans += q.poll();
                break;
            }
            int a = q.poll(), b = q.poll();
            a --; b -- ;
            if (a != 0) q.add(a);
            if (b != 0) q.add(b);
            ans ++ ;
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-无限集中的最小数字" tabindex="-1"><a class="header-anchor" href="#problem-b-无限集中的最小数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/smallest-number-in-infinite-set/" target="_blank" rel="noopener noreferrer">无限集中的最小数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟&amp;优先队列</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class SmallestInfiniteSet {
    PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();
    public SmallestInfiniteSet() {
        for (int i = 1; i &lt;= 1000; i ++ ) q.add(i);
    }
    
    public int popSmallest() {
        return q.poll();
    }
    
    public void addBack(int num) {
        if (!q.contains(num)) {
            q.add(num);
        }
    }
}

/**
 * Your SmallestInfiniteSet object will be instantiated and called as such:
 * SmallestInfiniteSet obj = new SmallestInfiniteSet();
 * int param_1 = obj.popSmallest();
 * obj.addBack(num);
 */

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-移动片段得到字符串" tabindex="-1"><a class="header-anchor" href="#problem-c-移动片段得到字符串" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/move-pieces-to-obtain-a-string/" target="_blank" rel="noopener noreferrer">移动片段得到字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：双指针</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean canChange(String start, String target) {
        int n = start.length();
        char[] s = start.toCharArray(), t = target.toCharArray();
        int j = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            if (s[i] == &#39;_&#39;) continue;
            while (j &lt; n &amp;&amp; t[j] == &#39;_&#39;) j ++ ;
            if (j == n) return false;
            if (s[i] != t[j]) return false;
            if (t[j] == &#39;L&#39; &amp;&amp; j &gt; i) return false;  
            if (t[j] == &#39;R&#39; &amp;&amp; j &lt; i) return false;
            j ++ ;
        }
        for (int i = j; i &lt; n; i ++ ) 
            if (t[i] != &#39;_&#39;) 
                return false;
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-统计理想数组的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-统计理想数组的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/count-the-number-of-ideal-arrays/" target="_blank" rel="noopener noreferrer">统计理想数组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学 &amp; 递推</strong></p><h2 id="_302场周赛" tabindex="-1"><a class="header-anchor" href="#_302场周赛" aria-hidden="true">#</a> 302场周赛</h2><h4 id="problem-a-数组能形成多少数对" tabindex="-1"><a class="header-anchor" href="#problem-a-数组能形成多少数对" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/maximum-number-of-pairs-in-array/" target="_blank" rel="noopener noreferrer">数组能形成多少数对<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] numberOfPairs(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);
        int[] res = new int[2];
        for (int k : map.keySet()) {
            res[0] += map.get(k) / 2;
            res[1] += map.get(k) % 2;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-数位和相等数对的最大和" tabindex="-1"><a class="header-anchor" href="#problem-b-数位和相等数对的最大和" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/" target="_blank" rel="noopener noreferrer">数位和相等数对的最大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumSum(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        int res = -1;
        for (int x : nums) {
            int s = 0, y = x;
            while (y != 0) {
                s += y % 10;
                y /= 10;
            }
            if (map.containsKey(s)) {
                res = Math.max(res, x + map.get(s));
                map.put(s, Math.max(map.get(s), x));
            } else {
                map.put(s, x);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-裁剪数字后查询第-k-小的数字" tabindex="-1"><a class="header-anchor" href="#problem-c-裁剪数字后查询第-k-小的数字" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/query-kth-smallest-trimmed-number/" target="_blank" rel="noopener noreferrer">裁剪数字后查询第 K 小的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：字符串排序&amp;第二关键字排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] smallestTrimmedNumbers(String[] a, int[][] b) {
        int n = a.length, m = a[0].length();
        int[] ans = new int[b.length];
        for (int i = 0; i &lt; b.length; i ++ ) {
            int k = b[i][0], trim = b[i][1];
            String[][] ss = new String[n][2];
            for (int j = 0; j &lt; n; j ++ ) {
                ss[j][0] = a[j].substring(m - trim);
                ss[j][1] = String.valueOf(j);
            }
            Arrays.sort(ss, (o1, o2) -&gt; {
                int x = o1[0].compareTo(o2[0]);
                return x == 0 ? Integer.parseInt(o1[1]) -  Integer.parseInt(o2[1]): x;
            });
            ans[i] = Integer.parseInt(ss[k - 1][1]);
        }
        return ans;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-使数组可以被整除的最少删除次数" tabindex="-1"><a class="header-anchor" href="#problem-d-使数组可以被整除的最少删除次数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-array-divisible/" target="_blank" rel="noopener noreferrer">使数组可以被整除的最少删除次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
    public int minOperations(int[] a, int[] b) {
        int res = 0;
        Arrays.sort(a);
        int d = 0;
        for (var x: b) d = gcd(d, x);
        for (int i = 0; i &lt; a.length; i ++ ) {
            if (d % a[i] == 0) break;
            res ++ ;
        }
        if (res == a.length) res = -1;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_83场双周赛" tabindex="-1"><a class="header-anchor" href="#_83场双周赛" aria-hidden="true">#</a> 83场双周赛</h2><h4 id="problem-a-最好的扑克手牌" tabindex="-1"><a class="header-anchor" href="#problem-a-最好的扑克手牌" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/best-poker-hand/" target="_blank" rel="noopener noreferrer">最好的扑克手牌<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String bestHand(int[] ranks, char[] suits) {
        // 记录花色种类的 set
        Set&lt;Character&gt; st = new HashSet();
        // 记录每个数字出现几次
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : ranks) map.put(x, map.getOrDefault(x, 0) + 1);
        for (char c : suits) st.add(c);
        // 只有一种花色
        if (st.size() == 1) return &quot;Flush&quot;;
        int mx = 0;
        for (int x : map.keySet()) mx = Math.max(mx, map.get(x));
        // 判断出现最多的数字出现了几次
        if (mx &gt;= 3) return &quot;Three of a Kind&quot;;
        else if (mx == 2) return &quot;Pair&quot;;
        else return &quot;High Card&quot;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-全-0-子数组的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-全-0-子数组的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/number-of-zero-filled-subarrays/" target="_blank" rel="noopener noreferrer">全 0 子数组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long zeroFilledSubarray(int[] nums) {
        long res = 0;
        int n = nums.length;
        for (int i = 0; i &lt; n; i ++ ) {
            if (nums[i] != 0) continue;
            if (nums[i] == 0) res ++ ;
            int j = i;
            while (j + 1 &lt; n &amp;&amp; nums[j + 1] == 0) {
                j ++ ;
                res += j - i + 1;
            }
            i = j;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-设计数字容器系统" tabindex="-1"><a class="header-anchor" href="#problem-c-设计数字容器系统" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/design-a-number-container-system/" target="_blank" rel="noopener noreferrer">设计数字容器系统<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class NumberContainers {
    Map&lt;Integer, Integer&gt; m1 = new HashMap&lt;&gt;();
    Map&lt;Integer, TreeSet&lt;Integer&gt;&gt; m2 = new HashMap&lt;&gt;();
    public NumberContainers() {
        
    }
    
    public void change(int index, int number) {
        if (m1.containsKey(index)) {
            int t = m1.get(index);
            TreeSet&lt;Integer&gt; S = m2.get(t);
            S.remove(index);
            if (S.size() &gt; 0) m2.put(t, S);
            else m2.remove(t);
        }
        m1.put(index, number);
        TreeSet&lt;Integer&gt; q = m2.getOrDefault(number, new TreeSet&lt;Integer&gt;());
        q.add(index);
        m2.put(number, q);
    }
    
    public int find(int number) {
        if (m2.containsKey(number)) return m2.get(number).first();
        else return -1;
    }
}

/**
 * Your NumberContainers object will be instantiated and called as such:
 * NumberContainers obj = new NumberContainers();
 * obj.change(index,number);
 * int param_2 = obj.find(number);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-不可能得到的最短骰子序列" tabindex="-1"><a class="header-anchor" href="#problem-d-不可能得到的最短骰子序列" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/shortest-impossible-sequence-of-rolls/" target="_blank" rel="noopener noreferrer">不可能得到的最短骰子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><h2 id="_303场周赛" tabindex="-1"><a class="header-anchor" href="#_303场周赛" aria-hidden="true">#</a> 303场周赛</h2><h4 id="problem-a-第一个出现两次的字母" tabindex="-1"><a class="header-anchor" href="#problem-a-第一个出现两次的字母" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/first-letter-to-appear-twice/" target="_blank" rel="noopener noreferrer">第一个出现两次的字母<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public char repeatedCharacter(String s) {
        int[] map = new int[128];
        for (char x : s.toCharArray()) {
            if (map[x] == 1) return x;
            map[x] ++ ;
        }
        return &#39;a&#39;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-相等行列对" tabindex="-1"><a class="header-anchor" href="#problem-b-相等行列对" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/equal-row-and-column-pairs/" target="_blank" rel="noopener noreferrer">相等行列对<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int equalPairs(int[][] g) {
        int n = g.length, m = g[0].length;
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                int t = 0;
                while (t &lt; n &amp;&amp; g[i][t] == g[t][j]) t ++ ;
                if (t == n) res ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-设计食物评分系统" tabindex="-1"><a class="header-anchor" href="#problem-c-设计食物评分系统" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/design-a-food-rating-system/" target="_blank" rel="noopener noreferrer">设计食物评分系统<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class FoodRatings {
    Map&lt;String, TreeSet&lt;Pair&lt;Integer, String&gt;&gt;&gt; hash = new HashMap&lt;&gt;();
    Map&lt;String, String&gt; c = new HashMap&lt;&gt;();
    Map&lt;String, Integer&gt; r = new HashMap&lt;&gt;();
    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        for (int i = 0; i &lt; foods.length; i ++ ) {
            c.put(foods[i], cuisines[i]);
            r.put(foods[i], ratings[i]);
            TreeSet&lt;Pair&lt;Integer, String&gt;&gt; S = hash.getOrDefault(cuisines[i], new TreeSet&lt;&gt;((o1, o2) -&gt; {
                return o1.getKey().equals(o2.getKey()) ? o1.getValue().compareTo(o2.getValue()) : o1.getKey() - o2.getKey();
            }));
            S.add(new Pair&lt;&gt;(-ratings[i], foods[i]));
            hash.put(cuisines[i], S);
        }
    }
    
    public void changeRating(String food, int newRating) {
        String cuisine = c.get(food);
        hash.get(cuisine).remove(new Pair(-r.get(food), food));
        r.put(food, newRating);
        TreeSet&lt;Pair&lt;Integer, String&gt;&gt; S = hash.get(cuisine);
        S.add(new Pair(-newRating, food));
        hash.put(cuisine, S);
    }
    
    public String highestRated(String cuisine) {
        return hash.get(cuisine).first().getValue();
    }
}

/**
 * Your FoodRatings object will be instantiated and called as such:
 * FoodRatings obj = new FoodRatings(foods, cuisines, ratings);
 * obj.changeRating(food,newRating);
 * String param_2 = obj.highestRated(cuisine);
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-优质数对的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-优质数对的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/number-of-excellent-pairs/" target="_blank" rel="noopener noreferrer">优质数对的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><p>第i位在两个数里出现几次那么它对答案的贡献就是几</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countExcellentPairs(int[] nums, int k) {
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        for (int x : nums) set.add(x);
        int[] cnt = new int[30];
        for (int x : set) {
            int t = 0;
            while (x != 0) {
                t += x &amp; 1;
                x &gt;&gt;= 1;
            }
            cnt[t] ++ ;
        }
        long res = 0;
        for (int i = 0; i &lt; 30; i ++ ) {
            for (int j = 0; j &lt; 30; j ++ ) {
                if (i + j &gt;= k) 
                    res += cnt[i] * cnt[j];
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_304场周赛" tabindex="-1"><a class="header-anchor" href="#_304场周赛" aria-hidden="true">#</a> 304场周赛</h2><h4 id="problem-a-使数组中所有元素都等于零" tabindex="-1"><a class="header-anchor" href="#problem-a-使数组中所有元素都等于零" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/make-array-zero-by-subtracting-equal-amounts/" target="_blank" rel="noopener noreferrer">使数组中所有元素都等于零<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumOperations(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int x : nums) 
            if (x &gt; 0) 
                set.add(x);
        return set.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-分组的最大数量" tabindex="-1"><a class="header-anchor" href="#problem-b-分组的最大数量" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/maximum-number-of-groups-entering-a-competition/" target="_blank" rel="noopener noreferrer">分组的最大数量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumGroups(int[] g) {
        int res = 0, cnt = 1, n = g.length;
        while (cnt &lt;= n) {
            res ++ ;
            n -= cnt;
            cnt ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-找到离给定两个节点最近的节点" tabindex="-1"><a class="header-anchor" href="#problem-c-找到离给定两个节点最近的节点" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/find-closest-node-to-given-two-nodes/" target="_blank" rel="noopener noreferrer">找到离给定两个节点最近的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int closestMeetingNode(int[] p, int x, int y) {
        int n = p.length;
        int[] d1 = new int[n], d2 = new int[n];
        Arrays.fill(d1, -1); Arrays.fill(d2, -1);
        d1[x] = 0; d2[y] = 0;
        //两次dfs求距离
        while (p[x] != -1) {
            if (d1[p[x]] != -1) break;
            d1[p[x]] = d1[x] + 1;
            x = p[x];
        }
        while (p[y] != -1) {
            if (d2[p[y]] != -1) break;
            d2[p[y]] = d2[y] + 1;
            y = p[y];
        }
        int max = -1, res = -1;
        for (int i = 0; i &lt; n; i ++ ) {
            int a = d1[i], b = d2[i];
            if (a != -1 &amp;&amp; b != -1) {
                if (max == -1 || max &gt; Math.max(a, b)) {
                    max = Math.max(a, b);
                    res = i;
                }
            }
        }  
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-图中的最长环" tabindex="-1"><a class="header-anchor" href="#problem-d-图中的最长环" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/longest-cycle-in-a-graph/" target="_blank" rel="noopener noreferrer">图中的最长环<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] p, in_stk;
    boolean[] st;
    int n, res = -1;
    public int longestCycle(int[] _p) {
        n = _p.length;
        p = _p;
        st = new boolean[n];
        in_stk = new int[n];
        for (int i = 0; i &lt; n; i ++ ) 
            if (!st[i])
                dfs(i, 1);
        return res;
    }
    //u：当前搜到的点的下标
    //depth：当前点的深度
    public void dfs(int u, int depth) {
        st[u] = true;
        in_stk[u] = depth;
        int j = p[u];
        if (j != -1) {
            if (!st[j]) 
                dfs(j, depth + 1);
            else if (in_stk[j] &gt; 0)
                // 当in_stk[j]大于0说明搜到了环，并且in_stk[j]为环的起点的深度
                res = Math.max(res, depth + 1 - in_stk[j]);
        }
        in_stk[u] = 0;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_84场双周赛" tabindex="-1"><a class="header-anchor" href="#_84场双周赛" aria-hidden="true">#</a> 84场双周赛</h2><h4 id="problem-a-合并相似的物品" tabindex="-1"><a class="header-anchor" href="#problem-a-合并相似的物品" aria-hidden="true">#</a> Problem A - <a href="https://leetcode-cn.com/problems/merge-similar-items/" target="_blank" rel="noopener noreferrer">合并相似的物品<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;Integer&gt;&gt; mergeSimilarItems(int[][] a, int[][] b) {
        TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();
        for (int[] x : a) {
            map.put(x[0], map.getOrDefault(x[0], 0) + x[1]);
        }
        for (int[] x : b) {
            map.put(x[0], map.getOrDefault(x[0], 0) + x[1]);
        }
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        for (int k : map.keySet()) {
            List&lt;Integer&gt; t = new ArrayList&lt;&gt;();
            t.add(k);
            t.add(map.get(k));
            res.add(t);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-统计坏数对的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-统计坏数对的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode-cn.com/problems/count-number-of-bad-pairs/" target="_blank" rel="noopener noreferrer">统计坏数对的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countBadPairs(int[] nums) {
        long n = nums.length;
        for (int i = 0; i &lt; n; i ++ ) nums[i] -= i;
        long res = n * (n - 1l) / 2;
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) map.put(x, map.getOrDefault(x, 0) + 1);
        for (int k : map.keySet()) {
            int v = map.get(k);
            if (v == 1) continue;
            else {
                res -= v * (v - 1l) / 2;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-任务调度器-ii" tabindex="-1"><a class="header-anchor" href="#problem-c-任务调度器-ii" aria-hidden="true">#</a> Problem C - <a href="https://leetcode-cn.com/problems/task-scheduler-ii/" target="_blank" rel="noopener noreferrer">任务调度器 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟&amp;贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long taskSchedulerII(int[] q, int space) {
        int n = q.length;
        long res = 0;
        Map&lt;Integer, Long&gt; map = new HashMap&lt;&gt;();
        for (int x : q) {
            res ++ ;
            if (!map.containsKey(x))
                map.put(x, res);
            else {
                if (res - map.get(x) &lt;= space) 
                    res = map.get(x) + space + 1;
                map.put(x, res);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-将数组排序的最少替换次数" tabindex="-1"><a class="header-anchor" href="#problem-d-将数组排序的最少替换次数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode-cn.com/problems/minimum-replacements-to-sort-the-array/" target="_blank" rel="noopener noreferrer">将数组排序的最少替换次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心&amp;数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minimumReplacement(int[] nums) {
        long res = 0;
        int n = nums.length, last = nums[n - 1];
        for (int i = n - 2; i &gt;= 0; i -- ) {
            if (nums[i] &gt; last) {
            	//拆的次数
                int x = (nums[i] + last - 1) / last;
                res += x - 1;
                //拆出来的最小数，nums[i]/(拆的次数)向下取整
                last = nums[i] / x;
            } else {
                last = nums[i];
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_305场周赛" tabindex="-1"><a class="header-anchor" href="#_305场周赛" aria-hidden="true">#</a> 305场周赛</h2><h4 id="problem-a-算术三元组的数目" tabindex="-1"><a class="header-anchor" href="#problem-a-算术三元组的数目" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/" target="_blank" rel="noopener noreferrer">算术三元组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int arithmeticTriplets(int[] nums, int diff) {
        int n = nums.length;
        int res = 0;
        for (int i = 0; i &lt; n - 2; i ++ ) 
            for (int j = i + 1; j &lt; n - 1; j ++ )
                for (int k = j + 1; k &lt; n; k ++ ) {
                    if ((nums[j] - nums[i] == diff) &amp;&amp; (nums[k] - nums[j] == diff)) 
                        res ++ ;
                }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-受限条件下可到达节点的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-受限条件下可到达节点的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions/" target="_blank" rel="noopener noreferrer"> 受限条件下可到达节点的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    List&lt;Integer&gt;[] g;
    boolean[] r;
    int res = 0;
    public void dfs(int i, int j) {
        res ++ ;
        for (int x : g[j]) 
            if (x != i &amp;&amp; !r[x]) 
                dfs(j, x);
    }
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        g = new List[n];
        for (int i = 0; i &lt; n; i ++ ) g[i] = new ArrayList&lt;&gt;();
        r = new boolean[n];
        //标记受限节点
        for (int x : restricted) r[x] = true;
        //建图
        for (int[] x : edges) {
            int a = x[0], b = x[1];
            g[a].add(b);
            g[b].add(a);
        }
        dfs(0, 0);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：bfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int reachableNodes(int n, int[][] edges, int[] restricted) {
        List&lt;Integer&gt;[] g = new List[n];
        boolean[] r;
        int res = 1;
        for (int i = 0; i &lt; n; i ++ ) g[i] = new ArrayList&lt;&gt;();
        r = new boolean[n];
        for (int x : restricted) r[x] = true;
        //建图
        for (int[] x : edges) {
            int a = x[0], b = x[1];
            g[a].add(b);
            g[b].add(a);
        }
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(0);
        r[0] = true;
        while (!q.isEmpty()) {
            int cur = q.poll();
            for (int x : g[cur]) {
                if (!r[x]) {
                    res ++ ;
                    r[x] = true;
                    q.add(x);
                }
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-检查数组是否存在有效划分" tabindex="-1"><a class="header-anchor" href="#problem-c-检查数组是否存在有效划分" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/" target="_blank" rel="noopener noreferrer">检查数组是否存在有效划分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean validPartition(int[] nums) {
        var n = nums.length;
        //设 f(i) 表示以 i 结尾的数组是否存在有效划分。i 的有效下标从 1 开始
        var f = new boolean[n + 1];
        f[0] = true;
        for (int i = 2; i &lt;= n; i ++ ) {
            if (nums[i - 1] == nums[i - 2]) 
                f[i] = f[i - 2];
            
            if (i &gt;= 3 &amp;&amp; nums[i - 1] == nums[i - 2] &amp;&amp; nums[i - 1] == nums[i - 3])
                f[i] = f[i] || f[i - 3];
            
            if (i &gt;= 3 &amp;&amp; nums[i - 1] == nums[i - 2] + 1 &amp;&amp; nums[i - 2] == nums[i - 3] + 1)
                f[i] = f[i] || f[i - 3];
        }
        return f[n];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-最长理想子序列" tabindex="-1"><a class="header-anchor" href="#problem-d-最长理想子序列" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/longest-ideal-subsequence/" target="_blank" rel="noopener noreferrer">最长理想子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestIdealString(String s, int k) {
        //记 f[d] 表示以字符 d 为结尾的最长理想子序列。
        var f = new int[26];
        var n = s.length();
        for (var c : s.toCharArray()) {
            var x = c - &#39;a&#39;;
            var t = 0;
            //满足Math.abs(x - y) &lt;= k就能将字符x接在以y结尾的子序列后边
            for (int y = 0; y &lt; 26; y ++ ) 
                if (Math.abs(x - y) &lt;= k)
                    t = Math.max(t, f[y] + 1);
            f[x] = Math.max(f[x], t);
        }
        return Arrays.stream(f).max().getAsInt();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_306场周赛" tabindex="-1"><a class="header-anchor" href="#_306场周赛" aria-hidden="true">#</a> 306场周赛</h2><h4 id="problem-a-矩阵中的局部最大值" tabindex="-1"><a class="header-anchor" href="#problem-a-矩阵中的局部最大值" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/" target="_blank" rel="noopener noreferrer">矩阵中的局部最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[][] largestLocal(int[][] g) {
        int n = g.length, m = g[0].length;
        int[][] res = new int[n - 2][m - 2];
        for (int i = 0; i &lt; n - 2; i ++ ) 
            for (int j = 0; j &lt; m - 2; j ++ )
                for (int x = 0; x &lt; 3; x ++ )
                    for (int y = 0; y &lt; 3; y ++ ) 
                        res[i][j] = Math.max(res[i][j], g[i + x][j + y]);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-边积分最高的节点" tabindex="-1"><a class="header-anchor" href="#problem-b-边积分最高的节点" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/node-with-highest-edge-score/" target="_blank" rel="noopener noreferrer">边积分最高的节点<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int edgeScore(int[] edges) {
        int n = edges.length;
        long[] f = new long[n];
        for (int i = 0; i &lt; n; i ++ ) {
            f[edges[i]] += i;
        }
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) 
            if (f[i] &gt; f[res]) 
                res = i;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-根据模式串构造最小数字" tabindex="-1"><a class="header-anchor" href="#problem-c-根据模式串构造最小数字" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/construct-smallest-number-from-di-string/" target="_blank" rel="noopener noreferrer">根据模式串构造最小数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String smallestNumber(String pattern) {
        int n = pattern.length();
        int[] num = new int[n + 1];
        for (int i = 0; i &lt;= n; i ++ ) 
            num[i] = i + 1;
        for (int i = 0; i &lt; n; i ++ ) {
            if (pattern.charAt(i) == &#39;D&#39;) {
                int j = i;
                while (j &lt; n &amp;&amp; pattern.charAt(j) == &#39;D&#39;) j ++ ;
                reverse(num, i, j);
                i = j - 1;
            }
        }
        StringBuilder res = new StringBuilder();
        for (int x : num) res.append(x);
        return res.toString();
    }
    public void reverse(int[] nums, int i, int j) {
        while (i &lt; j) {
            var x = nums[i];
            nums[i] = nums[j];
            nums[j] = x;
            i ++ ;
            j -- ;
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：暴力</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    boolean[] st;
    String p;
    public String smallestNumber(String _p) {
        p = _p;
        int n = p.length();
        int[] nums = new int[n + 1];
        for (int i = 0; i &lt; n + 1; i ++ ) 
            nums[i] = i + 1;

        while (!check(nums)) {
            nextPermutation(nums);
        }
        var res = &quot;&quot;;
        for (var x : nums) res += x;
        return res;
    }
    public void nextPermutation(int[] nums) {
        int k = nums.length - 1;
        while (k &gt; 0 &amp;&amp; nums[k - 1] &gt;= nums[k]) k -- ;
        if (k == 0) Arrays.sort(nums);
        else {
            int t = k;
            while (t + 1 &lt; nums.length &amp;&amp; nums[t + 1] &gt; nums[k - 1]) t ++ ;
            swap(nums, k - 1, t);
            reverse(nums, k, nums.length - 1);
        }
    }

    public void swap(int[] nums, int l, int r) {
        int t = nums[l];
        nums[l] = nums[r];
        nums[r] = t;
    }

    public void reverse(int[] nums, int l, int r) {
        while (l &lt; r) {
            swap(nums, l, r);
            l ++ ;
            r -- ;
        }
    }
    public boolean check(int[] nums) {
        for (int i = 0; i &lt; p.length(); i ++ ) {
            char c = p.charAt(i);
            if (c == &#39;I&#39; &amp;&amp; nums[i] &gt;= nums[i + 1])
                return false; 
            if (c == &#39;D&#39; &amp;&amp; nums[i] &lt;= nums[i + 1])
                return false; 
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-统计特殊整数" tabindex="-1"><a class="header-anchor" href="#problem-d-统计特殊整数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/count-special-integers/" target="_blank" rel="noopener noreferrer">统计特殊整数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数位dp</strong></p><h2 id="_84场双周赛-1" tabindex="-1"><a class="header-anchor" href="#_84场双周赛-1" aria-hidden="true">#</a> 84场双周赛</h2><h4 id="problem-a-得到-k-个黑块的最少涂色次数" tabindex="-1"><a class="header-anchor" href="#problem-a-得到-k-个黑块的最少涂色次数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/" target="_blank" rel="noopener noreferrer">得到 K 个黑块的最少涂色次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：滑动窗口</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimumRecolors(String s, int k) {
        int res = 100;
        for (int i = 0, j = 0, cnt = 0; i &lt; s.length(); i ++ ) {
            if (s.charAt(i) == &#39;W&#39;) cnt ++ ;
            if (i - j + 1 &gt; k) {
                if (s.charAt(j) == &#39;W&#39;) cnt -- ;
                j ++ ;
            }
            if (i &gt;= k - 1) res = Math.min(cnt, res);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-二进制字符串重新安排顺序需要的时间" tabindex="-1"><a class="header-anchor" href="#problem-b-二进制字符串重新安排顺序需要的时间" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/" target="_blank" rel="noopener noreferrer">二进制字符串重新安排顺序需要的时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int secondsToRemoveOccurrences(String s) {
        int res = 0;
        while (s.contains(&quot;01&quot;)) {
           res ++ ;
           s = s.replaceAll(&quot;01&quot;, &quot;10&quot;);
        }  
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-字母移位-ii" tabindex="-1"><a class="header-anchor" href="#problem-c-字母移位-ii" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/shifting-letters-ii/" target="_blank" rel="noopener noreferrer">字母移位 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：差分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        char[] c = s.toCharArray();
        int n = s.length();
        int[] t = new int[n + 1];
        for (int[] p : shifts) {
            int a = p[0], b = p[1], w = p[2];
            if (w == 0) w = -1;
            t[a] += w;
            t[b + 1] -= w;
        }
        for (int i = 0, cur = 0; i &lt; n; i ++ ) {
            cur += t[i];
            cur %= 26;
            int p = c[i] - &#39;a&#39;;
            p += cur;
            p = (p + 26) % 26;
            c[i] = (char) (p + &#39;a&#39;);
        }
        return new String(c);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-删除操作后的最大子段和" tabindex="-1"><a class="header-anchor" href="#problem-d-删除操作后的最大子段和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-segment-sum-after-removals/" target="_blank" rel="noopener noreferrer">删除操作后的最大子段和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><h2 id="_307场周赛" tabindex="-1"><a class="header-anchor" href="#_307场周赛" aria-hidden="true">#</a> 307场周赛</h2><h4 id="problem-a-赢得比赛需要的最少训练时长" tabindex="-1"><a class="header-anchor" href="#problem-a-赢得比赛需要的最少训练时长" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/" target="_blank" rel="noopener noreferrer">赢得比赛需要的最少训练时长<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minNumberOfHours(int a, int b, int[] c, int[] d) {
        int n = c.length;
        int res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            if (a &gt; c[i]) a -= c[i];
            else {
                int x = c[i] + 1 - a;
                a += x - c[i];
                res += x;
            }

            if (b &gt; d[i]) b += d[i];
            else {
                int x = d[i] + 1 - b;
                b += x + d[i];
                res += x;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最大回文数字" tabindex="-1"><a class="header-anchor" href="#problem-b-最大回文数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/largest-palindromic-number/" target="_blank" rel="noopener noreferrer">最大回文数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String largestPalindromic(String s) {
        int[] map = new int[10];
        for (char x : s.toCharArray()) {
            int t = x - &#39;0&#39;;
            map[t] ++ ;
        }
        int a = 0;
        //找出可能要追加的数
        for (int i = 1; i &lt; 10; i ++ )
            if (map[i] % 2 == 1)
                a = i;
        StringBuilder sb = new StringBuilder();
        //拼凑答案的前半部分
        for (int i = 9; i &gt;= 0; i -- ) {
            int t = map[i] / 2;
            if (i == 0 &amp;&amp; sb.length() == 0) break;
            for (int j = 0; j &lt; t; j ++ )
                sb.append(i);
        }

        StringBuilder x = new StringBuilder(sb).reverse();
        //如果可以的话，中间追加一位
        if (map[a] != 0) sb.append(a);
        return sb.toString() + x.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-感染二叉树需要的总时间" tabindex="-1"><a class="header-anchor" href="#problem-c-感染二叉树需要的总时间" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/" target="_blank" rel="noopener noreferrer">感染二叉树需要的总时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs + bfs</strong></p><p>链式前向星建图</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int N = 100010;
    int[] h, e, ne;
    //记录该点是否进入过队列
    boolean[] st;
    int idx;
    public void add(int a, int b) {
        e[idx] = b;
        ne[idx] = h[a];
        h[a] = idx ++ ;
    }
    //dfs建图
    public void dfs(TreeNode root) {
        if (root.left != null) {
            add(root.val, root.left.val);
            add(root.left.val, root.val);
            dfs(root.left);
        }
        if (root.right != null) {
            add(root.val, root.right.val);
            add(root.right.val, root.val);
            dfs(root.right);
        }
    }
    public int amountOfTime(TreeNode root, int start) {
        h = new int[N];
        e = new int[N * 2];
        ne = new int[N * 2];
        st = new boolean[N];
        idx = 0;
        Arrays.fill(h, -1);
        dfs(root);
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(start);
        int res = 0;
        while (!q.isEmpty()) {
            int count = q.size();
            while (count -- &gt; 0) {
                var t = q.poll();
                st[t] = true;           
                for (int i = h[t]; i != -1; i = ne[i]) {
                    int j = e[i];
                    if (st[j]) continue;
                    else q.add(j);
                }
            }
            res ++ ;
        }
        return res - 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs + bfs</strong></p><p>Map建图</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int N = 100010;
    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; g = new HashMap&lt;&gt;();
    boolean[] st;
    public void dfs(TreeNode root) {
        if (root == null) return;
        LinkedList&lt;Integer&gt; list = g.getOrDefault(root.val, new LinkedList&lt;&gt;());
        if (root.left != null) {
            list.add(root.left.val);
            LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();
            temp.add(root.val);
            g.put(root.left.val, temp);
        }
        if (root.right != null) {
            list.add(root.right.val);
            LinkedList&lt;Integer&gt; temp = new LinkedList&lt;&gt;();
            temp.add(root.val);
            g.put(root.right.val, temp);
        }
        g.put(root.val, list);
        dfs(root.left);
        dfs(root.right);
    }
    public int amountOfTime(TreeNode root, int start) {
        dfs(root);
        st = new boolean[N];
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        q.add(start);
        int res = -1;
        while (!q.isEmpty()) {
            int count = q.size();
            while (count -- &gt; 0) {
                int x = q.poll();
                st[x] = true;
                List&lt;Integer&gt; list = g.get(x);
                if (list != null) {
                    for (int a : list) 
                    if (!st[a])
                        q.add(a);
                }
            }
            res ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-找出数组的第-k-大和" tabindex="-1"><a class="header-anchor" href="#problem-d-找出数组的第-k-大和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/find-the-k-sum-of-an-array/" target="_blank" rel="noopener noreferrer">找出数组的第 K 大和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：多路归并</strong></p><h2 id="_308场周赛" tabindex="-1"><a class="header-anchor" href="#_308场周赛" aria-hidden="true">#</a> 308场周赛</h2><h4 id="problem-a-和有限的最长子序列" tabindex="-1"><a class="header-anchor" href="#problem-a-和有限的最长子序列" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/longest-subsequence-with-limited-sum/" target="_blank" rel="noopener noreferrer">和有限的最长子序列<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：前缀和 &amp;二分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] answerQueries(int[] nums, int[] q) {
        Arrays.sort(nums);
        int n = nums.length, m = q.length;
        int[] s = new int[n + 1];
        for (int i = 0; i &lt; n; i ++ )
            s[i + 1] = s[i] + nums[i];
        for (int i = 0; i &lt; m; i ++ ) {
            int k = q[i];
            int l = 0, r = n;
            while (l &lt; r) {
                int mid = l + r + 1 &gt;&gt; 1;
                if (s[mid] &lt;= k) l = mid;
                else r = mid - 1;
            }
            q[i] = l;
        }
        return q;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-从字符串中移除星号" tabindex="-1"><a class="header-anchor" href="#problem-b-从字符串中移除星号" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/removing-stars-from-a-string/" target="_blank" rel="noopener noreferrer">从字符串中移除星号<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String removeStars(String s) {
        StringBuilder sb = new StringBuilder();
        for (char x : s.toCharArray()) {
            if (x == &#39;*&#39;) sb.deleteCharAt(sb.length() - 1);
            else sb.append(x);
        }
        return sb.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-收集垃圾的最少总时间" tabindex="-1"><a class="header-anchor" href="#problem-c-收集垃圾的最少总时间" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage/" target="_blank" rel="noopener noreferrer">收集垃圾的最少总时间<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int garbageCollection(String[] g, int[] t) {
        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();
        int a = 0, b = 0, c = 0;
        for (int i = 0; i &lt; g.length; i ++) {
            for (char x : g[i].toCharArray()) {
                if (x == &#39;M&#39;) a ++ ;
                else if (x == &#39;P&#39;) b ++ ;
                else c ++ ;
                map.put(x, i);
            }
        }
        int res = a + b + c;
        int[] s = new int[t.length + 1];
        for (int i = 0; i &lt; t.length; i ++ ) 
            s[i + 1] = s[i] + t[i];
        for (char x : map.keySet()) res += s[map.get(x)];
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-给定条件下构造矩阵" tabindex="-1"><a class="header-anchor" href="#problem-d-给定条件下构造矩阵" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/build-a-matrix-with-conditions/" target="_blank" rel="noopener noreferrer">给定条件下构造矩阵<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：拓扑排序</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] topoSort(int k, int[][] edges) {
        List&lt;Integer&gt;[] g = new List[k];
        Arrays.setAll(g, e -&gt; new ArrayList&lt;&gt;());
        int[] d = new int[k];
        for (var e : edges) {
            int a = e[0] - 1, b = e[1] - 1;
            g[a].add(b);
            d[b] ++ ;
        }
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();
        for (int i = 0; i &lt; k; i ++ )
            if (d[i] == 0)
                q.add(i);
        while (!q.isEmpty()) {
            int t = q.poll();
            res.add(t);
            for (int x : g[t])
                if (-- d[x] == 0)
                    q.add(x);
        }
        return res.stream().mapToInt(x -&gt; x).toArray();
    }
    public int[][] buildMatrix(int k, int[][] row, int[][] col) {
        int[] x = topoSort(k, row), y = topoSort(k, col);
        if (x.length &lt; k || y.length &lt; k) return new int[][]{};
        int[][] res = new int[k][k];
        for (int i = 0; i &lt; k; i ++ )
            for (int j = 0; j &lt; k; j ++ )
                if (x[i] == y[j]) res[i][j] = x[i] + 1;
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_86场双周赛" tabindex="-1"><a class="header-anchor" href="#_86场双周赛" aria-hidden="true">#</a> 86场双周赛</h2><h4 id="problem-a-和相等的子数组" tabindex="-1"><a class="header-anchor" href="#problem-a-和相等的子数组" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/find-subarrays-with-equal-sum/" target="_blank" rel="noopener noreferrer">和相等的子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean findSubarrays(int[] nums) {
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        int n = nums.length;
        for (int i = 0; i &lt; n - 1; i ++ ) {
            int x = nums[i] + nums[i + 1];
            if (set.contains(x)) return true;
            set.add(x);
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-严格回文的数字" tabindex="-1"><a class="header-anchor" href="#problem-b-严格回文的数字" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/strictly-palindromic-number/" target="_blank" rel="noopener noreferrer">严格回文的数字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean f(String s) {
        for (int i = 0, j = s.length() - 1; i &lt; j; i ++ , j -- ) 
            if (i &lt; j &amp;&amp; s.charAt(i) != s.charAt(j)) 
                return false;
        
        return true;
    }
    
    public boolean isStrictlyPalindromic(int n) {
        for (int i = 2; i &lt;= n - 2; i ++ ) {
            StringBuilder sb = new StringBuilder();
            int t = n;
            while (t != 0) {
                sb.append(t % i);
                t /= i;
            }
            if (!f(sb.reverse().toString())) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean isStrictlyPalindromic(int n) {
    	return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-被列覆盖的最多行数" tabindex="-1"><a class="header-anchor" href="#problem-c-被列覆盖的最多行数" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/" target="_blank" rel="noopener noreferrer">被列覆盖的最多行数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二进制枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maximumRows(int[][] g, int cols) {
        int m = g.length, n = g[0].length;
        int res = 0;
        for (int k = 0; k &lt; (1 &lt;&lt; n); k ++ ) {
            if (Integer.bitCount(k) != cols) continue;
            int t = 0;
            out:for (int i = 0; i &lt; m; i ++ ) {
                    for (int j = 0; j &lt; n; j ++ )
                        if ((k &gt;&gt; j &amp; 1) == 0 &amp;&amp; g[i][j] == 1)
                            continue out;
                t ++ ;
            }
            res = Math.max(res, t);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs</strong>、</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[][] g;
    int res = 0;
    int n, m;
    public int maximumRows(int[][] mat, int cols) {
        n = mat.length;
        m = mat[0].length;
        g = mat;
        dfs(0, cols,new HashSet&lt;Integer&gt;());
        return res;
    }
    public void dfs(int u, int k, Set&lt;Integer&gt; set) {
        if (set.size() == k) {
            int t = 0;
            out:for (int i = 0; i &lt; n; i ++ ) {
                for (int j = 0; j &lt; m; j ++ )
                    if (g[i][j] == 1 &amp;&amp; !set.contains(j))
                        continue out;
                t ++ ;
            }
            res = Math.max(res, t);
        } else {
            for (int i = u; i &lt; m; i ++ ) {
                set.add(i);
                dfs(i + 1, k, set);
                set.remove(i);
            }
        }
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-预算内的最多机器人数目" tabindex="-1"><a class="header-anchor" href="#problem-d-预算内的最多机器人数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-number-of-robots-within-budget/" target="_blank" rel="noopener noreferrer">预算内的最多机器人数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：双指针&amp;单调队列</strong></p><h2 id="_309场周赛" tabindex="-1"><a class="header-anchor" href="#_309场周赛" aria-hidden="true">#</a> 309场周赛</h2><h4 id="problem-a-检查相同字母间的距离" tabindex="-1"><a class="header-anchor" href="#problem-a-检查相同字母间的距离" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/check-distances-between-same-letters/" target="_blank" rel="noopener noreferrer">检查相同字母间的距离<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean checkDistances(String s, int[] d) {
        Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; s.length(); i ++ ) {
            char x = s.charAt(i);
            if (!map.containsKey(x - &#39;a&#39;)) map.put(x - &#39;a&#39;, new ArrayList&lt;&gt;());
            map.get(x - &#39;a&#39;).add(i);
        }
        for (int k : map.keySet()) {
            if (map.get(k).get(1) - map.get(k).get(0) == d[k] + 1) continue;
            else return false;
        }
        return true;
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean checkDistances(String s, int[] distance) {
        int[] a = new int[26];
        Arrays.fill(a, -1);
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int x = s.charAt(i) - &#39;a&#39;;
            if (a[x] == -1) a[x] = i;
            else if (i - a[x] != distance[x] + 1) return false;
        }
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-恰好移动-k-步到达某一位置的方法数目" tabindex="-1"><a class="header-anchor" href="#problem-b-恰好移动-k-步到达某一位置的方法数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/" target="_blank" rel="noopener noreferrer">恰好移动 k 步到达某一位置的方法数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数论</strong></p><p>动态规划求组合数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private int mod = (int)1e9 + 7;
    public int numberOfWays(int startPos, int endPos, int k) {
        int d = Math.abs(endPos - startPos);
        if (d &gt; k || (d + k) % 2 == 1) return 0;
        int[][] f = new int[k + 1][k + 1];
        for (int i = 0; i &lt;= k; i ++ ) {
            f[i][0] = 1;
            for (int j = 1; j &lt;= i; j ++ )
                f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % mod;
        }
        return f[k][(d + k) / 2];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逆元求组合数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    private int mod = (int)1e9 + 7;
    
    public int qmi(int m, int k, int p) {
        long res = 1l % p, t = m * 1l;
        while (k != 0) {
            if ((k &amp; 1) != 0) res = res * t % p;
            t = t * t % p;
            k &gt;&gt;= 1;
        }
        return (int)res;
    }

    public int numberOfWays(int startPos, int endPos, int k) {
        int m = Math.abs(endPos - startPos);
        if ((m - k) % 2 != 0 || k &lt; m) return 0;
        int r = (k + m) / 2;
        long res = 1;
        for (int i = k; i &gt; k - r; i -- ) 
            res = res * i % mod;
        for (int i = 1; i &lt;= r; i ++ ) {
            res = res * qmi(i, mod - 2, mod) % mod;
        }
        return (int)res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最长优雅子数组" tabindex="-1"><a class="header-anchor" href="#problem-c-最长优雅子数组" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/longest-nice-subarray/" target="_blank" rel="noopener noreferrer">最长优雅子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：位运算&amp;滑动窗口&amp;状态压缩</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestNiceSubarray(int[] nums) {
        int n = nums.length;
        int res = 0;
        int s = 0;
        for (int i = 0, j = 0; i &lt; n; i ++ ) {
            while ((s &amp; nums[i]) &gt; 0) 
                s ^= nums[j ++ ];
            s ^= nums[i];
            res = Math.max(res, i - j + 1);    
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-会议室-iii" tabindex="-1"><a class="header-anchor" href="#problem-d-会议室-iii" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/meeting-rooms-iii/" target="_blank" rel="noopener noreferrer">会议室 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><h2 id="_310场周赛" tabindex="-1"><a class="header-anchor" href="#_310场周赛" aria-hidden="true">#</a> 310场周赛</h2><h4 id="problem-a-出现最频繁的偶数元素" tabindex="-1"><a class="header-anchor" href="#problem-a-出现最频繁的偶数元素" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/most-frequent-even-element/" target="_blank" rel="noopener noreferrer">出现最频繁的偶数元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int mostFrequentEven(int[] nums) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int x : nums) {
            if (x % 2 == 0) 
                map.put(x, map.getOrDefault(x, 0) + 1);
        }
        int res = -1;
        for (int k : map.keySet()) {
            int v = map.get(k);
            if (res == -1 || map.get(res) &lt; v || (map.get(res) == v &amp;&amp; res &gt; k))
                    res = k;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-子字符串的最优划分" tabindex="-1"><a class="header-anchor" href="#problem-b-子字符串的最优划分" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/optimal-partition-of-string/" target="_blank" rel="noopener noreferrer">子字符串的最优划分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int partitionString(String s) {
        int[] map = new int[26];
        int res = 0;
        for (int i = 0; i &lt; s.length(); i ++ ) {
            int x = s.charAt(i) - &#39;a&#39;;
            map[x] ++ ;
            if (map[x] &gt; 1) {
                res ++ ;
                i -- ;
                map = new int[26];
            }   
        }
        return res + 1;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-将区间分为最少组数" tabindex="-1"><a class="header-anchor" href="#problem-c-将区间分为最少组数" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/" target="_blank" rel="noopener noreferrer">将区间分为最少组数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minGroups(int[][] g) {
        int n = g.length;
        Arrays.sort(g, (a, b) -&gt; a[0] - b[0]);
        PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;();

        for (int i = 0; i &lt; n; i ++ ) {
            int[] r = g[i];
            //需要创建新组
            if (q.isEmpty() || q.peek() &gt;= r[0]) q.add(r[1]);
            else {
                //将该段放入更新当前组最大值
                int t = q.poll();
                q.add(r[1]);
            }
        }
        return q.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-最长递增子序列-ii" tabindex="-1"><a class="header-anchor" href="#problem-d-最长递增子序列-ii" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/" target="_blank" rel="noopener noreferrer">最长递增子序列 II<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线段树</strong></p><h2 id="_87场双周赛" tabindex="-1"><a class="header-anchor" href="#_87场双周赛" aria-hidden="true">#</a> 87场双周赛</h2><h4 id="problem-a-统计共同度过的日子数" tabindex="-1"><a class="header-anchor" href="#problem-a-统计共同度过的日子数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/count-days-spent-together/" target="_blank" rel="noopener noreferrer">统计共同度过的日子数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int[] t = new int[]{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    public int get(String s) {
        String[] ss = s.split(&quot;-&quot;);
        int a = Integer.parseInt(ss[0]), b = Integer.parseInt(ss[1]);
        int res = 0;
        for (int i = 0; i &lt; a; i ++ ) res += t[i];
        return res + b;
    }
    public int countDaysTogether(String s1, String s2, String s3, String s4) {
        int a = get(s1), b = get(s2), c = get(s3), d = get(s4);
        int res = Math.min(b, d) - Math.max(a, c) + 1;
        return Math.max(0, res);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-运动员和训练师的最大匹配数" tabindex="-1"><a class="header-anchor" href="#problem-b-运动员和训练师的最大匹配数" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/" target="_blank" rel="noopener noreferrer">运动员和训练师的最大匹配数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int matchPlayersAndTrainers(int[] a, int[] b) {
        Arrays.sort(a);
        Arrays.sort(b);
        int res = 0;
        for (int i = 0, j = 0; i &lt; a.length; i ++ ) {
            while (j &lt; b.length &amp;&amp; b[j] &lt; a[i]) j ++ ;
            if (j == b.length) break;
            if (a[i] &lt;= b[j]) {
                j ++ ;
                res ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-按位或最大的最小子数组长度" tabindex="-1"><a class="header-anchor" href="#problem-c-按位或最大的最小子数组长度" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/" target="_blank" rel="noopener noreferrer">按位或最大的最小子数组长度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] smallestSubarrays(int[] nums) {
        int n = nums.length;
        int[] p = new int[30];
        int[] res = new int[n];
        Arrays.fill(p, n);
        for (int i = n - 1; i &gt;= 0; i -- ) {
            int t = i;
            for (int j = 0; j &lt; 30; j ++ )
                if ((nums[i] &gt;&gt; j &amp; 1) == 1) p[j] = i;
                else if (p[j] != n) t = Math.max(p[j], t);
            res[i] = t - i + 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-完成所有交易的初始最少钱数" tabindex="-1"><a class="header-anchor" href="#problem-d-完成所有交易的初始最少钱数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/minimum-money-required-before-transactions/" target="_blank" rel="noopener noreferrer">完成所有交易的初始最少钱数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minimumMoney(int[][] transactions) {
        long sum = 0;
        for (int[] p : transactions) {
            int a = p[0], b = p[1];
            if (a &gt; b) sum += a - b;
        }
        long res = 0;
        for (int[] p : transactions) {
            int a = p[0], b = p[1];
            long s = sum;
            if (a &gt; b) s -= a - b;
            res = Math.max(res, s + a);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_311场周赛" tabindex="-1"><a class="header-anchor" href="#_311场周赛" aria-hidden="true">#</a> 311场周赛</h2><h4 id="problem-a-最小偶倍数" tabindex="-1"><a class="header-anchor" href="#problem-a-最小偶倍数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/smallest-even-multiple/" target="_blank" rel="noopener noreferrer">最小偶倍数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int smallestEvenMultiple(int n) {
        if (n % 2 == 0) return n;
        else return n * 2;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最长的字母序连续子字符串的长度" tabindex="-1"><a class="header-anchor" href="#problem-b-最长的字母序连续子字符串的长度" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/" target="_blank" rel="noopener noreferrer">最长的字母序连续子字符串的长度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestContinuousSubstring(String s) {
        char[] ss = s.toCharArray();
        int res = 0;
        for (int i = 0; i &lt; ss.length; i ++ ) {
            int j = i + 1;
            while (j &lt; ss.length &amp;&amp; ss[j] == ss[j - 1] + 1) j ++ ;
            res = Math.max(res, j - i);
            i = j - 1;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-反转二叉树的奇数层" tabindex="-1"><a class="header-anchor" href="#problem-c-反转二叉树的奇数层" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/" target="_blank" rel="noopener noreferrer">反转二叉树的奇数层<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：bfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void reverse(List&lt;TreeNode&gt; list) {
        int l = 0, r = list.size() - 1;
        while (l &lt; r) {
            TreeNode a = list.get(l), b = list.get(r);
            int t = a.val;
            a.val = b.val;
            b.val = t;
            l ++ ;
            r -- ;
        }
    } 
    public TreeNode reverseOddLevels(TreeNode root) {
        var q = new ArrayDeque&lt;TreeNode&gt;();
        q.add(root);
        int depth = -1;
        while (!q.isEmpty()) {
            int cur = q.size();
            var list = new ArrayList&lt;TreeNode&gt;();
            while (cur -- &gt; 0) {
                TreeNode node = q.poll();
                list.add(node);
                if (node.left != null) q.add(node.left);
                if (node.right != null) q.add(node.right);
            }
            depth ++ ;
            if (depth % 2 == 1) 
                reverse(list);
        }
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：dfs</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public void swap(TreeNode a, TreeNode b) {
        int t = a.val;
        a.val = b.val;
        b.val = t;
    }

    public void dfs(TreeNode a, TreeNode b, int d) {
        if (a == null) return;
        if (d % 2 == 1) swap(a, b);
        dfs(a.left, b.right, d + 1);
        dfs(a.right, b.left, d + 1); 
    }

    public TreeNode reverseOddLevels(TreeNode root) {
        dfs(root.left, root.right, 1);
        return root;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-字符串的前缀分数和" tabindex="-1"><a class="header-anchor" href="#problem-d-字符串的前缀分数和" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/" target="_blank" rel="noopener noreferrer">字符串的前缀分数和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：字典树</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    
    public class TrieNode {
        TrieNode[] child;
        int cnt;
        TrieNode() {
            child = new TrieNode[27];
            cnt = 1;
        }
    }
    
    TrieNode root = new TrieNode();
    
    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] == null) {
                p.child[c - &#39;a&#39;] = new TrieNode();
            } else {
                p.child[c - &#39;a&#39;].cnt ++ ;
            }
            p = p.child[c - &#39;a&#39;];
        }
    }

    public int search(String word) {
        TrieNode p = root;
        int res = 0;
        for (int i = 0; i &lt; word.length(); i++) {
            char c = word.charAt(i);
            if (p.child[c - &#39;a&#39;] != null) {
                p = p.child[c - &#39;a&#39;];
                res += p.cnt;
            }
        }
        return res;
    }

    public int[] sumPrefixScores(String[] words) {
        int n = words.length;
        for (String x : words) {
            insert(x);
        }
        int[] res = new int[n];
        for (int i = 0; i &lt; n; i ++ ) {
            String word = words[i];
            res[i] = search(word);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_312场周赛" tabindex="-1"><a class="header-anchor" href="#_312场周赛" aria-hidden="true">#</a> 312场周赛</h2><h4 id="problem-a-按身高排序" tabindex="-1"><a class="header-anchor" href="#problem-a-按身高排序" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/sort-the-people/" target="_blank" rel="noopener noreferrer">按身高排序<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String[] sortPeople(String[] names, int[] h) {
        var map = new HashMap&lt;Integer, String&gt;();
        for (int i = 0; i &lt; names.length; i ++ )
            map.put(h[i], names[i]);
        Arrays.sort(h);
        var list = new ArrayList&lt;String&gt;();
        for (int i = h.length - 1; i &gt;= 0; i -- )
            list.add(map.get(h[i]));
        return list.toArray(new String[h.length]);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-按位与最大的最长子数组" tabindex="-1"><a class="header-anchor" href="#problem-b-按位与最大的最长子数组" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/" target="_blank" rel="noopener noreferrer">按位与最大的最长子数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int longestSubarray(int[] nums) {
        int mx = 0, n = nums.length;
        for (int x : nums)
            mx = Math.max(mx, x);
        int res = 0, cur = 0;
        for (int i = 0; i &lt; n; i ++ )
            if (nums[i] == mx) {
                int j = i + 1;
                while (j &lt; n &amp;&amp; nums[j] == mx) j ++ ;
                res = Math.max(res, j - i);
                i = j;
            } 
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-找到所有好下标" tabindex="-1"><a class="header-anchor" href="#problem-c-找到所有好下标" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/find-all-good-indices/" target="_blank" rel="noopener noreferrer">找到所有好下标<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;Integer&gt; goodIndices(int[] nums, int k) {
        var n = nums.length;
        int[] f = new int[n], g = new int[n];
        Arrays.fill(f, 1); Arrays.fill(g, 1);
        for (int i = 1; i &lt; n; i ++ )
            if (nums[i] &lt;= nums[i - 1])
                f[i] = f[i - 1] + 1;
        for (int i = n - 1; i &gt; 0; i -- )
            if (nums[i] &gt;= nums[i - 1])
                g[i - 1] = g[i] + 1;
        var res = new ArrayList&lt;Integer&gt;();
        for (int i = k; i &lt; n - k; i ++ )
            if (f[i - 1] &gt;= k &amp;&amp; g[i + 1] &gt;= k)
                res.add(i);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-好路径的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-好路径的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/number-of-good-paths/" target="_blank" rel="noopener noreferrer">好路径的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：并查集</strong></p><h2 id="_88场双周赛" tabindex="-1"><a class="header-anchor" href="#_88场双周赛" aria-hidden="true">#</a> 88场双周赛</h2><h4 id="problem-a-删除字符使频率相同" tabindex="-1"><a class="header-anchor" href="#problem-a-删除字符使频率相同" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/remove-letter-to-equalize-frequency/" target="_blank" rel="noopener noreferrer">删除字符使频率相同<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean equalFrequency(String s) {
        int[] map = new int[26];
        for (char x : s.toCharArray()) map[x - &#39;a&#39;] ++ ;
        for (int i = 0; i &lt; 26; i ++ )
            if (map[i] &gt; 0) {
                map[i] -- ;
                int t = 0;
                boolean res = true;
                for (int j = 0; j &lt; 26; j ++ ) 
                    if (map[j] &gt; 0) {
                        if (t == 0) t = map[j];
                        else if (map[j] != t) res = false;
                    }
                map[i] ++ ;
                if (res) return res;
            }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最长上传前缀" tabindex="-1"><a class="header-anchor" href="#problem-b-最长上传前缀" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/longest-uploaded-prefix/" target="_blank" rel="noopener noreferrer">最长上传前缀<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class LUPrefix {
    boolean[] st;
    int n, now = 0;
    public LUPrefix(int _n) {
        n = _n;
        st = new boolean[n + 1];
    }
    
    public void upload(int x) {
        st[x] = true;
        while (now &lt; n &amp;&amp; st[now + 1]) now ++ ;
    }
    
    public int longest() {
        return now;
    }
}

/**
 * Your LUPrefix object will be instantiated and called as such:
 * LUPrefix obj = new LUPrefix(n);
 * obj.upload(video);
 * int param_2 = obj.longest();
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-所有数对的异或和" tabindex="-1"><a class="header-anchor" href="#problem-c-所有数对的异或和" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/bitwise-xor-of-all-pairings/" target="_blank" rel="noopener noreferrer">所有数对的异或和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：脑筋急转弯</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int xorAllNums(int[] a, int[] b) {
        int n = a.length, m = b.length;
        int res = 0;
        if (n % 2 == 1) 
            for (int x : b) 
                res ^= x;        
        if (m % 2 == 1) 
            for (int x : a) 
                res ^= x;    
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-满足不等式的数对数目" tabindex="-1"><a class="header-anchor" href="#problem-d-满足不等式的数对数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/" target="_blank" rel="noopener noreferrer">满足不等式的数对数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：树状数组</strong></p><h2 id="_313场周赛" tabindex="-1"><a class="header-anchor" href="#_313场周赛" aria-hidden="true">#</a> 313场周赛</h2><h4 id="problem-a-公因子的数目" tabindex="-1"><a class="header-anchor" href="#problem-a-公因子的数目" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/number-of-common-factors/" target="_blank" rel="noopener noreferrer">公因子的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int commonFactors(int a, int b) {
        int res = 0;
        for (int i = 1; i &lt;= Math.min(a, b); i ++ ) {
            if (a % i == 0 &amp;&amp; b % i == 0)
                res ++ ;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-沙漏的最大总和" tabindex="-1"><a class="header-anchor" href="#problem-b-沙漏的最大总和" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/" target="_blank" rel="noopener noreferrer">沙漏的最大总和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：前缀和</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int maxSum(int[][] g) {
        int n = g.length, m = g[0].length;
        int[][] s = new int[n + 1][m + 1];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m; j ++ ) {
                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + g[i][j];
            }
        }
        int res = 0;
        for (int i = 2; i &lt; n; i ++ )
            for (int j = 2; j &lt; m; j ++ )
                res = Math.max(res, s[i + 1][j + 1] - s[i + 1][j - 2] - s[i - 2][j + 1] + s[i - 2][j - 2] - g[i - 1][j] - g[i - 1][j - 2]);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最小-xor" tabindex="-1"><a class="header-anchor" href="#problem-c-最小-xor" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimize-xor/" target="_blank" rel="noopener noreferrer">最小 XOR<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimizeXor(int a, int b) {
        int n = Integer.bitCount(b);
        int res = 0;
        for (int i = 32 - 1; i &gt;= 0 &amp;&amp; n != 0; i -- ) 
            if ((a &gt;&gt; i &amp; 1) == 1) {
                res += 1 &lt;&lt; i;
                n -- ;
            }
        for (int i = 0; i &lt; 32 &amp;&amp; n != 0; i ++ )
            if ((res &gt;&gt; i &amp; 1) == 0) {
                res += 1 &lt;&lt; i;
                n -- ;
            }
        
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-对字母串可执行的最大删除数" tabindex="-1"><a class="header-anchor" href="#problem-d-对字母串可执行的最大删除数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/" target="_blank" rel="noopener noreferrer">对字母串可执行的最大删除数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：线性dp&amp;字符串哈希</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int P = 131, n;
    long[] h, p;
    public long get(int l, int r) {
        return h[r] - h[l - 1] * p[r - l + 1];
    }
    public int deleteString(String s) {
        n = s.length();
        h = new long[n + 1];
        p = new long[n + 1];
        p[0] = 1;
        for (int i = 1; i &lt;= n; i ++ ) {
            p[i] = p[i - 1] * P;
            h[i] = h[i - 1] * P + s.charAt(i - 1);
        }
        //表示将[i, n]这个后缀所需最大操作数
        int[] f = new int[n + 1];
        Arrays.fill(f, 1);
        for (int i = n; i &gt; 0; i -- ) 
            for (int j = 1; j &lt;= (n - i + 1) / 2; j ++ )
                if (get(i, i + j - 1) == get(i + j, i + j * 2 - 1))
                    f[i] = Math.max(f[i], f[i + j] + 1);
        
        return f[1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_314场周赛" tabindex="-1"><a class="header-anchor" href="#_314场周赛" aria-hidden="true">#</a> 314场周赛</h2><h4 id="problem-a-处理用时最长的那个任务的员工" tabindex="-1"><a class="header-anchor" href="#problem-a-处理用时最长的那个任务的员工" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/" target="_blank" rel="noopener noreferrer">处理用时最长的那个任务的员工<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int hardestWorker(int n, int[][] logs) {
        var list = new ArrayList&lt;int[]&gt;();
        int pre = 0;
        for (int[] p : logs) {
            int a = p[0], b = p[1];
            list.add(new int[]{a, b - pre});
            pre = b;
        }
        list.sort((a, b) -&gt; {
            return a[1] == b[1] ? a[0] - b[0] : b[1] - a[1];
        });
        return list.get(0)[0];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-找出前缀异或的原始数组" tabindex="-1"><a class="header-anchor" href="#problem-b-找出前缀异或的原始数组" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/" target="_blank" rel="noopener noreferrer">找出前缀异或的原始数组<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：位运算</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] findArray(int[] p) {
        int n = p.length;
        int[] res = new int[n];
        res[0] = p[0];
        for (int i = 1; i &lt; n; i ++ ) {
            res[i] = p[i] ^ p[i - 1];
        }
        return res;
    }   
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-使用机器人打印字典序最小的字符串" tabindex="-1"><a class="header-anchor" href="#problem-c-使用机器人打印字典序最小的字符串" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/" target="_blank" rel="noopener noreferrer">使用机器人打印字典序最小的字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：贪心</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String robotWithString(String s) {
        var map = new int[26];
        var res = new StringBuilder();
        var stk = new ArrayDeque&lt;Character&gt;();
        var min = 0;
        for (char c : s.toCharArray()) map[c - &#39;a&#39;] ++ ;
        for (char c : s.toCharArray()) {
            -- map[c - &#39;a&#39;];
            while (min &lt; 26 &amp;&amp; map[min] == 0) min ++ ;
            stk.push(c);
            while (!stk.isEmpty() &amp;&amp; stk.peek() - &#39;a&#39; &lt;= min)
                res.append(stk.pop());
        }
        return res.toString();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-矩阵中和能被-k-整除的路径" tabindex="-1"><a class="header-anchor" href="#problem-d-矩阵中和能被-k-整除的路径" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/" target="_blank" rel="noopener noreferrer">矩阵中和能被 K 整除的路径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：动态规划</strong></p><h2 id="_89场双周赛" tabindex="-1"><a class="header-anchor" href="#_89场双周赛" aria-hidden="true">#</a> 89场双周赛</h2><h4 id="problem-a-有效时间的数目" tabindex="-1"><a class="header-anchor" href="#problem-a-有效时间的数目" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/number-of-valid-clock-times/" target="_blank" rel="noopener noreferrer">有效时间的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
        public int countTime(String time) {
            String[] temp = time.split(&quot;:&quot;);
            int ans1 = 1, ans2 = 1, ans3 = 1, ans4 = 1;
            if (temp[0].equals(&quot;??&quot;)) {
                ans1 = 3;
                ans2 = 8;
            } else if (temp[0].charAt(0) == &#39;?&#39; &amp;&amp; temp[0].charAt(1) != &#39;?&#39;) {
                if (temp[0].charAt(1) &gt;= &#39;4&#39; &amp;&amp; temp[0].charAt(1) &lt;= &#39;9&#39;) ans1 = 2;
                else ans1 = 3;
            } else if (temp[0].charAt(1) == &#39;?&#39; &amp;&amp; temp[0].charAt(0) != &#39;?&#39;) {
                if (temp[0].charAt(0) == &#39;2&#39;) ans2 = 4;
                else ans2 = 10;
            }
            if (temp[1].charAt(0) == &#39;?&#39;) {
                ans3 = 6;
            }
            if (temp[1].charAt(1) == &#39;?&#39;) {
                ans4 = 10;
            }
            return ans1 * ans2 * ans3 * ans4;
        }
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-二的幂数组中查询范围内的乘积" tabindex="-1"><a class="header-anchor" href="#problem-b-二的幂数组中查询范围内的乘积" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/range-product-queries-of-powers/" target="_blank" rel="noopener noreferrer">二的幂数组中查询范围内的乘积<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int mod = (int) 1e9 + 7;
    public int[] productQueries(int n, int[][] q) {
        var m = q.length;
        var p = new ArrayList&lt;Integer&gt;();
        for (var i = 0; i &lt; 30; i ++ ) 
            if ((n &gt;&gt; i &amp; 1) != 0)
                p.add(1 &lt;&lt; i);
        var res = new int[m];
        for (var i = 0; i &lt; m; i ++ ) {
            int l = q[i][0], r = q[i][1];
            var cur = 1l;
            for (var j = l; j &lt;= r; j ++ )
                cur = (cur * p.get(j)) % mod;
            res[i] = (int) cur;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-最小化数组中的最大值" tabindex="-1"><a class="header-anchor" href="#problem-c-最小化数组中的最大值" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimize-maximum-of-array/" target="_blank" rel="noopener noreferrer">最小化数组中的最大值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：二分</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int minimizeArrayValue(int[] nums) {
        int n = nums.length;
        int k = 0;
        for (int x : nums) k = Math.max(k, x);
        int l = 0, r = k;
        while (l &lt; r) {
            int mid = l + r &gt;&gt; 1;
            var A = new long[n];
            for (int i = 0; i &lt; n; i ++ )
                A[i] = nums[i] * 1l;
            for (int i = n - 1; i &gt; 0; i -- )
                if (A[i] &gt; mid) {
                    var p = A[i] - mid * 1l;
                    A[i] = mid;
                    A[i - 1] += p;
                }
            if (mid &gt;= A[0]) r = mid;
            else l = mid + 1;
        }
        return r;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-创建价值相同的连通块" tabindex="-1"><a class="header-anchor" href="#problem-d-创建价值相同的连通块" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/create-components-with-same-value/" target="_blank" rel="noopener noreferrer">创建价值相同的连通块<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><h2 id="_315场周赛" tabindex="-1"><a class="header-anchor" href="#_315场周赛" aria-hidden="true">#</a> 315场周赛</h2><h4 id="problem-a-与对应负数同时存在的最大正整数" tabindex="-1"><a class="header-anchor" href="#problem-a-与对应负数同时存在的最大正整数" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/" target="_blank" rel="noopener noreferrer">与对应负数同时存在的最大正整数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int findMaxK(int[] nums) {
        var set = new HashSet&lt;&gt;();
        for (int x : nums) 
            if (x &lt; 0)
                set.add(x);
        var res = 0;
        for (int x: nums)
            if (x &gt; 0 &amp;&amp; set.contains(-x))
                res = Math.max(res, x);
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-反转之后不同整数的数目" tabindex="-1"><a class="header-anchor" href="#problem-b-反转之后不同整数的数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/" target="_blank" rel="noopener noreferrer">反转之后不同整数的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int countDistinctIntegers(int[] nums) {
        var set = new HashSet&lt;Integer&gt;();
        for (int x : nums) {
            set.add(x);
            var y = 0;
            for (int k = x; k != 0; k /= 10)
                y = y * 10 + k % 10;
            set.add(y);
        }
        return set.size();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-反转之后的数字和" tabindex="-1"><a class="header-anchor" href="#problem-c-反转之后的数字和" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/" target="_blank" rel="noopener noreferrer">反转之后的数字和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public boolean sumOfNumberAndReverse(int num) {
        for (int x = 0; x &lt;= num; x ++ ) {
            int y = 0;
            for (int j = x; j != 0; j /= 10)
                y = y * 10 + j % 10;
            if (x + y == num) return true;
        }
        return false;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-统计定界子数组的数目" tabindex="-1"><a class="header-anchor" href="#problem-d-统计定界子数组的数目" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/" target="_blank" rel="noopener noreferrer">统计定界子数组的数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：滑动窗口</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long countSubarrays(int[] nums, int minK, int maxK) {
        var res = 0l;
        int n = nums.length, x = -1, y = -1, k = -1;
        for (int i = 0; i &lt; n; i ++ ) {
            int v = nums[i];
            if (v == minK) x = i;
            if (v == maxK) y = i;
            if (v &lt; minK || v &gt; maxK) k = i;
            res += Math.max(Math.min(x, y) - k, 0);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_316场周赛" tabindex="-1"><a class="header-anchor" href="#_316场周赛" aria-hidden="true">#</a> 316场周赛</h2><h4 id="problem-a-判断两个事件是否存在冲突" tabindex="-1"><a class="header-anchor" href="#problem-a-判断两个事件是否存在冲突" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict/" target="_blank" rel="noopener noreferrer">判断两个事件是否存在冲突<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int get(String s) {
        String[] ss = s.split(&quot;:&quot;);
        return Integer.parseInt(ss[0]) * 60 + Integer.parseInt(ss[1]);
    }
    public boolean haveConflict(String[] a, String[] b) {
        int t1 = get(a[0]), t2 = get(a[1]);
        int t3 = get(b[0]), t4 = get(b[1]);
        if (t2 &lt; t3 || t4 &lt; t1) return false;
        return true;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最大公因数等于-k-的子数组数目" tabindex="-1"><a class="header-anchor" href="#problem-b-最大公因数等于-k-的子数组数目" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/" target="_blank" rel="noopener noreferrer">最大公因数等于 K 的子数组数目<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
    public int subarrayGCD(int[] nums, int k) {
        int n = nums.length, res = 0;
        for (int i = 0; i &lt; n; i ++ ) {
            int p = nums[i];
            for (int j = i; j &lt; n; j ++ ) {
                p = gcd(p, nums[j]);
                if (p == k) res ++ ;
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-使数组相等的最小开销" tabindex="-1"><a class="header-anchor" href="#problem-c-使数组相等的最小开销" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimum-cost-to-make-array-equal/" target="_blank" rel="noopener noreferrer">使数组相等的最小开销<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long minCost(int[] nums, int[] cost) {
        var n = nums.length;
        var list = new ArrayList&lt;int[]&gt;();
        for (int i = 0; i &lt; n; i ++ )
            list.add(new int[]{nums[i], cost[i]});
        Collections.sort(list, (a, b) -&gt; {
            return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
        });
        var tot = 0l;
        for (int x : cost)
            tot += x;
        var note = 0l;
        var choose = 0;
        for (int[] p : list) {
            int num = p[0], c = p[1];
            note += c;
            if (note * 2 &gt;= tot) {
                choose = num;
                break;
            }
        }
        var res = 0l;
        for (int[] p : list) {
            int num = p[0], c = p[1];
            res += c * 1l * Math.abs(num - choose);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def minCost(self, nums: List[int], cost: List[int]) -&gt; int:
        tem = sorted(zip(nums, cost))
        tot, note = sum(cost), 0
        for num, c in tem:
            note += c
            if note * 2 &gt;= tot:
                choose = num
                break
        return sum(c * abs(num - choose) for num, c in tem)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-使数组相似的最少操作次数" tabindex="-1"><a class="header-anchor" href="#problem-d-使数组相似的最少操作次数" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/" target="_blank" rel="noopener noreferrer">使数组相似的最少操作次数<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public long makeSimilar(int[] nums, int[] target) {
        var n = nums.length;
        var a = new Integer[n];
        var b = new Integer[n];
        for(var i = 0; i &lt; n; i ++ ){
            a[i] = nums[i];
            b[i] = target[i];
        }
        Arrays.sort(a, (o1, o2)-&gt; o1 % 2 == o2 % 2 ? o1 - o2 : o1 % 2 - o2 % 2);
        Arrays.sort(b, (o1, o2)-&gt; o1 % 2 == o2 % 2 ? o1 - o2 : o1 % 2 - o2 % 2);
        var res = 0l;
        for (var i = 0; i &lt; n; i ++ )
            res += Math.abs(a[i] - b[i]);
        return res &gt;&gt; 2;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution:
    def makeSimilar(self, nums: List[int], target: List[int]) -&gt; int:
        nums.sort(key=lambda x: (x % 2, x))
        target.sort(key=lambda x: (x % 2, x))
        return sum(abs(x - y) for x, y in zip(nums, target)) // 4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_90场双周赛" tabindex="-1"><a class="header-anchor" href="#_90场双周赛" aria-hidden="true">#</a> 90场双周赛</h2><h4 id="problem-a-差值数组不同的字符串" tabindex="-1"><a class="header-anchor" href="#problem-a-差值数组不同的字符串" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/odd-string-difference/" target="_blank" rel="noopener noreferrer">差值数组不同的字符串<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public String oddString(String[] words) {
        int n = words.length, m = words[0].length();
        int[][] d = new int[n][m - 1];
        for (int i = 0; i &lt; n; i ++ ) {
            for (int j = 0; j &lt; m - 1; j ++ ) {
                d[i][j] = words[i].charAt(j + 1) - words[i].charAt(j);
            }
        }
        Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            var sb =  new StringBuilder();
            for (int c : d[i])
                sb.append(c).append(&quot;,&quot;);
            var s = sb.toString();
            if (!map.containsKey(s)) map.put(s, new ArrayList&lt;&gt;());
            map.get(s).add(i);
        }
        for (var k : map.keySet()) {
            if (map.get(k).size() == 1)
                return words[map.get(k).get(0)];
        }
        return &quot;&quot;;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-距离字典两次编辑以内的单词" tabindex="-1"><a class="header-anchor" href="#problem-b-距离字典两次编辑以内的单词" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/words-within-two-edits-of-dictionary/" target="_blank" rel="noopener noreferrer">距离字典两次编辑以内的单词<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;String&gt; twoEditWords(String[] q, String[] d) {
        var res = new ArrayList&lt;String&gt;();
        for (var s1 : q) {
            for (var s2 : d) {
                int k = 0;
                for (int i = 0; i &lt; s1.length(); i ++ ) {
                    if (s1.charAt(i) != s2.charAt(i)) k ++ ;
                    if (k &gt; 2) break;
                }
                if (k &lt;= 2) {
                    res.add(s1);
                    break;
                }
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-摧毁一系列目标" tabindex="-1"><a class="header-anchor" href="#problem-c-摧毁一系列目标" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/destroy-sequential-targets/" target="_blank" rel="noopener noreferrer">摧毁一系列目标<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：枚举</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int destroyTargets(int[] nums, int space) {
        var map = new TreeMap&lt;Integer, Integer&gt;();
        Arrays.sort(nums);
        for (int x : nums) {
            map.put(x % space, map.getOrDefault(x % space, 0) + 1);
        }
        var n = nums.length;
        int res = 0, p = 0;
        for (var i = 0; i &lt; n; i ++ ) {
            int x = nums[i] % space;
            if (map.get(x) &gt; p) {
                res = nums[i];
                p = map.get(x);
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-下一个更大元素-iv" tabindex="-1"><a class="header-anchor" href="#problem-d-下一个更大元素-iv" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/next-greater-element-iv/" target="_blank" rel="noopener noreferrer">下一个更大元素 IV<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：单调栈</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] secondGreaterElement(int[] nums) {
        var n = nums.length;
        var res = new int[n];
        Arrays.fill(res, -1);
        var s1 = new ArrayDeque&lt;Integer&gt;();
        var s2 = new ArrayDeque&lt;Integer&gt;();
        var tem = new ArrayDeque&lt;Integer&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            while (!s2.isEmpty() &amp;&amp; nums[s2.peek()] &lt; nums[i])
                res[s2.pop()] = nums[i];
            while (!s1.isEmpty() &amp;&amp; nums[s1.peek()] &lt; nums[i]) 
                tem.push(s1.pop());
            while (!tem.isEmpty()) s2.push(tem.pop());
            s1.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解法：单调栈&amp;堆</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int[] secondGreaterElement(int[] nums) {
        var n = nums.length;
        var res = new int[n];
        Arrays.fill(res, -1);
        var s1 = new ArrayDeque&lt;Integer&gt;();
        var q = new PriorityQueue&lt;Integer&gt;((a, b) -&gt; nums[a] - nums[b]);
        for (int i = 0; i &lt; n; i ++ ) {
            while (!q.isEmpty() &amp;&amp; nums[q.peek()] &lt; nums[i]) 
                res[q.poll()] = nums[i];  
            while (!s1.isEmpty() &amp;&amp; nums[s1.peek()] &lt; nums[i]) 
                q.add(s1.pop());
            s1.push(i);
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_317场周赛" tabindex="-1"><a class="header-anchor" href="#_317场周赛" aria-hidden="true">#</a> 317场周赛</h2><h4 id="problem-a-可被三整除的偶数的平均值" tabindex="-1"><a class="header-anchor" href="#problem-a-可被三整除的偶数的平均值" aria-hidden="true">#</a> Problem A - <a href="https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/" target="_blank" rel="noopener noreferrer">可被三整除的偶数的平均值<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int averageValue(int[] nums) {
        int sum = 0, cnt = 0;
        for (var x : nums)
            if (x % 2 == 0 &amp;&amp; x % 3 == 0) {
                sum += x;
                cnt ++ ;
            }
        return cnt == 0 ? 0 : sum / cnt;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-b-最流行的视频创作者" tabindex="-1"><a class="header-anchor" href="#problem-b-最流行的视频创作者" aria-hidden="true">#</a> Problem B - <a href="https://leetcode.cn/problems/most-popular-video-creator/" target="_blank" rel="noopener noreferrer">最流行的视频创作者<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public List&lt;List&lt;String&gt;&gt; mostPopularCreator(String[] creators, String[] ids, int[] views) {
        int n = creators.length;
        var max = 0l;
        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
        Map&lt;String, Long&gt; m1 = new HashMap&lt;&gt;();
        Map&lt;String, Integer&gt; m2 = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i ++ ) {
            var creator = creators[i];
            var id = ids[i];
            var view = views[i];
            m1.put(creator, m1.getOrDefault(creator, 0l) + view);
            max = Math.max(max, m1.get(creator));
            if (m2.containsKey(creator)) {
                if (view &gt; views[m2.get(creator)]) {
                    m2.put(creator, i);
                } else if (view == views[m2.get(creator)]) {
                    if (ids[m2.get(creator)].compareTo(id) &gt; 0) {
                        m2.put(creator, i);
                    }
                }
            } else {
                m2.put(creator, i);
            }
        }
        for (var creator : m1.keySet()) {
            if (m1.get(creator) == max) {
                res.add(List.of(creator, ids[m2.get(creator)]));
            }
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-c-美丽整数的最小增量" tabindex="-1"><a class="header-anchor" href="#problem-c-美丽整数的最小增量" aria-hidden="true">#</a> Problem C - <a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/" target="_blank" rel="noopener noreferrer">美丽整数的最小增量<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：数学&amp;模拟</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>class Solution {
    public int f(List&lt;Integer&gt; A) {
        var sm = 0;
        for (var x : A) sm += x;
        return sm;
    }
    public long makeIntegerBeautiful(long n, int target) {
        var A = new ArrayList&lt;Integer&gt;();
        var t = n;
        while (t != 0) {
            A.add((int)(t % 10));
            t /= 10;
        }
        A.add(0);
        if (f(A) &lt;= target) return 0;
        var res = 0l;
        var p = 1l;
        for (var i = 0; i + 1 &lt; A.size(); i ++, p *= 10) {
            res += (10l - A.get(i)) * p;
            A.set(i, 0);
            A.set(i + 1, A.get(i + 1) + 1);
            if (A.get(i + 1) == 10) continue;
            if (f(A) &lt;= target) break;
        }
        return res;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="problem-d-移除子树后的二叉树高度" tabindex="-1"><a class="header-anchor" href="#problem-d-移除子树后的二叉树高度" aria-hidden="true">#</a> Problem D - <a href="https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/" target="_blank" rel="noopener noreferrer">移除子树后的二叉树高度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h4><p><strong>解法：dfs</strong></p></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/q1061709994/blog/edit/main/demo/src/posts/article2.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/10/30 10:56:49</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1061709994@qq.com">huan</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/blog/posts/article1.html" class="nav-link prev" aria-label="刷题笔记"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><span class="icon iconfont icon-article"></span>刷题笔记</div></a><a href="/blog/posts/article3.html" class="nav-link next" aria-label="算法模板"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">算法模板<span class="icon iconfont icon-article"></span></div></a></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">主题: VuePress Theme Hope</div><div class="copyright">Copyright © 2022 huan</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/blog/assets/app.c628af9c.js" defer></script>
  </body>
</html>
